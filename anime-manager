#!/bin/sh
# shellcheck disable=SC2016,SC2034
set -o errexit
set -o nounset

#*********************************
#* ANIME MANAGER - Watch and sync anime from your terminal.
# Project repository: https://github.com/anma-dev/Anime-Manager
# LICENSE: GNU GPL 3.0
VERSION="v0.5.3-alpha"
#*********************************

#*********************************
#* UTILITY FUNCTIONS
#*********************************

#*********************************
#* GENERAL UTILITIES
#*********************************

# Empties the watch history file
delete_watch_history() {
    printf "" >"$WATCH_HISTORY_FILE"
}

# Internet connectivity check with random selection of hosts
connectivity_check() {
    connectivity_check_tmout=3
    urls=$(array "ubuntu.com" "google.com" "duckduckgo.com" "bing.com")
    urls_len=$(printf '%s\n' "$urls" | array_len | sed "s/[[:space:]]//g")
    rand_id=$(shuf -i 0-"$((urls_len - 1))" -n 1)
    rand_url=$(printf '%s\n' "$urls" | array_nth "$rand_id")
    if [ "$OSTYPE" = "Darwin" ]; then
        if printf "%b" "GET https://$rand_url HTTP/1.0\n\n" | nc -G $connectivity_check_tmout "$rand_url" 443 >/dev/null 2>&1; then
            true
        else
            false
        fi
    elif [ "$OSTYPE" = "Linux" ]; then
        if printf "%b" "GET https://$rand_url HTTP/1.0\n\n" | timeout $connectivity_check_tmout nc "$rand_url" 443 >/dev/null 2>&1; then
            true
        else
            false
        fi
    fi
}

#! Unused
torrent_is_playing() {
    process_name="$(ps -p "$webtorrentpid" -o comm=)"
    if [ "$process_name" = "WebTorrent" ]; then
        true
    else
        false
    fi
}

# get the shell configuration file path
get_shell_config_file() {
    get_shell_config_file_cfg_file=""
    if [ "$SHELL" = "/bin/bash" ]; then
        [ "$OSTYPE" = "Linux" ] && touch "$HOME/.bashrc" && get_shell_config_file_cfg_file="$HOME/.bashrc"
        [ "$OSTYPE" = "Darwin" ] && touch "$HOME/.bash_profile" && get_shell_config_file_cfg_file="$HOME/.bash_profile"
    fi
    # nvm on macos needs the shell config file
    [ "$SHELL" = "/bin/zsh" ] && touch "$HOME/.zshrc" && get_shell_config_file_cfg_file="$HOME/.zshrc"
    printf "%s" "$get_shell_config_file_cfg_file"
}

# Clear all modifiers. A 'modifier' for us is a flow control variable for the
# menu navigation
clear_modifiers() {
    random_anime=0
    random_airing=0
    prompt=""
    sort_airing=0
    sort_score=0
    anime_title=""
    entry_index=""
    cur_anime_episode=""
    status=""
    new_status=""
    last_watched_ep=""
    nyaa_search_res=""
    play_status=$PLAY_STATUS_WAITING
    # do not clear player source when in playlist mode
    [ "$playlist_mode" -eq 0 ] && player_source=""
    magnet_link=""
    play_method_menu_opt=""
    debug_match_info=""
    file_list=""
    file_index=""
    animdl_playthrough=0
    animdl_search_index=1
    nyaa_search_ret_code=""
    watch_choice=""
    list_choice=""
    media_player_helper=""
}

reset_logs() {
    echo >"$WEBTORRENT_LOGFILE"
    echo >"$TRACKMA_LOGFILE"
    echo >"$ANIMDL_LOGFILE"
    # echo > "$CURRENTLY_PLAYING_LOGFILE"
    echo >"$NYAA_SEARCH_LOGFILE"
    echo >"$NYAA_FE_LOGFILE"
}

# returns a substring of a string
# starting from the beginning
start_substring() {
    cut_string_string="$1"
    cut_string_end_id="$2"
    printf "%s" "$cut_string_string" | cut -c1-"$cut_string_end_id"
}

get_playback_time() {
    case "$MEDIA_PLAYER_APP" in
    "vlc")
        playback_time="$(printf "get_time\n" | $netcat_comm "$MEDIA_PLAYER_VLC_SOCKET" 2>/dev/null)"
        ;;
    "mpv")
        playback_time=$(printf '{ "command": ["get_property", "playback-time"] }\n' | $netcat_comm "$MEDIA_PLAYER_MPV_SOCKET" 2>/dev/null)
        ;;
    "iina")
        playback_time=$(printf '{ "command": ["get_property", "playback-time"] }\n' | $netcat_comm "$MEDIA_PLAYER_IINA_SOCKET" 2>/dev/null)
        ;;
    esac
}

get_video_length() {
    case "$MEDIA_PLAYER_APP" in
    "vlc")
        playback_length="$(printf "get_length\n" | $netcat_comm "$MEDIA_PLAYER_VLC_SOCKET" 2>/dev/null)"
        ;;
    "mpv")
        playback_length=$(printf '{ "command": ["get_property", "duration"] }\n' | $netcat_comm "$MEDIA_PLAYER_MPV_SOCKET" 2>/dev/null)
        ;;
    "iina")
        playback_length=$(printf '{ "command": ["get_property", "duration"] }\n' | $netcat_comm "$MEDIA_PLAYER_IINA_SOCKET" 2>/dev/null)
        ;;
    esac
}

# approximate*
get_playback_percent() {
    case "$MEDIA_PLAYER_APP" in
    "vlc")
        get_video_length
        get_playback_time
        cur_playback_percent=$((playback_time * 100 / playback_length))
        ;;
    "mpv")
        cur_playback_percent=$(printf '{ "command": ["get_property", "percent-pos"] }\n' | $netcat_comm "$MEDIA_PLAYER_MPV_SOCKET" 2>/dev/null | jq --raw-output '.data' | cut -d. -f1)
        ;;
    "iina")
        cur_playback_percent=$(printf '{ "command": ["get_property", "percent-pos"] }\n' | $netcat_comm "$MEDIA_PLAYER_IINA_SOCKET" 2>/dev/null | jq --raw-output '.data' | cut -d. -f1)
        ;;
    esac
    if [ -z "$cur_playback_percent" ] || [ -n "$(printf "%s" "$cur_playback_percent" | sed -n "/null/p")" ]; then
        cur_playback_percent=0
    fi
}

# trim long show titles
trim() {
    MAX_MENU_TITLE_SERIES_LEN=20
    title="$1"
    c_count=$(printf "%s" "$title" | wc -c | sed "s/ //g")
    if [ "$c_count" -gt $MAX_MENU_TITLE_SERIES_LEN ]; then
        printf "%s" "$title" | cut -c 1-"$MAX_MENU_TITLE_SERIES_LEN" | sed "s/$/(...)/"
    else
        printf "%s" "$title"
    fi
}

line_to_remove() {
    lines_to_remove="$((lines_to_remove + 1))"
}

# sanitizes a string to be used in an extended regular expression
# used for updating watch history file
sanitize_ext_regex_function_code='sanitize_ext_regex() {
    printf "%s" "$1" |
        sed "s,$(printf "\033")\\[[0-9;]*[a-zA-Z],," |
        sed "s,$(printf "\033")\\[[0-9;]*[a-zA-Z],,g" |
        sed "s,\033\[[0-9;]*[a-zA-Z],,g" |
        sed "s/[]\/\$*.^+()\"['"'"'-]/\\\&/g" |
        sed "s/ $//"
}'
eval "$sanitize_ext_regex_function_code"

# clear n number of lines from output
# caveat: wrapped lines
clear_lines() {
    if [ "$DEBUG" -eq 0 ]; then
        while [ "$lines_to_remove" -gt 0 ]; do
            printf "%b" "${OVERWRITE}"
            lines_to_remove=$((lines_to_remove - 1))
        done
    fi
}

sanitize_bash() {
    printf "%s" "$1" | LC_ALL=C sed -e 's/[^a-zA-Z0-9,._+@%/-]/\\&/g; 1{$s/^$/""/}; 1!s/^/"/; $!s/$/"/'
}

getcwd() {
    printf "%s" "$(lsof -p "$$" | grep cwd | awk '{print $9}')"
}

# Create a safe temporary filename in a posix-compliant way
get_temp_filename() {
    {
        posix_mktemp_file_file=$(
            (mktemp -u "$TMP_PATH/anmaXXXXXXXX") 2>/dev/null
        )
    } || {
        posix_mktemp_file_file=$TMP_PATH/anma$$-$(awk 'BEGIN { srand(); print int(rand()*32768) }' /dev/null)
    } || exit $?
    printf "%s" "$posix_mktemp_file_file"
}

get_xxhash() {
    hash_input="$1"
    hash_title_hash="$(printf "%s" "$hash_input" | xxh128sum | sed "s/[[:space:]]*stdin//g")"
    printf "%s" "$hash_title_hash"
}

# Prints the account currently in use by Trackma
print_account() {
    clear_lines
    printf "$SUBTITLE_COLOR%s$RESET" "      ðŸ‘¤ ${USERNAME}"
}

# Prints a message to inform the user that they are in incognito mode
print_incognito_msg() {
    clear_lines
    printf "      "
    printf "$INCOGNITO_MODE_COLORS%s$RESET" "ðŸ•µ  INCOGNITO MODE"
}

print_subheader() {
    if [ "$INCOGNITO_MODE" -eq 1 ]; then
        print_incognito_msg
    else
        print_account
    fi
    printf " â”‚"
    if [ "$playlist_mode" -eq 1 ]; then
        printf "%b" " ${MSG_WARN_COLOR}AUTO UPDATE ON${RESET} â”‚"
        printf "%b" " ${MSG_HELP_COLOR}ðŸŽ¦ PLAYLIST MODE${RESET} â”‚"
    elif [ "$AUTO_UPDATE" -eq 1 ]; then
        printf "%b" " ${MSG_WARN_COLOR}AUTO UPDATE ON${RESET} â”‚"
    fi
    printf "\n"
}

# Print the application logo.
# The logos are compressed for efficiency.
paint_logo() {
    # print the logos
    LOGO_B64=$LOGO_DEFAULT_B64
    # special dates
    if [ "$DATE_MONTH" -eq 10 ] && [ "$DATE_DAY" -eq 31 ]; then
        LOGO_B64=$LOGO_HALLOWEEN_B64
    fi
    if [ "$DATE_MONTH" -eq 12 ]; then
        if [ "$DATE_DAY" -eq 24 ] || [ "$DATE_DAY" -eq 25 ]; then
            LOGO_B64=$LOGO_XMAS_B64
        fi
    fi
    [ "$MONOCHROME_LOGO" -eq 1 ] && LOGO_B64=$LOGO_MONOCHROME
    if [ "$DEBUG" -eq 0 ]; then
        tput clear
        printf "%b\n" "$(
            base64 -d <<EOF | gunzip
$LOGO_B64
EOF
        )"
    fi
    printf "$TITLE_COLOR%s$RESET\n" "      ðŸ¿ Watch and Sync Anime from Your Terminal"
    printf "$MSG_HELP_COLOR%s$RESET\n" "         Use arrow keys/mouse scroll to navigate. Type to filter results" && echo

}

#*********************************
#* INITIALIZATION
# Defaults, set environment variables, parse arguments, imports, etc
#*********************************

# Override locale categories
eval export "$(locale)"
unset LC_ALL
LANG="C"
LC_ALL="C"
LC_COLLATE="C"
LC_CTYPE="C"
LC_MESSAGES="C"
LC_MONETARY="C"
LC_NUMERIC="C"
LC_TIME="C"
LC_ADDRESS="C"
LC_IDENTIFICATION="C"
LC_MEASUREMENT="C"
LC_NAME="C"
LC_PAPER="C"
LC_TELEPHONE="C"
LANGUAGE="en_US.UTF-8"
export LANG LC_ALL \
    LC_COLLATE \
    LC_CTYPE \
    LC_MESSAGES \
    LC_MONETARY \
    LC_NUMERIC \
    LC_TIME \
    LANGUAGE \
    LC_ADDRESS \
    LC_IDENTIFICATION \
    LC_MEASUREMENT \
    LC_NAME \
    LC_PAPER \
    LC_TELEPHONE \
    LANGUAGE

#* IMPORTS
. ./lib/array

#* DEFAULTS
LOGO_MONOCHROME="H4sIABqJ4GMAA+NSAINH0zoeTWsAow5kTguQMxHMmggXbkFXpvC4oQG3LBYTscs0IJmIrIYLyYktYATVNhGMQJwGiHq4cANcBsOJ6LI4TMQig+ZpJDUNcCc2wMxowMJpQBNGk4E4EYsskRwUG1DsAnPKDPRM9Yx1E3MKMhIBoQHlpvYBAAA="
LOGO_DEFAULT_B64="H4sIABuJ4GMAA8XWvW7cMAwA4L2vkEUv0EIS9WOBD9KhU1EU6BAjHYrOHjJkvSVTH6DPlb5IqfOdTZFyfElz6HC5yweSkixa9s0nGNCjj/H4seO7GynmxeJeLR+VfOUSMsmtki9K7pSMStrKXs7nKD+U3F2Q1Qj9+p8Srib2WuJVR11RVB9eT1y+msC1xKqOuqKoHvsHefr1W1lztlnVd28krqSuPD0+dGy60Npc2Vuz9KJktW27f36EIR+jDh2bLorrVXvYrQZ6bifrxT0oM3tRuehqm2aU/Jn2okJnzNCpH/RKn4lr66kePEovSlbbtleMkDr9+4zdKzOdqHYE36m2bTrX7EXFThe+yEwnqh2h07+bZjpRr68mckMRp+Is5g1EPmm3RM4o6s7oWqf7gurRzShxPvUMEjqZCxl9OwL9CvJK07tSVJkRk4qLmEU1j4PK9FjU3ACd2uCKTkVadF6VJAQxMlGQcT5T28hhNjG1FX2gM0Iej74ewiLuSHJkR48guRZP32rVZ1SRavNcoZeyduyZ5NiWXkplv7lE7/Zb2A5DPRLFMFBJxgX0SU58E7NKdxWNJHUlHX0XNfEe2oKg7pYZzX5cQlDNd8ZJorrmFioaSdCLg6YidRm920FQaCuahhxCuw2w4v0elgGhvYXPth6gdKvSXPi2XCIOS0QYWnFKPEJhYk/CZ7TagdlQMDS3CB3XZ5uUGS4JQ7OBYVjssGcZg29yM9L7V2DbXCVgABnlpCUcbMcojm3xIjyKjthhtoOwuGsBc5xt4kZrZUddgJPwqA3z0jxmuiKsF6rYKuzcXGyNcphppUNTa7V1BRZT7hittEiLsy31oJzMcAGMTdfQ37MdLrQ1N2OyGB0b4Sw8Ki12YBYHjL6xuNjELVYzSngUPa5pbtBU6xksNnHz7Qj0r8PYdGE1KzNpswpNRtogc8kyRtZx9KimVheZZFFkerqdQ80UBjV3qeapGWh6uYkic3Pmsnp6woOcb7VB5tLx3s63St2w8ecidNzFmme5BNro8cMidEhCzYpcXM1aY+hpQNe1jMCElkhZ77nUtho/L0KfVLNuudT2Gb8vQo9SqDHfuPgas9ah9wRbK/8FWoqfTkQVAAA="
LOGO_XMAS_B64="H4sIABuJ4GMAA8XYvW4TQRAH8D6vkOZ4AKL93jvNM1CDRIVQJIpYQYCQ6Fy4cIGQ3ND63eAF8gj812efd2bW8SUkUCRBP83M7t7N7a64fOt7cuRi3P2YxcWllO7BYh8tr5Vc1xIy5EbJeyW3ShZKeGUn57OTL0puZ2Qxwb/+p4RnE/Nc4lRHPZmorvuXYvOj5W77Y3UmzENeKblW8mmGfKvFqKbayRslCyXvlHxmUprqhZJOyd32+1bhxYxELqrT/kJ+/VxXZoe0s+VM07ndrChZzZ60lbKuEbU5V63POq6XzXeIWjesVW11Ns436nk16qmodjVmeZDVdvJ7OSdKjLk3nhn0SvfWilsr685GmUa106Zzu1lRM0ZISa81qZ5OjZ5OjZ5ummvkypP2dFS7GrPY6MKo+jw2+vxkpjTVv7HRv7HRq/eYzq13RRtU/z6ZyLN1FDGjva1mGs9VPRoaPbq3zUxjuT6R5SP4TE4+aZhXmT0FFRcoimqRksqMlOXcvKNeVXM0qDhP1qqChqwT44L0lPfIRnF4AmohLqOVeMVCSW6OLmA7EHFlt5UjH5CtBbcjO6iR8Ve9uQOuJYp3ZwfcuWTcAVm3OYNbp0SbcHlX6Tvkw6BFoorzI7KJ20AuncK1RPEkrS0k44C9mngT8XeQ6biAAdkwZiCvHu4B2cRNIm/lCzvgWqLoSOMLyTig6kiN6DJc5Xz9GgqZQnXFgpZ8ZI/Ct3HIoy1r68mnavs8yHFYfJKYSH6gWBoi+Z6LVeLI8+/BTLY5Y/1AgR0Q2K5H6yoZDAUro9JoU7XQty1TYBtjMV/sOELeSx0FCxS8NCstUW+KdbUgKoio3I92nFs8aex7DGGyZW2xWFcLVp9YlJ9vWH/15oPbS7VvFjM8ylLGStkBUNmmspSlmbZhpayX/EApFuuUiChPkX35+H2fHXMzJUOx2pInqaPSZJvKcFvS1lNkvYSDc7SuliijcAgj2bNqMC/NT7aszfERIJYi60IczPjkRKbDo8RkmJUXKHNhWGu1p+BURluLTFgUmQ6fc1maNF9yp2oOLx7TyywKZsfMafU4ztEmohq2xF7mYifn8y1SXs7iay2x5JlJsN0FvOjFVS2Y6bCIk2CTtCXrqhZTYvwkOFSHMtbLWvpSefp/hXIPSCXrppbSKouPk+CA3I3+oRZXYo51cCUwpfIfX4h68xAVAAA="
LOGO_HALLOWEEN_B64="H4sIAByJ4GMAA8XYsW4UMRAA0D6/kGb5ACLbY3u9mh/gDyioEIpEkSMUCER3EldchXQNbT6Ev4EfyCcws3u355nx5TaQiAISPc2M7d1Z28rlGygYMKQ0/nOri0st3aPF/7W8NnJdS+xJboy8M3JrZGVEVg56PqN8MnK7IEsI/fY/JT6buOeSYDrqycR03ZPK/d33bw+HeW68V0beGvm4QL4KATMWmLHAjAX6g7Liim77Ub4YuV4gH4RwU70w0hm5v9v9NHixIFGK6bR/kF8/tpX5IY+2Xmg2t1sUpav5k7Yx1jWidueqld7GjdY1orYNa1XbnI2DRj3d4Kej2tWE9YOuNsrv9ZIoNebeZGa0K91bK25rrDsb5RrVTpvN7RZFLRghZ7vWbHo6N3o6N3q6aaGRq0/a01HtasJSowuT6fPU6POTmdpM/6ZG/6ZGrz5gNrfeFX00/ftkos/WSdSM9rZZaDLX9Ghs9OjedgtN5EJGL0eAHoN+0mRgMgtGExcxqWoJs8lM2Ou5QcBiqgUcTByg96agQx/UuER2ynsUowR6AmYhoadWkhWZst4cQ6TtQMXxbqtHPqBYC12N/GBGpp/mzR1wq1G9Oz/QhUvHHVB0W3B069ToM13eTfqIchhqkWTiYEIxcR8x5FO41aiepPdMOo6wmIk3kX4OOp0uYIRiGDcgmId7QDFxlxG8fmEH3GpUHemASccRmo60SF1GVzmoXwOTY6orMnqEJB4FtHHoJ1vXVhBytX0e5DgsfZI0kf6R4nFICEWKNxIQ5PfgZtudsTJgFAcEbdeTdZUMDqPXUXmyuVosbesxio2RDdiOI/R7qaPIIkbQ5rVlLI6tq4Wioorqy2THuaWTJr7HGGdb15bYulpo9VlEwXKj9VdvPoa9VPsmm5NRHntaqTgAKttVlnttrm20UtFLMGBObJ0RFQWYxJdP/z9kx9wes8NUbcmz1FF5tl1ldFuyVjCJXqKDc7KulqSj6BCmZBDVyEAbzLauLcgRSDwm0YV0MNMnpzIDPUqajDB+gTqXjNZa7Sl0KlNbq0yypDIDfc68NG3AuXO1QC+epteLKDI/Zc6rp+Oc2kRVoy2x6FzayeV8WfjlrD7XkjjPzULbXaQXvbqqhWY6rNIstEl6zrqqxXEMzEKH6sBjvaylcOX5bxh8D8icdVMLt8rx7yV01Qjj6O9rCRxzrENXAseV/wBBvHhFEBUAAA=="

DEFAULT_DOWNLOADS_DIR="/tmp/anime-manager/webtorrent"
MEDIA_PLAYERS="mpv | iina | vlc"
DEFAULT_LINUX_PLAYER="mpv"
DEFAULT_DARWIN_PLAYER="iina"

lines_to_remove=0
playlist_mode=0
LINENO=0
# Message color palette
RESET="\033[0m"
MSG_INFO_COLOR="\033[38;2;255;255;224m" # lightyellow
MSG_WARN_COLOR="\033[38;2;255;165;0m"   # orange
MSG_ERR_COLOR="\033[31m"                # red
MSG_HELP_COLOR="\033[1;34m"             # lightblue, bold
TITLE_COLOR="\033[33m"                  # yellow
SUBTITLE_COLOR="\033[1;34m"             # lightblue, bold
INCOGNITO_MODE_COLORS="\033[37;45m"     # magenta bg, white fg
OVERWRITE='\r\033[1A\033[0K'

DATE_MONTH=$(date "+%m")
DATE_DAY=$(date "+%d")
CONFIG_PATH="$HOME/.config/anime-manager"
LOG_DIR="$CONFIG_PATH/log"
TMP_PATH="/tmp/anime-manager"

cached_playback=0
animdl_playthrough=0
AUTOINSTALL=0
GLOBAL_TRACKMA_FIFO=""
# Define player socket for ipc comms. Standard naming: all socket files must
# be in this path with this file name for compatibility with third party
# tools. Can be updated if compatibility issues arise.
MEDIA_PLAYER_VLC_SOCKET="/tmp/vlcsocket"
MEDIA_PLAYER_MPV_SOCKET="/tmp/mpvsocket"
MEDIA_PLAYER_IINA_SOCKET="/tmp/iinasocket"

ANIMDL_CONF_FILE="$CONFIG_PATH/animdl_config.yml"
PLAYER_LOGFILE="$CONFIG_PATH/log/media_player.log"
NYAA_SEARCH_BIN="$(getcwd)/lib/nyaa_search.py"
NYAA_SEARCH_LOGFILE="$LOG_DIR/nyaa_search.log"
NYAA_FE_LOGFILE="$LOG_DIR/file_extractor.log"
NYAA_FE_BIN="$(getcwd)/lib/file_extractor.py"
WEBTORRENT_CLI="lib/webtorrent-cli/bin/cmd.js"

# logfiles
WEBTORRENT_LOGFILE="$LOG_DIR/webtorrent.log"
TRACKMA_LOGFILE="$LOG_DIR/trackma.log"
# CURRENTLY_PLAYING_LOGFILE="$CONFIG_PATH/now_playing.log"
ANIMDL_LOGFILE="$LOG_DIR/animdl.log"
# webtorrent globals
# torrent status codes
TORRENT_TMOUT=20
TORRENT_STATUS_OKPLAYING=0
TORRENT_STATUS_STALLED=1
TORRENT_STATUS_ERRORED=2
file_list=""
webtorrentpid=""
# threshold percentage of video duration that when reached will
# trigger the episode to be set as watched
MEDIA_PLAYER_PERCENT_WATCHED=80
# player status codes
PLAY_STATUS_WAITING=0
PLAY_STATUS_OKPLAYING=1
PLAY_STATUS_ERRORED=2
PLAY_STATUS_EXITED=3
# PLAY_STATUS_OFFLINE=4
PLAY_STATUS_FILE_SEL=5
PLAY_STATUS_SEARCH_SYNONYM=6
PLAY_STATUS_SELECT_SOURCE=7
play_status=$PLAY_STATUS_WAITING
# nyaa search return codes, corresponds with lib/return_codes.py
NYAA_SEARCH_CODE_NO_RESULTS="-1"
NYAA_SEARCH_CODE_FATAL_ERROR="-3"
NYAA_FID_CODE_CONTENT_MISMATCH="-6"

export BACK_MSG
export TO_MAIN_MENU
export SWITCH_STATUS_MSG_MENU_ENTRY
export TRACKMA_ENTRY_REGEX
export TRACKMA_LOGFILE
export MEDIA_PLAYER_PERCENT_WATCHED

# fzf colors
export FZF_DEFAULT_OPTS='--color=fg:#ffffff,bg:-1,hl:#ba9c41 --color=fg+:#ffbf00,bg+:#262626,hl+:#5fd7ff --color=info:#ffffff,prompt:#ffbf00,pointer:#af5fff --color=marker:#87ff00,spinner:#af5fff,header:#d7005f --color=label:#ffbf00'

# regex for extracting trackma results
# gets the whole series list
TRACKMA_LIST_REGEX="^\|[[:space:]]+([0-9]+[[:space:]]+.*[0-9]+[[:space:]]+\/[[:space:]]+[0-9?]+[[:space:]]+[0-9]+).*\|$"
# gets the multiple parts of an entry, by matching groups
#	1- list index
#	2- anime title fragment
#	3- unused
#	4- last watched ep
#	5- end episode
#	6- series score
# Caveat: removing possesive quantifier makes the \2 match to end
# with a residual dot, we will have to remove it with sed.
# We also have no way of making a distinction between series that
# actually end with a dot from a residual dot.
TRACKMA_ENTRY_REGEX="^([[:digit:]]+)[[:space:]]+(([^.]*|.*))\.*[[:space:]]+([[:digit:]]+)[[:space:]]\/[[:space:]]([[:digit:]]+|\?)[[:space:]]+([[:digit:]]+)$"
# mainmenu entries
WATCH_HISTORY="ðŸ‘ï¸  Watch History"
WATCH="ðŸ“º Watch"
WATCH_RANDOM="ðŸ”€ Watch Random"
ADD_ANIME="ðŸ§© Add Anime"
LIST="ðŸ“™ Lists"
UPDATE_STATUS="ðŸ”„ Update Anime Status"
SCORE_SHOW="ðŸ‘ Score Anime"
EXIT_INCOGNITO_MODE="ðŸ‘¤ Exit Incognito Mode"
ENTER_INCOGNITO_MODE="ðŸ•µï¸  Enter Incognito Mode"
TO_SUBMENU="MORE OPTIONS â–¸"
BACK_TO_SUBMENU="â—‚ BACK"
# submenu entries
PLAYLIST="Create Playlist ðŸŽ¦"
SWITCH_ACCOUNTS="Switch Accounts ðŸ‘¤"
DELETE_ANIME="Delete Anime ðŸ—‘ï¸"
WATCH_RAND_AIRING="Watch Random Anime (Currently Airing ðŸ†•)"
LIST_AIRING="List Anime (Currently Airing ðŸ†•)"
UPDATE_EPISODES="Update Anime Episodes ðŸ”„"
SET_ALTNAME="Set Alternative Name ðŸ“"
PULL="Pull Lists from Remote â†“"
PUSH="Push Local Lists to Remote â†‘"
LIST_BY_SCORE="List Anime (Sort by Rating ðŸŒŸ)"
TO_MAIN_MENU="â—‚ MAIN MENU"
SELECT_SOURCE="â—‚ SELECT SOURCE"
DELETE_HIST="ðŸ—‘ï¸  Delete watch history"
SWITCH_STATUS_MSG_MENU_ENTRY="ðŸ”„ SWITCH STATUS"
# used in account_menu, incognito_menu
PLAY_METHOD_TORRENTING="ðŸ˜º Search Nyaa Torrents (torrenting)"
PLAY_METHOD_SAVED_LINK="ðŸ”– Load from Bookmarks (torrenting)"
PLAY_METHOD_STREAMING="ðŸ’¡ Play with animdl (streaming)"
PLAY_METHOD_MAGNET="ðŸ§² Play a magnet link (torrenting)"
NYAA_SEARCH_SYNONYM="ðŸ”Ž Search again using a title synonym"
MAIN_MENU_HELPTEXT="
ðŸ•µï¸  Switch Incognito Mode on. Browse and watch without syncing your activity with any account.
â”€â”€â”€
ðŸ‘  Score an anime or change an anime score.
â”€â”€â”€
ðŸ”„  Update the status of your anime.
â”€â”€â”€
ðŸ“™  Browse all your lists. It can also play anime.
â”€â”€â”€
ðŸ§©  Add a new anime to your Plan to Watch list.
â”€â”€â”€
ðŸ”€  Select one random anime from your watching lists (watching, rewatching) and play it.
â”€â”€â”€
ðŸ“º  Open your watching lists (watching, rewatching) for playing an anime.
â”€â”€â”€
ðŸ‘ï¸  Your watching history with anime and episode count.
"

SUB_MENU_HELPTEXT="
ðŸŒŸ  Display your lists in descending order by score.
â”€â”€â”€
â†‘  Upload your local progress to your tracking service.
â”€â”€â”€
â†“  Download your remote progress and update your local lists.
â”€â”€â”€
ðŸ“  Set the alternative name for an anime.
â”€â”€â”€
ðŸ”„  Update your watching progress on an anime.
â”€â”€â”€
ðŸ†•  Display your lists by showing currently airing anime only.
â”€â”€â”€
ðŸ†•  Play one random, currently airing anime from your watching lists (watching, rewatching).
â”€â”€â”€
ðŸ—‘ï¸  Delete an anime from your lists. You will lose all your progress on that anime.
â”€â”€â”€
ðŸ‘¤  Switch between the various accounts connected to Trackma.
"
# used in media_player_menu
PLAYER_MENU_FILE_SELECT_CODE=0
PLAYER_MENU_END_CODE=1
PLAYER_MENU_SELECT_SEARCH_RES_CODE=2
PLAYER_MENU_SEARCH_SYNONYM=3

# Parse arguments
parser_definition() {
    setup REST help:usage -- "Usage: anime-manager [options]..." ''
    msg -- 'Options:'
    flag AUTO_UPDATE -a --auto-update init:="0" -- "Automatically update the lists when the playback time reaches  
                              the threshold (80% of video duration)."
    flag MINIMAL -m --minimal init:="0" -- "Minimalistic interface. It does not print the logo, the menu  
                              fills the screen and is reversed. Dimmer colors."
    flag INCOGNITO_MODE -i --incognito init:="0" -- "Switch Incognito Mode on. Your activity will not be synced 
                              with the remote anime cataloguing service."
    flag MONOCHROME_LOGO --monochrome-logo init:="0" -- "Print the monochromatic logo instead of the big orange one.
                              Suitable for terminals that do not support 24-bit colors."
    flag TORRENT_ONLY -t --torrent-only init:="0" -- "Always torrent the anime selection. Always load bookmark if 
                              possible or automatically search the torrent tracker."
    param TORRENT_DOWNLOADS_DIR -f --downloads-folder init:="$DEFAULT_DOWNLOADS_DIR" -- "Full path for a persistent downloads folder for torrenting.
                              It is created if it does not exist."
    param MEDIA_PLAYER_APP -p --player pattern:"$MEDIA_PLAYERS" -- "Select the media player. Defaults to mpv or iina (macOS)
                              Available players: iina, mpv, vlc."
    flag DEBUG -d --debug init:="0" -- "Start debug mode."
    disp :usage -h --help
    disp VERSION -v --version init:="0"
}

eval "$(utils/getoptions parser_definition) exit 1"

if [ "$DEBUG" -eq 1 ]; then
    set -x
    export NYAA_DEBUG="$DEBUG"
else
    unset NYAA_DEBUG
fi

# Further validate arguments
if [ "$MONOCHROME_LOGO" -eq 1 ] && [ "$MINIMAL" -eq 1 ]; then
    printf "Error: Incompatible options --monochrome-logo, --minimal\nPlease use one or the other."
    exit
fi

if printf "%s" "$TORRENT_DOWNLOADS_DIR" | grep -- "--" >/dev/null 2>&1; then
    printf "Requires an argument: --downloads-folder\n"
    exit 1
fi

if printf "%s" "$TORRENT_DOWNLOADS_DIR" | grep -- "~" >/dev/null 2>&1; then
    printf "Full path required: --downloads-folder\n"
    exit 1
fi

if printf "%s" "$TORRENT_DOWNLOADS_DIR" | grep -- "\./" >/dev/null 2>&1; then
    printf "Full path required: --downloads-folder\n"
    exit 1
fi

if printf "%s" "$TORRENT_DOWNLOADS_DIR" | grep -- "\\$" >/dev/null 2>&1; then
    printf "Full path required: --downloads-folder\n"
    exit 1
fi

#* TRACKMA UTILITIES =====

# Returns the index of a Trackma entry.
get_entry_index_function_code='get_entry_index() {
    printf "%s" "$1" | sed -En "s/$TRACKMA_ENTRY_REGEX/\1/p"
}'
eval "$get_entry_index_function_code"

# Returns the last episode from a Trackma entry
get_last_show_episode() {
    printf "%s" "$1" | sed -En "s/$TRACKMA_ENTRY_REGEX/\5/p"
}

# Returns the last watched episode from a Trackma entry
get_last_watched_episode() {
    printf "%s" "$1" | sed -En "s/$TRACKMA_ENTRY_REGEX/\4/p"
}

# Returns the score from a Trackma entry
get_score() {
    printf "%s" "$1" | sed -En "s/$TRACKMA_ENTRY_REGEX/\6/p"
}

# get the account in use in Trackma
get_account_name() {
    while ! grep "using account" "$GLOBAL_TRACKMA_TMPFILE" >/dev/null 2>&1; do :; done
    sed -En "s/.*using account (.*)\(.*/\1/p" "$GLOBAL_TRACKMA_TMPFILE" # | sed "s/ $//g"
}

# gets the remote tracking service (mal, anilist, etc) used in trackma
# this is necessary because the lists differ between services
get_remote_tracker() {
    while ! grep "using account" "$GLOBAL_TRACKMA_TMPFILE" >/dev/null 2>&1; do :; done
    sed -En "s/.*using account (.*)\((.*)\).*/\2/p" "$GLOBAL_TRACKMA_TMPFILE"
}

get_trackma_tracker_name() {
    get_trackma_tracker_name_name="$1"
    case $get_trackma_tracker_name_name in
    "mal")
        printf "MAL"
        ;;
    "anilist")
        printf "Anilist"
        ;;
    esac
}

# Filter and return an entry from a Trackma list.
get_entry_from_title() {
    [ -z "$anime_title" ] && printf "ðŸ’¥ Unable to get entry (no title)." && kill $$
    while read -r get_entry_from_title_status; do
        printf "filter %s\nsearch \"^%s$\"\n" "$get_entry_from_title_status" "$anime_title" | trackma_query >/dev/null 2>&1
        while ! grep "results" "$GLOBAL_TRACKMA_TMPFILE" >/dev/null 2>&1; do :; done
        format_trackma_list_res="$(cat "$GLOBAL_TRACKMA_TMPFILE")"
        get_entry_from_title_entry="$(format_trackma_list "$format_trackma_list_res")"
        if [ -n "$get_entry_from_title_entry" ]; then
            status="$get_entry_from_title_status"
            break
        fi
    done <<EOF
$TRACKMA_STATUS_MENU_ENTRIES
EOF
    if [ -z "$get_entry_from_title_entry" ]; then
        printf "%b\n" "ðŸ’¥ ERROR getting entry from title (no results)."
        kill $$
    fi
    printf "%s" "$get_entry_from_title_entry"
}

# Format anime info.
format_anime_info_function_code='format_anime_info() {
    ENTRY_TEXT="\x1b[38;2;255;255;224m" # lightyellow
    ENTRY_NAME="\x1b[38;2;255;165;0m"   # orange
    RESET="\x1b[0m"
    formatted_info="$1"
    # add abbreviation for empty values
    formatted_info="$(printf "$formatted_info" | sed -E "s/^(.*):[[:space:]]\[\]/\1: N\/A/g")"
    # remove square brackets around lists
    formatted_info="$(printf "$formatted_info" | sed -E "s/\[(.*)\]/\1/g")"
    # colorize text
    formatted_info="$(printf "%b" "$formatted_info" | sed -E "1,3 s/^(.*)/${ENTRY_NAME}\1${RESET}/")"
    formatted_info="$(printf "%b" "$formatted_info" | sed -E "s/^(English):(.*)/${ENTRY_NAME}\1${RESET}:${ENTRY_TEXT}\2${RESET}/")"
    formatted_info="$(printf "%b" "$formatted_info" | sed -E "s/^(Japanese):(.*)/${ENTRY_NAME}\1${RESET}:${ENTRY_TEXT}\2${RESET}/")"
    formatted_info="$(printf "%b" "$formatted_info" | sed -E "s/^(Romaji):(.*)/${ENTRY_NAME}\1${RESET}:${ENTRY_TEXT}\2${RESET}/")"
    formatted_info="$(printf "%b" "$formatted_info" | sed -E "s/^(Synonyms):(.*)/${ENTRY_NAME}\1${RESET}:${ENTRY_TEXT}\2${RESET}/")"
    formatted_info="$(printf "%b" "$formatted_info" | sed -E "s/^(Synopsis):(.*)/${ENTRY_NAME}\1${RESET}:${ENTRY_TEXT}\2${RESET}/")"
    formatted_info="$(printf "%b" "$formatted_info" | sed -E "s/^(Type):(.*)/${ENTRY_NAME}\1${RESET}:${ENTRY_TEXT}\2${RESET}/")"
    formatted_info="$(printf "%b" "$formatted_info" | sed -E "s/^(Genres):(.*)/${ENTRY_NAME}\1${RESET}:${ENTRY_TEXT}\2${RESET}/")"
    formatted_info="$(printf "%b" "$formatted_info" | sed -E "s/^(Studios):(.*)/${ENTRY_NAME}\1${RESET}:${ENTRY_TEXT}\2${RESET}/")"
    formatted_info="$(printf "%b" "$formatted_info" | sed -E "s/^(Mean score):(.*)/${ENTRY_NAME}\1${RESET}:${ENTRY_TEXT}\2${RESET}/")"
    formatted_info="$(printf "%b" "$formatted_info" | sed -E "s/^(Status):(.*)/${ENTRY_NAME}\1${RESET}:${ENTRY_TEXT}\2${RESET}/")"
    formatted_info="$(printf "%b" "$formatted_info" | sed -E "/^(Mean score|Status|Type|Synopsis|Synonyms|Romaji|Japanese|English):(.*)/! s/(.*)/${ENTRY_TEXT}\1${RESET}/")"
    printf "\n%s\n" "$formatted_info"
}'
eval "$format_anime_info_function_code"

# returns a status code that trackma understands
get_trackma_status_code_function_code='get_trackma_status_code() {
    get_trackma_status_code_status_status="$1"
    case $get_trackma_status_code_status_status in
    "Watching" | "watching")
        printf "watching"
        ;;
    "Plan to Watch" | "plantowatch")
        printf "plantowatch"
        ;;
    "Rewatching" | "rewatching")
        printf "rewatching"
        ;;
    "Dropped" | "dropped")
        printf "dropped"
        ;;
    "Paused" | "paused")
        printf "paused"
        ;;
    "Completed" | "completed")
        printf "completed"
        ;;
    "On Hold" | "onhold")
        printf "onhold"
        ;;
    "$TO_MAIN_MENU")
        printf "%s" "$TO_MAIN_MENU"
        ;;
    "$SWITCH_STATUS_MSG_MENU_ENTRY")
        printf "%s" "$SWITCH_STATUS_MSG_MENU_ENTRY"
        ;;
    esac
}'
eval "$get_trackma_status_code_function_code"

# Update watched episodes and update watch history
set_ep_as_watched() {
    date="$(date "+%Y/%m/%d %H:%M:%S %p")"
    # avoid 'EngineError: Show already at episode X'
    if [ "$cur_anime_episode" -ne "$last_watched_ep" ]; then
        printf "update %s %s\n" "$entry_index" "$cur_anime_episode" | trackma_query >/dev/null 2>&1
        # leave the full title at the end to avoid formatting it :P
        printf "%s\n" "$date |////${cur_anime_episode}////${anime_title}" >>"$WATCH_HISTORY_FILE"
    fi
}

# set the status of an anime
set_anime_status() {
    set_anime_status_new_status="$(get_trackma_status_code "$1")"
    status="$(get_trackma_status_code "$status")"
    printf "filter %s\nstatus '%s' %s\n" "$status" "$entry_index" "$set_anime_status_new_status" | trackma_query >/dev/null 2>&1
}

filter_trackma_list_function_code='filter_trackma_list() {
    printf "%b" "$1" | sed -En "s/$TRACKMA_LIST_REGEX/\1/p"
}'
eval "$filter_trackma_list_function_code"

# returns a formatted trackma list
# it also adds status emojis to the entries
format_trackma_list() {
    format_trackma_list_list="$(filter_trackma_list "$1")"
    # remove character sequences and add an emoji next to shows currently airing
    format_trackma_list_list=$(printf '%b' "$format_trackma_list_list" | sed "s,$(printf '\033')\\[[0-9;]*[a-zA-Z],ðŸ†• ," | sed "s,$(printf '\033')\\[[0-9;]*[a-zA-Z],,g" | sed "s,\x1B\[[0-9;]*[a-zA-Z],,g" | sed -E "/ðŸ†•/ s/(.*)\.{3}(.*)/\1\2/")
    printf "%b" "$format_trackma_list_list"
}

# cleans a trackma entry from status emoji and escape codes
# this is required for the trackma_entry_regex to work properly
clean_trackma_entry() {
    clean_trackma_entry_entry="$1"
    clean_trackma_entry_cleaned="$(printf "%s" "$clean_trackma_entry_entry" | sed -E "s/ *$//g" | sed -E "s/\.*$//g" | sed -E "s,$(printf '\033')\\[0-9;]*[a-zA-Z],," | sed -E "s,$(printf '\033')\\[0-9;]*[a-zA-Z],,g" | sed "s,\x1B\[[0-9;]*[a-zA-Z],,g" | sed "s/ðŸ†• //g" | sed -E "s/\[.*\]//g" | sed -E "s/ $//g")"
    printf "%s" "$clean_trackma_entry_cleaned"
}

# get all the shows the user has set as watching in their lists
# for presenting in unified way
get_watching_shows() {
    get_watching_shows_rewatching=""
    get_watching_shows_watching="$(printf "filter %s\nls\n" "watching" | trackma_query)"
    get_watching_shows_watching="$(format_trackma_list "$get_watching_shows_watching")"
    if [ "$TRACKER_SERVICE" = "anilist" ]; then
        # exception for anilist
        get_watching_shows_rewatching="$(printf "filter %s\nls\n" "rewatching" | trackma_query)"
        get_watching_shows_rewatching="$(format_trackma_list "$get_watching_shows_rewatching")"
    fi
    printf "%b\n%b" "$get_watching_shows_watching" "$get_watching_shows_rewatching"
}

# Gets a full anime title from the user selection. This is a workaround for the
# caveats of our regex pattern that is unable to extract the anime title
# correctly. It will get the complete anime title from the first line in the
# information output, including any trailing dots. This title doesn't need
# cleaning because  we are not getting it from a list.
get_anime_title() {
    [ -z "$entry_index" ] && printf "ðŸ’¥ Unable to get anime title (no index set)." && kill $$
    [ -z "$status" ] && printf "ðŸ’¥ Unable to get anime title (no status set)." && kill $$
    # Split the Trackma commands in two parts otherwise the Trackma prompt gets
    # in the same line as the anime title.
    printf "filter %s\n" "$status" | trackma_query >/dev/null 2>&1
    printf "info %s\n" "$entry_index" | trackma_query >/dev/null 2>&1
    while ! grep "Status" "$GLOBAL_TRACKMA_TMPFILE" >/dev/null 2>&1; do :; done
    get_anime_title_title="$(head -n1 "$GLOBAL_TRACKMA_TMPFILE")"
    [ -z "$get_anime_title_title" ] && printf "ðŸ’¥ Unable to get anime title (no info)." && kill $$
    printf "%s" "$get_anime_title_title"
}

# Get a cleaned title fragment.
get_title_fragment_function_code='get_title_fragment() {
    if [ -n "$(printf "%s" "$1" | sed -En "s/$TRACKMA_ENTRY_REGEX/\2/p")" ]; then
        # raw entry
        printf "%s" "$1" | sed -En "s/$TRACKMA_ENTRY_REGEX/\2/p" | sed -E "s/ *$//g" | sed -E "s/\.*$//g" | sed -E "s,$(printf "'"\033"'")\\[0-9;]*[a-zA-Z],," | sed -E "s,$(printf "'"\033"'")\\[0-9;]*[a-zA-Z],,g" | sed "s,\x1B\[[0-9;]*[a-zA-Z],,g" | sed "s/ðŸ†• //g" | sed -E "s/\[.*\]//g" | sed -E "s/ $//g"
    else
        printf "%s" "$1"
    fi
}'
eval "$get_title_fragment_function_code"

get_last_show_ep_from_title() {
    [ -z "$anime_title" ] && printf "ðŸ’¥ Unable to get last episode (no title)" && kill $$
    if [ -n "$status" ]; then
        status="$(get_trackma_status_code "$status")"
        printf "%s" "$status"
    else
        while read -r trackma_code; do
            printf "filter %s\nsearch '^%s$'\n" "$(get_trackma_status_code "$trackma_code")" "$(printf "%s" "$title_fragment" | sed "s/'/'\"'\"'/g")" | trackma_query >/dev/null 2>&1
            while ! grep "result" "$GLOBAL_TRACKMA_TMPFILE" >/dev/null 2>&1; do :; done
            # Filter by index because we may get more than one match by fragment.
            res_title="$(filter_trackma_list "$(cat "$GLOBAL_TRACKMA_TMPFILE")")"
            if [ -n "$res_title" ]; then
                last_show_episode="$(get_last_show_ep "$res_title")"
                break
            fi
        done <<EOF
$TRACKMA_STATUS_MENU_ENTRIES
EOF
        if [ -z "$status" ]; then
            printf "%b\n" "ðŸ’¥ ERROR getting show status."
            kill $$
        fi
        printf "%s" "$status"
    fi
}

# Gets the status of an entry. This is used when we have a menu with mixed lists
# and we want to know the status of a particular entry.
get_show_status() {
    [ -z "$entry_index" ] && printf "ðŸ’¥ Unable to get status (no index)" && kill $$
    [ -z "$title_fragment" ] && printf "ðŸ’¥ Unable to get status (no title fragment)" && kill $$
    if [ -n "$status" ]; then
        status="$(get_trackma_status_code "$status")"
        printf "%s" "$status"
    else
        while read -r trackma_code; do
            # Filter by title fragment. Escape single quotes in title for search
            # query
            printf "filter %s\nsearch '%s'\n" "$(get_trackma_status_code "$trackma_code")" "$(printf "%s" "$title_fragment" | sed "s/'/'\"'\"'/g")" | trackma_query >/dev/null 2>&1
            while ! grep "result" "$GLOBAL_TRACKMA_TMPFILE" >/dev/null 2>&1; do :; done
            # Filter by index because we may get more than one match by fragment.
            res_title="$(filter_trackma_list "$(cat "$GLOBAL_TRACKMA_TMPFILE")")"
            res_title="$(printf "%s" "$res_title" | sed -En "/^$entry_index/p")"
            if [ -n "$res_title" ]; then
                status="$(get_trackma_status_code "$trackma_code")"
                break
            fi
        done <<EOF
$TRACKMA_STATUS_MENU_ENTRIES
EOF
        if [ -z "$status" ]; then
            printf "%b\n" "ðŸ’¥ ERROR getting show status."
            kill $$
        fi
        printf "%s" "$status"
    fi
}

# Get anime info for an entry from a mixed list.
get_mixed_anime_info_function_code='get_mixed_anime_info() {
    if [ "$1" = "$TO_MAIN_MENU" ]; then
        get_mixed_anime_info_info="Go back to the main menu"
    else
        while read -r get_mixed_anime_info_status; do
            get_mixed_anime_info_title_fragment="$(get_title_fragment "$1")"
            get_mixed_anime_info_entry_index="$(get_entry_index "$1")"
            printf "filter %s\n" "$(get_trackma_status_code "$get_mixed_anime_info_status")" | trackma_query >/dev/null 2>&1
            printf "search '\''%s'\''\n" "$(printf "%s" "$get_mixed_anime_info_title_fragment" | sed "s/'\''/'\''\"'\''\"'\''/g")" | trackma_query >/dev/null 2>&1
            # Filter by index because we may get more than one match by fragment.
            get_mixed_anime_info_info="$(filter_trackma_list "$(cat "$GLOBAL_TRACKMA_TMPFILE"| tr -d '\''\0'\'')" | sed -En "/^$get_mixed_anime_info_entry_index/p")"
            if [ -n "$get_mixed_anime_info_info" ]; then
                printf "info '\''%s'\''\n" "$get_mixed_anime_info_entry_index" | trackma_query >/dev/null 2>&1
                while ! grep "Status" "$GLOBAL_TRACKMA_TMPFILE" >/dev/null 2>&1; do :; done
                get_mixed_anime_info_info="$(cat "$GLOBAL_TRACKMA_TMPFILE" | tr -d '\''\0'\'' | sed -n "1,/Status/p" | sed -e "s/<[^>]*>//g")"
                break
            fi
        done <<EOF
$TRACKMA_STATUS_MENU_ENTRIES
EOF
    fi
    if [ -z "$get_mixed_anime_info_info" ]; then
        printf "%s\n" "ðŸ’¥ ERROR getting anime info."
    else
        format_anime_info "$get_mixed_anime_info_info"
    fi
}'
eval "$get_mixed_anime_info_function_code"

# get anime series across lists or from a particular list
# this is used to play any episode from the watch history
# the status code argument should be parseable by trackma
get_show_entry() {
    status="$(get_show_status)"
    # trackma search uses regex so we need to sanitize it
    printf "filter %s\nsearch '^%s$'\n" "$(get_trackma_status_code "$status")" "$(printf "%s" "$anime_title" | sed "s/'/'\"'\"'/g")" | trackma_query >/dev/null 2>&1
    while ! grep "result" "$GLOBAL_TRACKMA_TMPFILE" >/dev/null 2>&1; do :; done
    res="$(cat "$GLOBAL_TRACKMA_TMPFILE")"
    get_show_entry_list="$(filter_trackma_list "$res")"
    # we assume we should find a result
    [ -z "$get_show_entry_list" ] &&
        printf "%b\n" "ðŸ’¥ ERROR getting show entry." && kill $$
    printf "%b" "$get_show_entry_list"
}

# get shows info from Trackma
get_anime_info_function_code='get_anime_info() {
    if [ "$1" = "$TO_MAIN_MENU" ]; then
        get_anime_info_info="Go back to the main menu"
    elif [ "$1" = "$SWITCH_STATUS_MSG_MENU_ENTRY" ]; then
        get_anime_info_info="Switch to another list"
    else
        get_anime_info_status="$(get_trackma_status_code "$2")"
        entry_index="$(printf "%s" "$1" | sed -En "s/$TRACKMA_ENTRY_REGEX/\1/p")"
        printf "filter %s\n" "$(get_trackma_status_code "$get_anime_info_status")" | trackma_query >/dev/null 2>&1
        printf "info '\''%s'\''\n" "$(printf "%s" "$entry_index" | sed "s/'\''/'\''\"'\''\"'\''/g")" | trackma_query >/dev/null 2>&1
        while ! grep "Status" "$GLOBAL_TRACKMA_TMPFILE" >/dev/null 2>&1; do :; done
        get_anime_info_info="$(cat "$GLOBAL_TRACKMA_TMPFILE" | sed -n "1,/Status/p" | sed -e "s/<[^>]*>//g")"
    fi
    format_anime_info "$get_anime_info_info"
}'
eval "$get_anime_info_function_code"

#*********************************
#* SYSTEM SETUP - Detect environment, autoinstall
#*********************************

OSTYPE="$(uname -s 2>/dev/null)"
if [ "$OSTYPE" = "Linux" ]; then
    DISTRO_ID="$(awk -F= '$1 == "ID" {print $2}' /etc/*-release)"
    DISTRO_VERSION="$(awk -F= '$1 == "VERSION_ID" {print $2}' /etc/*-release | sed "s/\"//g")"
fi

# set the default media player
reset_media_player_app() {
    if [ -n "$media_player_helper" ]; then
        MEDIA_PLAYER_APP="$media_player_helper"
    fi
}

# check if we can run automatic install for missing dependencies
auto_compat() {
    if [ "$OSTYPE" = "Linux" ]; then
        case $DISTRO_ID in
        "ubuntu")
            true
            ;;
        "debian")
            true
            ;;
        *)
            false
            ;;
        esac
    elif [ "$OSTYPE" = "Darwin" ]; then
        true
    else
        printf "%s" "Automatic installation does not support your platform yet\nbut we may add support for it in the future.\n\nPlease install the dependencies manually.\nhttps://github.com/anma-dev/Anime-Manager#dependencies"
        exit 0
    fi
}

# install dependencies automatically if we can
install_dependencies() {
    shell_cfg="$(get_shell_config_file)"
    install_dep_msg="ðŸŽ‰ Finished the autoinstall!\nRestart your shell to start using Anime Manager."
    if ! which fzf nc animdl trackma jq node "$MEDIA_PLAYER_APP" xxh128sum >/dev/null 2>&1 || [ ! -d "./lib/webtorrent-cli/node_modules" ]; then
        printf "%b" "Anime Manager can automatically install its dependencies.\nSome dependencies were not found!\n" && line_to_remove
        AUTOINSTALL=1
        AM_SHELL_CFG_MSG="### Anime Manager autoinstall ###"
        printf "%s\n" "$AM_SHELL_CFG_MSG"
        if auto_compat; then
            printf "%s" "Install missing dependencies now? [y/N] " && line_to_remove
            read -r yn </dev/tty
            if [ -z "$yn" ]; then
                yn="n"
            fi
            case "$yn" in
            [Yy]*) ;;
            [Nn]*) exit ;;
            *) printf "%s\n" "      Please answer 'yes' or 'no'." && line_to_remove ;;
            esac
        fi
        # begin installation
        if [ "$OSTYPE" = "Linux" ]; then
            printf "%s\n" "ðŸ§ Installing Linux dependencies."
            if ! sudo -v; then
                printf "%s" "ðŸ’¥ Your current user account has no administrative privileges.\nRequired dependencies unable to install\nPlease contact your system administrator." && exit 1
            fi
            sudo apt update
            sudo apt -y install build-essential procps netcat curl wget file git python3-setuptools python3-pip jq xxhash
            mkdir -p "$HOME/.local/bin"
            if ! grep '$HOME/.local/bin:$PATH' "$shell_cfg"; then
                printf "\n%s\n%s\n" "$AM_SHELL_CFG_MSG" 'export PATH="$HOME/.local/bin:$PATH"' >>"$shell_cfg"
            fi
            if ! command -v "$MEDIA_PLAYER_APP"; then
                case "$MEDIA_PLAYER_APP" in
                "mpv")
                    sudo apt -y install mpv
                    ;;
                "vlc")
                    sudo apt -y install vlc
                    ;;
                esac
            fi
            if ! command -v fzf; then
                if [ -d "$HOME/.fzf" ]; then
                    printf "\n\n%s\n\n" "INSTALLATION CONFLICT! Existing $HOME/.fzf folder found!\nfzf was not installed. Please install it manually."
                else
                    # require an fzf version with label and label coloring support
                    git clone --depth 1 https://github.com/junegunn/fzf.git "$HOME/.fzf"
                    "$HOME/.fzf/install" --all --update-rc
                fi
            else
                fzf_version="$(fzf --version)"
                if [ -z "$(printf "%s" "$fzf_version" | awk -F. '$1 >= 0 && $2 >= 35 {print $0}')" ]; then
                    printf "\n\n%s\n\n" "Please manually update your fzf installation to version >= 0.35.x."
                fi
            fi
            ./utils/install-webtorrent.sh
            if ! command -v animdl; then
                # https://github.com/justfoolingaround/animdl
                pip3 install animdl
            fi
            if ! command -v trackma; then
                sudo apt install lsof
                sudo apt -y install python3-pyqt5
                # https://github.com/z411/trackma
                pip3 install pillow \
                    pydbus \
                    setuptools \
                    wheel \
                    pyinotify \
                    nyaapy \
                    anitopy \
                    'requests>=2.20.0' \
                    beautifulsoup4==4.6.0 \
                    lxml \
                    dbus-python
                pip3 install Trackma==0.8.5
            fi
        elif [ "$OSTYPE" = "Darwin" ]; then
            printf "%s" "ðŸ Installing macOS dependencies."
            if ! pkgutil --pkg-info=com.apple.pkg.CLTools_Executables | grep version >/dev/null 2>&1; then
                # xcode command line tools is a dependency of nvm and homebrew
                xcode-select --install
            fi
            if ! command -v brew; then
                # Install homebrew unattended
                NONINTERACTIVE=1 /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
            fi
            if ! grep 'export PATH="/opt/homebrew/bin/:$PATH"' "$shell_cfg" >/dev/null 2>&1; then
                printf "\n%s\n%s\n" "$AM_SHELL_CFG_MSG" 'export PATH="/opt/homebrew/bin/:$PATH"' >>"$shell_cfg"
            fi
            brew install curl jq grep axel openssl@1.1 ffmpeg git xxhash
            brew install patchelf cmake automake fzf
            if ! command -v "$MEDIA_PLAYER_APP"; then
                case "$MEDIA_PLAYER_APP" in
                "mpv")
                    brew install --cask mpv
                    ;;
                "vlc")
                    brew install --cask vlc
                    ;;
                "iina")
                    brew install --cask iina
                    # we install mpv anyway because some stream providers don't go well with iina.
                    brew install --cask mpv
                    ;;
                esac
            fi
            if ! command -v animdl; then
                # https://github.com/justfoolingaround/animdl
                pip3 install animdl
            fi
            ./utils/install-webtorrent.sh
            if ! command -v trackma; then
                # https://github.com/z411/trackma
                # dbus-python module is broken on macOS and cannot be built. This means no trackma mpris support.
                # pip3 install dbus-python
                # inotify is not available on macosx-XX-arm64
                # pip3 install pyinotify
                # Installs qt5 for trackma gui
                pip3 install pillow \
                    PyQt5 \
                    pydbus \
                    setuptools \
                    setuptools_scm \
                    scikit-build \
                    nyaapy \
                    anitopy \
                    'requests>=2.20.0' \
                    beautifulsoup4==4.6.0 \
                    lxml \
                    wheel \
                    Trackma==0.8.5
            fi
        fi
        echo
        printf "%s" "$install_dep_msg"
        exit 0
    fi
}

check_setup() {
    # initial checks
    clear_modifiers
    # set default media player
    if [ -z "$MEDIA_PLAYER_APP" ]; then
        # follow defaults
        if [ "$OSTYPE" = "Darwin" ]; then
            MEDIA_PLAYER_APP="$DEFAULT_DARWIN_PLAYER"
        else
            MEDIA_PLAYER_APP="$DEFAULT_LINUX_PLAYER"
        fi
    fi
    # use node if nvm is already installed
    if ! which node >/dev/null 2>&1; then
        PLATFORM_NVM_DIR=""
        if [ -d "$HOME/.config/nvm" ]; then
            PLATFORM_NVM_DIR="$HOME/.config/nvm"
        elif [ -d "$HOME/.nvm" ]; then
            PLATFORM_NVM_DIR="$HOME/.nvm"
        fi
        if [ -d "$PLATFORM_NVM_DIR" ]; then
            export NVM_DIR="$PLATFORM_NVM_DIR"
            # shellcheck disable=SC1091
            [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh" >/dev/null 2>&1 # This loads nvm
            # shellcheck disable=SC1091
            [ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion" >/dev/null 2>&1 # This loads nvm bash_completion
            if comand -v nvm >/dev/null 2>&1; then
                nvm use node >/dev/null 2>&1
            fi
        fi
    fi
    # install animdl conf file
    if [ ! -s "$ANIMDL_CONF_FILE" ]; then
        printf "players:
    vlc:
        executable: vlc
        opts: ['--extraintf oldrc', '--rc-fake-tty', '--rc-unix %s', '--verbose=1', '--file-logging', '--logfile=%s', '--play-and-exit']
    iina:
        executable: iina-cli
        opts: ['--mpv-keep-open=no', '--mpv-log-file=%s', '--mpv-input-ipc-server=%s']
    mpv:
        executable: mpv
        opts: ['--keep-open=no', '--log-file=%s', '--input-ipc-server=%s']
" "$MEDIA_PLAYER_VLC_SOCKET" "$PLAYER_LOGFILE" "$PLAYER_LOGFILE" "$MEDIA_PLAYER_IINA_SOCKET" "$PLAYER_LOGFILE" "$MEDIA_PLAYER_MPV_SOCKET" >"$ANIMDL_CONF_FILE"
    fi
    case "$OSTYPE" in
    "Linux")
        netcat_comm="nc -U -N"
        ;;
    "Darwin")
        netcat_comm="nc -U"
        ;;
    esac
    install_dependencies
}

if [ "$OSTYPE" != "Darwin" ] && [ "$MEDIA_PLAYER_APP" = "iina" ]; then
    printf "The iina media player is not available for your platform.\n"
    exit 1
fi

mkdir -p "$TMP_PATH"
mkdir -p "$TORRENT_DOWNLOADS_DIR"
mkdir -p "$CONFIG_PATH"
mkdir -p "$LOG_DIR"
touch "$TRACKMA_LOGFILE"
printf "" >"$PLAYER_LOGFILE"

#*********************************
#* MAIN LOGIC
#*********************************

#* TRACKMA SUBPROCESS
# global long-running trackma subprocess
spawn_trackma() {
    if [ "$DEBUG" -eq 1 ]; then
        GLOBAL_TRACKMA_TMPFILE="$LOG_DIR/debug_trackma_fifo"
        echo >"$GLOBAL_TRACKMA_TMPFILE"
    else
        GLOBAL_TRACKMA_TMPFILE="$(get_temp_filename)"
    fi
    GLOBAL_TRACKMA_FIFO="$(get_temp_filename)"
    mkfifo -m 600 "$GLOBAL_TRACKMA_FIFO"
    trackma <"$GLOBAL_TRACKMA_FIFO" >"$GLOBAL_TRACKMA_TMPFILE" 2>"$TRACKMA_LOGFILE" &
    exec 3>"$GLOBAL_TRACKMA_FIFO"
    # printf "%s" " âš™ï¸  Starting background process, please wait..." && line_to_remove
    while [ ! -s "$GLOBAL_TRACKMA_TMPFILE" ]; do :; done
    # clear_lines
}

# Sends a query to the Trackma process and returns the result.
trackma_query_function_code='trackma_query() {
    # Reset temp file w/o adding a newline
    printf "" >"$GLOBAL_TRACKMA_TMPFILE"
    while read -r query </dev/stdin; do
        printf "%s\n" "$query" >"$GLOBAL_TRACKMA_FIFO"
    done
    # wait for various prompts as signal for operation finished
    while ! sed -En "/>>|\):/p" "$GLOBAL_TRACKMA_TMPFILE"; do :; done
    cat "$GLOBAL_TRACKMA_TMPFILE"
}'
eval "$trackma_query_function_code"

close_trackma() {
    # printf "%s" "      âš™ï¸  Closing background processes, please wait..." && line_to_remove
    if [ -n "$(sed -En "s/no account|Available accounts/&/p" "$GLOBAL_TRACKMA_TMPFILE")" ]; then
        printf "q\n" >"$GLOBAL_TRACKMA_FIFO"
    else
        printf "exit\n" >"$GLOBAL_TRACKMA_FIFO"
    fi
    rm "$GLOBAL_TRACKMA_FIFO"
    if [ "$DEBUG" -eq 0 ]; then
        rm "$GLOBAL_TRACKMA_TMPFILE"
    fi
    # shellcheck disable=2188
    3>&- # this syntax is valid by POSIX https://pubs.opengroup.org/onlinepubs/009695399/utilities/xcu_chap02.html#tag_02_07_06
    true # fix weird 'Syntax error: "}" missing' by the language server.
}

print_readme_first_msg() {
    if [ ! -f "$CHECKPOINTFILE" ]; then
        printf "%s" "
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ READ FIRST:                                                            â”‚
â”‚                                                                        â”‚
â”‚    This program comes with ABSOLUTELY NO WARRANTY.                     â”‚
â”‚ Anime Manager is a file sharing program. When you run a torrent (Anime â”‚
â”‚ Manager can play content by the means of running a torrent), its data  â”‚
â”‚ will be made available to others by means of upload. Any content you   â”‚
â”‚ share is your sole responsibility. No further notices will be issued.  â”‚
â”‚                                                                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

 Do you agree with this? [yes/no]: "
        while true; do
            read -r answer
            case "$answer" in
            "yes") break ;;
            "no") exit ;;
            *) printf "%s" " Please answer 'yes' or 'no': " ;;
            esac
        done
        printf "%s\n" "$answer" >"$CHECKPOINTFILE"
    fi
    tput clear
}

select_account() {
    [ "$MINIMAL" -eq 0 ] && paint_logo
    # account selection
    TRACKMA_ACCOUNTS="$(sed -nE "/[0-9]+:/p" "$GLOBAL_TRACKMA_TMPFILE")"
    if [ -n "$TRACKMA_ACCOUNTS" ]; then
        TRACKMA_ACCOUNTS_MENU_ENTRIES="$(printf "%s" "$TRACKMA_ACCOUNTS" | sed "s/^[0-9]: /ðŸ‘¤ /g")"
    else
        TRACKMA_ACCOUNTS_MENU_ENTRIES="No account was found"
    fi
    TRACKMA_ACCOUNTS_MENU_ENTRIES="ðŸ•µï¸  Incognito Mode\n$TRACKMA_ACCOUNTS_MENU_ENTRIES"
    while [ -n "$(sed -En "s/no account|Available accounts/&/p" "$GLOBAL_TRACKMA_TMPFILE")" ] && [ "$INCOGNITO_MODE" -eq 0 ]; do
        account_choice=$(
            printf "%b" "$TRACKMA_ACCOUNTS_MENU_ENTRIES" |
                $FZF -i --prompt="Select an option: " \
                    --border-label "â•¢ â™£  ACCOUNT SELECTION â™£  â•Ÿ" \
                    --header "â‡… Navigation â”€ [ESC] Exit â”€ [Enter] Select" \
                    --header-first
        )
        if [ "$(printf "%s" "$account_choice" | cut -d " " -f1)" = "ðŸ•µï¸" ]; then
            INCOGNITO_MODE=1
            close_trackma
            break
        elif [ "$account_choice" = "No account was found" ]; then
            exit
        else
            acc_id="$(printf "%s" "$TRACKMA_ACCOUNTS" | grep "$(printf "%s" "$account_choice" | sed "s/^ðŸ‘¤ //g")" | cut -d ":" -f1)"
            [ -z "$acc_id" ] && exit
            printf "r%s\n" "$acc_id" | trackma_query >/dev/null 2>&1
        fi
    done
    if [ "$INCOGNITO_MODE" -eq 0 ]; then
        USERNAME="$(get_account_name)"
        TRACKER_SERVICE="$(get_remote_tracker)"
    fi
    printf "ls\n" >"$GLOBAL_TRACKMA_FIFO"
    tput clear
}

check_trackma_config() {
    check_trackma_config_config_file=""
    if [ -s "$HOME"/.trackma/config.json ]; then
        check_trackma_config_config_file="$HOME/.trackma/config.json"
    elif [ -s "$HOME"/.config/trackma/config.json ]; then
        check_trackma_config_config_file="$HOME/.config/trackma/config.json"
    fi
    AUTORET_VALUE="$(jq --raw-output '.autoretrieve' "$check_trackma_config_config_file")"
    AUTOSEN_VALUE="$(jq --raw-output '.autosend' "$check_trackma_config_config_file")"
    if [ "$AUTORET_VALUE" = "always" ] || [ "$AUTOSEN_VALUE" = "always" ]; then
        printf "%b" "
ðŸ’¥ Anime Manager was unable to start!
   Please change the 'autoretrieve' and 'autosave' options
   in '$check_trackma_config_config_file'
   to a value other than 'always'.
"
        exit
    fi
    select_account
}

#* BOOKMARKS

# Generate and return a bookmark's filename from the anime title
get_cache_filename() {
    if [ -z "$anime_title" ]; then
        printf "ðŸ’¥ ERROR: unable to get bookmark file (no title).\n"
        kill $$
    fi
    get_xxhash "$(
        printf "%s" "$anime_title"
    )"
}

# saves a magnet link to a cache file
cache_link() {
    if [ -n "$magnet_link" ]; then
        cache_link_filename="$(get_cache_filename)"
        printf "%s" "$magnet_link" | gzip -cf | base64 >"$LINK_CACHE_DIR/$cache_link_filename"
    fi
}

# prints a cached magnet link
get_cached_link() {
    cached_file_content="$(cat "$LINK_CACHE_DIR/$(get_cache_filename)")"
    printf "%b\n" "$(
        base64 -d <<EOF | gunzip
$cached_file_content
EOF
    )"
}

# checks if there is a cached magnet link for the current anime title
has_cached_link() {
    if [ -s "$LINK_CACHE_DIR/$(get_cache_filename)" ]; then
        true
    else
        false
    fi
}

# deletes a cached link
delete_link_cache() {
    delete_link_cache_filename="$(get_cache_filename)"
    delete_link_cache_file="${LINK_CACHE_DIR}/${delete_link_cache_filename}"
    if [ -n "$delete_link_cache_filename" ] && [ -s "$delete_link_cache_file" ]; then
        rm -f "$delete_link_cache_file"
    fi
}

# monitors playback progress and updates anime episode count
monitor_playback_time() {
    get_playback_percent
    # check for app exit and playback percent value
    while [ -z "$(sed -En "/finished playback|\[cplayer\] EOF code: 1|\[main\] Exiting...|end of playlist, exiting/p" "$PLAYER_LOGFILE")" ] && [ "$cur_playback_percent" -lt "$MEDIA_PLAYER_PERCENT_WATCHED" ]; do
        sleep 2
        get_playback_percent
    done
    if [ -n "$cur_playback_percent" ]; then
        if [ "$cur_playback_percent" -ge "$MEDIA_PLAYER_PERCENT_WATCHED" ]; then
            set_ep_as_watched
        fi
    fi
}

# Monitor the player log file for player exit messages. This is
# part of the playlist mode to automatically play the next anime
# functionality.
monitor_media_player_app_exit() {
    while [ -z "$(sed -En "/finished playback|\[cplayer\] EOF code: 1|\[main\] Exiting...|end of playlist, exiting/p" "$PLAYER_LOGFILE")" ]; do sleep 1; done
    # re enable command log
    [ "$DEBUG" -eq 1 ] && set -x
    curl -XPOST localhost:6266 -d 'abort' >/dev/null 2>&1
}

#* MEDIA PLAYER MENU
# the menu that shows up when the media player opens
media_player_menu() {
    media_player_exit_code=""
    # block until the play status is set up
    while [ "$play_status" -eq "$PLAY_STATUS_WAITING" ]; do
        sleep 1
    done
    if [ "$play_status" -eq "$PLAY_STATUS_ERRORED" ]; then
        # fatal error, go back to mainmenu
        echo && line_to_remove
        if [ "$player_source" = "streaming" ]; then
            printf "$MSG_ERR_COLOR%s$RESET\n" "      ðŸ’¥ Unable to play (streaming)." && line_to_remove
        else
            printf "$MSG_ERR_COLOR%s$RESET\n" "      ðŸ’¥ Unable to play (torrenting)." && line_to_remove
        fi
        printf "%s\n" "      [Enter]  â—‚ MAIN MENU" && line_to_remove
        # recovery menu loop
        while true; do
            read -r key
            key="$(start_substring "$key" 1)"
            if [ "$key" = "" ]; then
                line_to_remove
                clear_lines
                break
            fi
        done
        player_source="torrenting"
        nyaa_search_res=""
        file_list=""
        magnet_link=""
        media_player_exit_code="$PLAYER_MENU_END_CODE"
        return
    elif [ "$play_status" = "$PLAY_STATUS_EXITED" ]; then
        # the user decided to go to main menu
        clear_lines
        clear_modifiers
        media_player_exit_code="$PLAYER_MENU_END_CODE"
        return
    fi
    clear_lines
    if [ -z "$anime_title" ]; then
        printf "ðŸ’¥ anime_title is not set"
        kill $$
    fi
    trimmed_anime_title=$(trim "$anime_title")
    playing_menu=""
    if [ "$INCOGNITO_MODE" -eq 0 ]; then
        # trackma account entries
        if [ "$last_show_episode" != "?" ] && [ "$cur_anime_episode" -eq "$last_show_episode" ]; then
            playing_menu="ðŸ Set as Watched\n"
            [ "$show_type" != "movie" ] && trimmed_anime_title="ðŸ END! â”€ $trimmed_anime_title"
        else
            playing_menu="â­ï¸  Set as Watched + Play next â–¶\nâœ… Set as Watched\n"
        fi
    fi
    # player reset entries
    if [ "$player_source" = "torrenting" ] || [ "$player_source" = "cached_link" ]; then
        # common menu for torrenting
        playing_menu="${playing_menu}ðŸ™ˆ Unexpected? Select another file â–¸"
        if [ -n "$nyaa_search_res" ]; then
            playing_menu="${playing_menu}\nðŸ”Ž Select another search result"
        fi
        if [ "$INCOGNITO_MODE" -eq 0 ]; then
            if ! has_cached_link; then
                playing_menu="${playing_menu}\nðŸ”– Add magnet link to Bookmarks"
            elif has_cached_link && [ "$player_source" = "torrenting" ]; then
                # the user performed a new search, let them overwrite cached links with the new magnet
                playing_menu="${playing_menu}\nðŸ”– Overwrite bookmarked link\nðŸ—‘ï¸  Delete bookmark"
            elif has_cached_link && [ "$player_source" = "cached_link" ]; then
                playing_menu="${playing_menu}\nðŸ—‘ï¸  Delete bookmark"
            fi
        fi
    elif [ "$player_source" = "streaming" ]; then
        if [ -n "$animdl_search_index" ]; then
            playing_menu="${playing_menu}ðŸ”Ž Select another search result"
        fi
    fi
    # for some reason fzf doesn't like this logic inside the label text
    media_player_menu_label="$(
        if [ -n "$show_type" ]; then
            printf "%s" " ($show_type)" | tr '[:lower:]' '[:upper:]'
        fi
    ) â”€ ${trimmed_anime_title}$(
        if [ -n "$show_type" ] && [ "$show_type" != "movie" ]; then
            printf " â–¶ %s" "$cur_anime_episode"
        fi
    )"
    if [ "$AUTO_UPDATE" -eq 1 ]; then
        {
            monitor_playback_time
        } &
    fi
    if [ "$playlist_mode" -eq 1 ]; then
        {
            monitor_media_player_app_exit
        } &
    fi
    FZF_PREVIEW_WINDOW_CMD="printf \"%s\" '$debug_match_info' | jq"
    media_player_menu_choice=$(printf "%b" "${playing_menu}\n${TO_MAIN_MENU}" |
        $FZF -i --prompt="Choose an action: " \
            --border-label "â•¢ â™£  ðŸ“º  NOW PLAYING${media_player_menu_label} â™£  â•Ÿ" \
            --header "â‡… Navigation â”€ [ESC] Exit â”€ [Enter] Select" \
            --header-first \
            --preview "$FZF_PREVIEW_WINDOW_CMD" \
            --bind "ctrl-l:toggle-preview" \
            --preview-window "$PREVIEW_WINDOW_OPTS" \
            --bind "shift-right:change-preview-window($MENU_PREVIEW_POS_MODES)+preview:$FZF_PREVIEW_WINDOW_CMD" \
            --listen 6266 \
            --preview-label "STREAM DEBUG" | cut -d " " -f1)
    # silence loop debug log for readability
    if [ "$media_player_menu_choice" = "â—‚" ]; then
        prompt="$TO_MAIN_MENU"
        clear_modifiers
        media_player_exit_code="$PLAYER_MENU_END_CODE"
    elif [ "$media_player_menu_choice" = "âœ…" ]; then
        set_ep_as_watched
        # Do not clear modifiers when in playlist mode. This is to avoid losing
        # global state when playing more than one episode per anime.
        [ "$playlist_mode" -eq 0 ] && clear_modifiers
        media_player_exit_code="$PLAYER_MENU_END_CODE"
    elif [ "$media_player_menu_choice" = "â­ï¸" ]; then
        set_ep_as_watched
        if [ "$player_source" = "torrenting" ] || [ "$player_source" = "cached_link" ]; then
            # will query nyaa again or resume from cache
            if has_cached_link; then
                # if a bookmark is set switch the player source
                # for searching the next episode
                player_source="cached_link"
            else
                # If no bookmark is set switch to nyaa search.
                # This could happen if the user deleted the
                # bookmark from the 'now playing' menu.
                player_source="torrenting"
            fi
            nyaa_search_res=""
            magnet_link=""
            file_list=""
        elif [ "$player_source" = "streaming" ]; then
            animdl_playthrough=1
        fi
        play_method_menu_opt=""
        cur_anime_episode=$((cur_anime_episode + 1))
    elif [ "$media_player_menu_choice" = "ðŸ" ]; then
        set_ep_as_watched
        media_player_exit_code="$PLAYER_MENU_END_CODE"
    elif [ "$media_player_menu_choice" = "ðŸ”Ž" ]; then
        if [ "$player_source" = "streaming" ]; then
            animdl_playthrough=0
        elif [ "$player_source" = "torrenting" ] || [ "$player_source" = "cached_link" ]; then
            nyaa_search_res=""
            magnet_link=""
            file_list=""
            player_source="torrenting"
        fi
        media_player_exit_code="$PLAYER_MENU_SELECT_SEARCH_RES_CODE"
    elif [ "$media_player_menu_choice" = "ðŸ™ˆ" ]; then
        # this will tell the select_magnet_file function to present a menu
        play_status="$PLAY_STATUS_FILE_SEL"
        # this will tell the play loop to execute play_anime function again
        media_player_exit_code="$PLAYER_MENU_FILE_SELECT_CODE"
    elif [ "$media_player_menu_choice" = "ðŸ”–" ]; then
        # add new bookmark or overwrite bookmark
        cache_link
        media_player_menu
    elif [ "$media_player_menu_choice" = "ðŸ—‘ï¸" ]; then
        # delete the bookmark for the current anime
        delete_link_cache
        media_player_menu
    fi
}

#* PLAYER LOGIC

# Torrent plays a file from a magnet link
# run completely detached from terminal for availability
torrent_magnet_link() {
    case "$MEDIA_PLAYER_APP" in
    "vlc")
        webtorrent_player_args="--extraintf oldrc --rc-fake-tty --rc-unix $MEDIA_PLAYER_VLC_SOCKET --verbose=1 --file-logging --logfile=$PLAYER_LOGFILE --play-and-exit"
        ;;
    "iina")
        webtorrent_player_args="--mpv-keep-open=no --mpv-log-file=$PLAYER_LOGFILE --mpv-input-ipc-server=$MEDIA_PLAYER_IINA_SOCKET"
        ;;
    "mpv")
        webtorrent_player_args="--keep-open=no --log-file=$PLAYER_LOGFILE --input-ipc-server=$MEDIA_PLAYER_MPV_SOCKET"
        ;;
    esac
    torrent_pid_file="$(get_temp_filename)"
    set +m
    (
        nohup node "$WEBTORRENT_CLI" download "$magnet_link" --select "$file_index" --out "$TORRENT_DOWNLOADS_DIR" --"$MEDIA_PLAYER_APP" --player-args="$webtorrent_player_args" >"$WEBTORRENT_LOGFILE" 2>&1 &
        echo $! >"$torrent_pid_file"
    )
    set -m
    # printf "%s" "$episode_data" | jq '.name' >"$CURRENTLY_PLAYING_LOGFILE"
    # remove from job queue to avoid info messages if we have to end the process with kill
    echo && line_to_remove
    printf "$MSG_INFO_COLOR%s$RESET\n" "      ðŸš€ Torrent is playing soon (please wait...)" && line_to_remove
    play_episode_torrent_status=$(check_torrent_health "$(cat "$torrent_pid_file")")
    if [ "$play_episode_torrent_status" -eq "$TORRENT_STATUS_ERRORED" ]; then
        printf "$MSG_WARN_COLOR%s$RESET\n" "      ðŸš« Unable to play (torrenting)" && line_to_remove
        magnet_link=""
        play_status=$PLAY_STATUS_ERRORED
    else
        rm "$torrent_pid_file"
        play_status=$PLAY_STATUS_OKPLAYING
    fi
    # do not clear_lines here because the messages are chained
}

# gets info from a magnet link
get_magnet_info() {
    echo && line_to_remove
    printf "$MSG_INFO_COLOR%s$RESET\n" "      ðŸ—ƒï¸  Searching for matching file..." && line_to_remove
    get_magnet_info_data="$(python3 "$NYAA_FE_BIN" --title "$anime_title_match" --synonyms "$(printf "%s" "$show_synonyms")" --magnet-link "$magnet_link" --episode "$cur_anime_episode" --type "$show_type")"
    episode_data="$(printf "%s" "$get_magnet_info_data" | awk -F"////" '{print $1}' | sed "s/'/'\"'\"'/g")"
    file_list="$(printf "%s" "$get_magnet_info_data" | awk -F"////" '{print $2}')"
    file_index="$(printf "%s" "$get_magnet_info_data" | awk -F"////" '{print $3}')"
    debug_match_info=$episode_data
    # do not clear_lines here because the messages are chained
}

# get magnet content and select a file from it
# it picks the file index from the magnet file if there is no file list initialized
# or it allows the user to pick a file from the list
select_magnet_file() {
    if [ -z "$file_list" ]; then
        get_magnet_info
    fi
    [ "$file_index" = "$NYAA_FID_CODE_CONTENT_MISMATCH" ] && play_status="$PLAY_STATUS_FILE_SEL"
    if [ "$play_status" = "$PLAY_STATUS_FILE_SEL" ]; then
        if [ "$file_list" = "None" ]; then
            printf "$MSG_WARN_COLOR%s$RESET\n" "      ðŸš« Could not find any matching files in this magnet" && line_to_remove
            magnet_link=""
            file_list=""
            play_status=$PLAY_STATUS_ERRORED
            return
        fi
        FZF_PREVIEW_WINDOW_CMD="printf \"\n%s\n\n%b\" {}"
        file_index=$(
            printf "%b" "$file_list\nâ—‚ NOW PLAYING" | sed "s/\"//g" |
                $FZF -i --prompt "Choose a file: " \
                    --border-label "â•¢ â™£  ðŸ—ƒï¸  FILE SELECTION â”€ $(trim "$anime_title") â–¶ $cur_anime_episode â™£  â•Ÿ" \
                    --header "â‡… Navigation â”€ [ESC] Exit â”€ [Ctrl-L] Expand â”€ [Enter] Play â–¶ (torrenting)" \
                    --header-first \
                    --preview "$FZF_PREVIEW_WINDOW_CMD" \
                    --preview-window "$PREVIEW_WINDOW_OPTS" \
                    --bind "shift-right:change-preview-window($MENU_PREVIEW_POS_MODES)+preview:$FZF_PREVIEW_WINDOW_CMD" \
                    --preview-label ' Expanded view ' \
                    --bind "ctrl-l:toggle-preview" | cut -d " " -f1
        )
    fi
}

create_playlist() {
    full_info=$(get_watching_shows)
    if [ ! "$full_info" ]; then
        full_info="Your watching list is empty"
        watch_choice=$(
            printf "%s\n%s" "$full_info" "$BACK_TO_SUBMENU" |
                $FZF -i --prompt "(multi) Choose anime for your playlist: " \
                    --border-label "â•¢ â™£  CREATE PLAYLIST ($(
                        if [ "$TRACKER_SERVICE" = "anilist" ]; then
                            printf "%s" "re+watching"
                        else
                            printf "%s" "watching"
                        fi
                    ) list) â™£  â•Ÿ" \
                    --header "â‡… Navigation â”€ [ESC] Exit â”€ [Enter] Play â–¶" \
                    --header-first
        )
        clear_modifiers
    fi
    if [ "$random_anime" -eq 1 ]; then
        watch_choice=$(printf "%s" "$full_info" | shuf -n 1)
    elif [ "$random_airing" -eq 1 ]; then
        # format and filter airing shows, select one randomly
        watch_choice=$(printf "%s" "$full_info" | sed -n "/ðŸ†•/p" | shuf -n 1)
    else
        full_info="$(printf "%s" "$full_info")"
        WATCH_MENU_PREVIEW_CMD="TO_MAIN_MENU=\"$TO_MAIN_MENU\"; TRACKMA_STATUS_MENU_ENTRIES=\"$TRACKMA_STATUS_MENU_ENTRIES\"; TRACKMA_LIST_REGEX=\"$TRACKMA_LIST_REGEX\"; TRACKMA_ENTRY_REGEX=\"$TRACKMA_ENTRY_REGEX\"; GLOBAL_TRACKMA_FIFO=$GLOBAL_TRACKMA_FIFO; GLOBAL_TRACKMA_TMPFILE=$GLOBAL_TRACKMA_TMPFILE; $trackma_query_function_code; $filter_trackma_list_function_code; $get_trackma_status_code_function_code; $get_title_fragment_function_code; $get_entry_index_function_code; $format_anime_info_function_code; $get_mixed_anime_info_function_code; get_mixed_anime_info {}"
        cur_playlist=$(
            printf "%s\n%s" "$BACK_TO_SUBMENU" "$full_info" |
                $FZF -i --prompt "(multi) Choose anime for your playlist: " \
                    --multi \
                    --preview "$WATCH_MENU_PREVIEW_CMD" \
                    --preview-window "$PREVIEW_WINDOW_OPTS" \
                    --bind "shift-right:change-preview-window($MENU_PREVIEW_POS_MODES)+preview:$WATCH_MENU_PREVIEW_CMD" \
                    --preview-label ' Info ' \
                    --border-label "â•¢ â™£  CREATE PLAYLIST ($(
                        if [ "$TRACKER_SERVICE" = "anilist" ]; then
                            printf "%s" "re+watching"
                        else
                            printf "%s" "watching"
                        fi
                    )) list â™£  â•Ÿ" \
                    --header "â‡… Navigation â”€ [Ctrl-L] Toggle info â”€ [ESC] Exit â”€ [Enter] Play â–¶" \
                    --bind "ctrl-l:toggle-preview" \
                    --header-first --tac
        )
    fi
    if [ -n "$(printf "%s" "$cur_playlist" | sed -En "/$BACK_TO_SUBMENU/p")" ] || [ -z "$cur_playlist" ]; then
        cur_playlist=""
        return
    fi
    echo && line_to_remove
    if [ "$(printf "%b\n" "$cur_playlist" | wc -l)" -gt 1 ]; then
        printf "      ðŸŽ¦ How many episodes per anime?\n" && line_to_remove
    else
        printf "      ðŸŽ¦ How many episodes?\n" && line_to_remove
    fi
    printf "      ðŸ‘‰ (leave blank for default) [1]: " && line_to_remove
    read -r playlist_ep_count
    playlist_ep_count="$(printf "%s" "$playlist_ep_count" | sed -E "s/[^0-9]//g")"
    if [ -z "$playlist_ep_count" ]; then
        playlist_ep_count=1
    fi
    clear_lines
}

# plays an anime episode via streaming or torrenting
play_anime() {
    reset_logs
    # reset the media player
    reset_media_player_app
    # reset media player log file
    printf "" >"$PLAYER_LOGFILE"
    while ! connectivity_check; do
        echo && line_to_remove
        printf "$MSG_WARN_COLOR%s$RESET\n" "      ðŸŒ´ðŸ¦• NO INTERNET CONNECTION ãƒ»ãƒ»ãƒ»" && line_to_remove
        printf "$MSG_WARN_COLOR%s$RESET\n" "      Please check your connection and press [Enter]" && line_to_remove
        read -r key
        key="$(start_substring "$key" 1)"
        [ "$key" = "" ] && clear_lines && continue
    done
    if [ "$player_source" = "torrenting" ]; then
        if [ -z "$magnet_link" ]; then
            # get magnet link and play it with webtorrent-cli
            if [ -z "$nyaa_search_res" ]; then
                echo && line_to_remove
                printf "$MSG_INFO_COLOR%s$RESET\n" "      ðŸ˜º Searching Nyaa Torrents. Please wait..." && line_to_remove
                nyaa_search_res="$($NYAA_SEARCH_BIN --title "$anime_title_match" --episode "$cur_anime_episode" --quality 1080 --show-type "$show_type")"
                if printf "%s" "$nyaa_search_res" | grep "////" >/dev/null 2>&1; then
                    nyaa_search_ret_msg=$(printf "%s" "$nyaa_search_res" | awk -F "////" '{print $1}')
                    nyaa_search_ret_code=$(printf "%s" "$nyaa_search_res" | awk -F "////" '{print $2}')
                fi
                if [ "$nyaa_search_ret_code" = "$NYAA_SEARCH_CODE_NO_RESULTS" ]; then
                    nyaa_search_res="{\"name\": \"$nyaa_search_ret_msg\"}"
                elif [ "$nyaa_search_ret_code" = "$NYAA_SEARCH_CODE_FATAL_ERROR" ]; then
                    echo && line_to_remove
                    printf "$MSG_WARN_COLOR%s$RESET\n" "      ðŸš« $nyaa_search_ret_msg" && line_to_remove
                    play_status=$PLAY_STATUS_ERRORED
                    return
                fi
                if [ "$INCOGNITO_MODE" -eq 0 ]; then
                    # incognito mode source selection menu is the same as the main menu
                    # so we do not need two options in that case
                    # incognito mode does not know about synonyms either
                    nyaa_search_res="{\"name\": \"$SELECT_SOURCE\"}\n{\"name\": \"$NYAA_SEARCH_SYNONYM\"}\n${nyaa_search_res}"
                    # replace simple quotes with 'smart quotes' to avoid filtering command failure
                    # and to not disrupt the user experience
                    nyaa_search_res="$(printf "%s" "$nyaa_search_res" | sed "s/'/â€™/g")"
                fi
                clear_lines
            fi
            FZF_PREVIEW_WINDOW_CMD="printf \"\n%s\n\n%b\" {} 'â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nColor code: \nðŸŸ¢ Trusted\nðŸ”´ Remake\nâšªï¸ No category\n\nMore info: https://nyaa.si/help'"
            PROMPT_TEXT="Choose a search result: "
            nya_res_choice=$(
                printf "%b" "{\"name\": \"$TO_MAIN_MENU\"}\n$nyaa_search_res" | jq --raw-output '.name' |
                    $FZF -i --prompt "$PROMPT_TEXT" \
                        --border-label "â•¢ â™£  SEARCH RESULTS (Nyaa Torrents): $(trim "$anime_title_match") â–¶ $cur_anime_episode â™£  â•Ÿ" \
                        --header "â‡… Navigation â”€ [ESC] Exit â”€ [Ctrl-L] Expand â”€ [Enter] Play â–¶ (torrenting)" \
                        --header-first \
                        --tac \
                        --preview "$FZF_PREVIEW_WINDOW_CMD" \
                        --preview-window "$PREVIEW_WINDOW_OPTS" \
                        --preview-label ' Expanded view ' \
                        --bind "ctrl-l:toggle-preview" \
                        --bind "shift-right:change-preview-window($MENU_PREVIEW_POS_MODES)+preview:$FZF_PREVIEW_WINDOW_CMD" \
                        --bind "ctrl-l:toggle-preview" \
                        --bind "ctrl-b:change-prompt($(printf "\033[44;37m BLU-RAY: \033[0m"))+reload:printf \"%b\" '$nyaa_search_res' | jq --raw-output '.name' | sed -En '/[bB][dD]|[bB][lL][uU][\-]*[rR][aA][yY]/p'" \
                        --bind "tab:change-prompt($PROMPT_TEXT)+reload:printf \"%b\" '{\"name\": \"$TO_MAIN_MENU\"}\n$nyaa_search_res' | jq --raw-output '.name'" \
                        --bind "ctrl-a:change-prompt($(printf "\033[43;37m DUAL-AUDIO: \033[0m"))+reload:printf \"%b\" '$nyaa_search_res' | jq --raw-output '.name' | sed -n '/[dD][uU][aA][lL]/p'" \
                        --bind "ctrl-d:change-prompt($(printf "\033[46;37m DUBBED: \033[0m"))+reload:printf \"%b\" '$nyaa_search_res' | jq --raw-output '.name' | sed -n '/[dD][uU][bB]/p'" \
                        --bind "ctrl-r:change-prompt($(printf "\033[101;37m RAW: \033[0m"))+reload:printf \"%b\" '$nyaa_search_res' | jq --raw-output '.name' | sed -n '/[rR][aA][wW]/p'" \
                        --bind "ctrl-s:change-prompt($(printf "\033[103;90m SUBBED: \033[0m"))+reload:printf \"%b\" '$nyaa_search_res' | jq --raw-output '.name' | sed -n '/[sS][uU][bB]/p'" \
                        --bind "ctrl-f:change-prompt($(printf "\033[104;37m MULTI: \033[0m"))+reload:printf \"%b\" '$nyaa_search_res' | jq --raw-output '.name' | sed -n '/[mM][uU][lL][tT][iI]/p'" \
                        --bind "ctrl-v:change-prompt($(printf "\033[100;90m VHS: \033[0m"))+reload:printf \"%b\" '$nyaa_search_res' | jq --raw-output '.name' | sed -n '/[vV][hH][sS]/p'" \
                        --bind "ctrl-t:change-prompt($(printf "\033[42;37m TRUSTED: \033[0m"))+reload:printf \"%b\" '$nyaa_search_res' | jq --raw-output '.name' | sed -n '/ðŸŸ¢/p'" \
                        --bind "ctrl-o:change-prompt($(printf "\033[45;37m OVA: \033[0m"))+reload:printf \"%b\" '$nyaa_search_res' | jq --raw-output '.name' | sed -n '/[oO][vV][aA]/p'"
            )
            # These conditionals need to be in this order for the user to
            # be able to select a different source or synonym before exiting
            # if the search returned no results.
            if [ "$nya_res_choice" = "$NYAA_SEARCH_SYNONYM" ]; then
                play_status="$PLAY_STATUS_SEARCH_SYNONYM"
                return
            elif [ "$nya_res_choice" = "$SELECT_SOURCE" ]; then
                play_status="$PLAY_STATUS_SELECT_SOURCE"
                return
            elif [ "$nyaa_search_ret_code" = "$NYAA_SEARCH_CODE_NO_RESULTS" ]; then
                play_status="$PLAY_STATUS_EXITED"
                return
            elif [ "$nya_res_choice" = "$TO_MAIN_MENU" ]; then
                play_status="$PLAY_STATUS_EXITED"
                return
            elif [ -z "$nya_res_choice" ]; then
                play_status="$PLAY_STATUS_EXITED"
                return
            fi
            magnet_link="$(printf "%b" "$nyaa_search_res" | jq -c "select( .name == \"$nya_res_choice\" )" | jq --raw-output ".magnet")"
        fi
        select_magnet_file
        [ "$file_index" = "â—‚" ] && play_status=$PLAY_STATUS_OKPLAYING && return
        if [ "$play_status" = "$PLAY_STATUS_ERRORED" ]; then
            # could not find matching file
            return
        fi
        if [ "$file_index" = "$NYAA_SEARCH_CODE_FATAL_ERROR" ]; then
            printf "$MSG_WARN_COLOR%s$RESET\n" "      ðŸš« FATAL ERROR!" && line_to_remove
            magnet_link=""
            file_list=""
            play_status=$PLAY_STATUS_ERRORED
            return
        elif [ -z "$file_index" ]; then
            # return to 'now playing' menu
            play_status=$PLAY_STATUS_OKPLAYING
            return
        else
            torrent_magnet_link
        fi
    elif [ "$player_source" = "streaming" ]; then
        stream_providers=$(array "animepahe" "allanime")
        echo && line_to_remove
        printf "$MSG_INFO_COLOR%s$RESET\n" "      ðŸ’¡ Streaming (animdl)" && line_to_remove
        while IFS= read -r provider; do
            decoded_stream_provider=$(printf '%s\n' "$provider" | array_element_decode)
            if [ "$animdl_playthrough" -eq 0 ]; then
                play_episode_stream_fifo_write="$(get_temp_filename)"
                mkfifo -m 600 "$play_episode_stream_fifo_write"
                # switch temporarily to mpv in exceptional case
                if [ "$decoded_stream_provider" = "allanime" ] && [ "$MEDIA_PLAYER_APP" = "iina" ]; then
                    # iina doesn't go well with allanime
                    # save player in helper var
                    media_player_helper="iina"
                    MEDIA_PLAYER_APP="mpv"
                fi
                stream_pid_file="$(get_temp_filename)"
                set +m
                (
                    ANIMDL_CONFIG="$ANIMDL_CONF_FILE" nohup animdl stream "$decoded_stream_provider:$anime_title_match" --range "$cur_anime_episode" --player "$MEDIA_PLAYER_APP" <"$play_episode_stream_fifo_write" >"$ANIMDL_LOGFILE" 2>&1 &
                    echo $! >"$stream_pid_file"
                )
                set -m
                animdl_pid="$(cat "$stream_pid_file")"
                exec 4>"$play_episode_stream_fifo_write"
                printf "$MSG_INFO_COLOR%s$RESET\n" "      ðŸ”Ž Please wait, searching the stream provider ($decoded_stream_provider)..." && line_to_remove
                stream_health=20
                while [ $stream_health -gt 0 ]; do
                    # check for search result prompt
                    if ! grep "Select the search result" "$ANIMDL_LOGFILE" >/dev/null 2>&1; then
                        if grep "Could not find any streams" "$ANIMDL_LOGFILE" >/dev/null 2>&1; then
                            # stream started automatically
                            play_status=$PLAY_STATUS_ERRORED
                            printf "$MSG_INFO_COLOR%s$RESET\n" "      ðŸš« Could not find any streams" && line_to_remove
                            return
                        fi
                        if [ -z "$(sed -En "/AV:|libmpv|A-V|File started|Running vlc/p" "$PLAYER_LOGFILE")" ]; then
                            stream_health=$((stream_health - 1))
                        else
                            # stream started automatically
                            play_status=$PLAY_STATUS_OKPLAYING
                            printf "$MSG_INFO_COLOR%s$RESET\n" "      ðŸš€ The stream is starting (please wait...)" && line_to_remove
                            return
                        fi
                    else
                        break
                    fi
                    sleep 1
                done
                if [ $stream_health -eq 0 ]; then
                    printf "$MSG_WARN_COLOR%s$RESET\n" "      ðŸš« No results found ($decoded_stream_provider), next..." && line_to_remove
                    play_status=$PLAY_STATUS_ERRORED
                    # next provider
                    echo >"$ANIMDL_LOGFILE"
                    continue
                fi
                clear_lines
                results=$(sed -En '/^[[:space:]]+[0-9]+\./p' "$ANIMDL_LOGFILE")
                animdl_search_index="$(
                    printf "%b" "$SELECT_SOURCE\n$TO_MAIN_MENU\n$results" | sed "s/^[[:space:]]*//" |
                        $FZF --prompt="Select a search result: " \
                            --border-label "â•¢ â™£  SEARCH RESULTS ($decoded_stream_provider): $(trim "$anime_title_match") â–¶ Episode $cur_anime_episode â™£  â•Ÿ" \
                            --header "â‡… Navigation â”€ [ESC] Exit â”€ [Enter] Play â–¶ (streaming)" \
                            --header-first \
                            --tac | cut -d '.' -f1
                )"
                if [ "$animdl_search_index" = "$SELECT_SOURCE" ]; then
                    play_status="$PLAY_STATUS_SELECT_SOURCE"
                    animdl_search_index=""
                    return
                elif [ "$animdl_search_index" = "$TO_MAIN_MENU" ]; then
                    play_status=$PLAY_STATUS_EXITED
                    animdl_search_index=""
                    return
                elif [ -z "$animdl_search_index" ]; then
                    play_status=$PLAY_STATUS_EXITED
                    animdl_search_index=""
                    return
                fi
                animdl_playthrough=1
                printf "%b" "$animdl_search_index\n" >"$play_episode_stream_fifo_write"
                # shellcheck disable=2188
                4>&-
                sleep 2 # wait for the stream to start
                stream_health=20
                printf "$MSG_INFO_COLOR%s$RESET\n" "      Trying to stream with $decoded_stream_provider" && line_to_remove
                while [ $stream_health -gt 0 ]; do
                    if [ -z "$(sed -En "/AV:|libmpv|A-V|File started|Running vlc/p" "$PLAYER_LOGFILE")" ]; then
                        stream_health=$((stream_health - 1))
                    else
                        break
                    fi
                    sleep 1
                done
                if [ $stream_health -eq 0 ]; then
                    echo && line_to_remove
                    printf "$MSG_WARN_COLOR%s$RESET\n" "      ðŸš« Unable to stream with $decoded_stream_provider, next..." && line_to_remove
                    play_status=$PLAY_STATUS_ERRORED
                    # next provider
                    echo "" >"$ANIMDL_LOGFILE"
                    continue
                else
                    rm "$play_episode_stream_fifo_write"
                    unset stream_tmpfile
                    unset stream_fifo_write
                    printf "$MSG_INFO_COLOR%s$RESET\n" "      ðŸš€ The stream is starting (please wait...)" && line_to_remove
                    play_status=$PLAY_STATUS_OKPLAYING
                    return
                fi
            else
                [ -z "$animdl_search_index" ] && kill $$
                # switch temporarily to mpv in exceptional case
                if [ "$decoded_stream_provider" = "allanime" ] && [ "$MEDIA_PLAYER_APP" = "iina" ]; then
                    # iina doesn't go well with allanime
                    # save player in helper var
                    media_player_helper="iina"
                    MEDIA_PLAYER_APP="mpv"
                fi
                play_episode_stream_fifo_write="$(get_temp_filename)"
                mkfifo -m 600 "$play_episode_stream_fifo_write"
                stream_pid_file="$(get_temp_filename)"
                set +m
                (
                    ANIMDL_CONFIG="$ANIMDL_CONF_FILE" nohup animdl stream "$decoded_stream_provider:$anime_title_match" --index "$animdl_search_index" --range "$cur_anime_episode" --player "$MEDIA_PLAYER_APP" <"$play_episode_stream_fifo_write" >"$ANIMDL_LOGFILE" 2>&1 &
                    echo $! >"$stream_pid_file"
                )
                set -m
                exec 4>"$play_episode_stream_fifo_write"
                animdl_pid="$(cat "$stream_pid_file")"
                stream_health=20
                while [ $stream_health -gt 0 ]; do
                    if grep "Could not find any streams" "$ANIMDL_LOGFILE" >/dev/null 2>&1; then
                        # stream started automatically
                        play_status=$PLAY_STATUS_ERRORED
                        printf "$MSG_INFO_COLOR%s$RESET\n" "      ðŸš« Could not find any streams" && line_to_remove
                        return
                    fi
                    if [ -z "$(sed -En "/AV:|libmpv|A-V|File started|Running vlc/p" "$PLAYER_LOGFILE")" ]; then
                        stream_health=$((stream_health - 1))
                    else
                        break
                    fi
                    sleep 1
                done
                if [ $stream_health -eq 0 ]; then
                    echo && line_to_remove
                    printf "$MSG_WARN_COLOR%s$RESET\n" "      ðŸš« Unable to stream with $decoded_stream_provider" && line_to_remove
                    play_status=$PLAY_STATUS_ERRORED
                    # next provider
                    continue
                else
                    play_status=$PLAY_STATUS_OKPLAYING
                    return
                fi
            fi
        done <<EOF
$stream_providers
EOF
    elif [ "$player_source" = "self_magnet" ]; then
        echo && line_to_remove
        printf "$MSG_INFO_COLOR%s$RESET\n" "      ðŸ§² Paste your magnet link and press Enter (silent input): " && line_to_remove
        stty_orig=$(stty -g)
        stty -echo
        read -r magnet_link
        stty "$stty_orig"
        magnet_link="$(printf "%s" "$magnet_link" | sed "s/;//g" | tr -d '\012')" # newline esc seq in octal
        clear_lines
        if [ -z "$magnet_link" ]; then
            play_status=$PLAY_STATUS_EXITED
            magnet_link=""
            return
        fi
        player_source="torrenting"
        play_anime
    elif [ "$player_source" = "cached_link" ]; then
        if has_cached_link; then
            # check for cached data
            if [ "$play_status" != "$PLAY_STATUS_FILE_SEL" ]; then
                echo && line_to_remove
                printf "$MSG_INFO_COLOR%s$RESET\n" "      ðŸ”– Loading bookmark..." && line_to_remove
            fi
            cached_playback=1
            magnet_link="$(get_cached_link)"
            select_magnet_file
            [ "$file_index" = "â—‚" ] && play_status=$PLAY_STATUS_OKPLAYING && return
            if [ "$file_index" = "$NYAA_SEARCH_CODE_FATAL_ERROR" ]; then
                printf "$MSG_WARN_COLOR%s$RESET\n" "      ðŸš« FATAL ERROR: please contact development" && line_to_remove
                printf "$MSG_WARN_COLOR%s$RESET\n" "      ðŸš« https://github.com/anma-dev/Anime-Manager#support" && line_to_remove
                magnet_link=""
                file_list=""
                play_status=$PLAY_STATUS_ERRORED
                return
            elif [ -z "$file_index" ]; then
                # return to 'now playing' menu
                play_status=$PLAY_STATUS_OKPLAYING
                return
            else
                torrent_magnet_link
            fi
        fi
    fi
}

#* INCOGNITO MENU
#
# The menu that is presented when the user switches incognito mode on.
incognito_menu() {
    tput clear
    INCOGNITO_MENU_HELPTEXT="
ðŸ‘¤  Switch Incognito Mode off.
â”€â”€â”€
ðŸ’¡  Stream with animdl. You will need to type a search query and episode number. This option uses streaming for playing content.
â”€â”€â”€
ðŸ˜º  Search Nyaa Torrents. You will need to type a search query, type and episode number and select a search result to play it. This option uses torrenting for playing content.
"
    INCOGNITO_MENU_ENTRIES="$PLAY_METHOD_TORRENTING\n$PLAY_METHOD_STREAMING\n$EXIT_INCOGNITO_MODE"
    MAINMENU_TITLE="MAIN MENU"
    menu_entries=$INCOGNITO_MENU_ENTRIES
    menu_title=$MAINMENU_TITLE
    menu_help_text=$INCOGNITO_MENU_HELPTEXT
    prompt=""
    CHECKPOINTFILE="$TMP_PATH/tmp-checkpoint"
    # always remove checkpoint file for every incognito user
    if [ -s "$CHECKPOINTFILE" ]; then
        rm -f "$CHECKPOINTFILE"
    fi
    print_readme_first_msg
    [ "$MINIMAL" -eq 0 ] && paint_logo
    [ "$MINIMAL" -eq 0 ] && print_subheader
    while true; do
        if [ -z "$prompt" ]; then
            FZF_PREVIEW_WINDOW_CMD="printf \"%s\n\" \"$menu_help_text\""
            clear_modifiers
            prompt=$(
                printf "%b" "$menu_entries" |
                    $FZF -i --prompt="Choose an action: " \
                        --border-label "â•¢ â™£  $menu_title â™£  â•Ÿ" \
                        --header "â‡… Navigation â”€ [ESC] Exit â”€ [Ctrl-L] Help â”€ [Enter] Select" \
                        --header-first \
                        --preview-window "$PREVIEW_WINDOW_OPTS" \
                        --bind "shift-right:change-preview-window($MENU_PREVIEW_POS_MODES)+preview:$FZF_PREVIEW_WINDOW_CMD" \
                        --preview "$FZF_PREVIEW_WINDOW_CMD" \
                        --bind "ctrl-l:toggle-preview" \
                        --preview-label " Help "
            )
        fi
        case $prompt in
        "$PLAY_METHOD_TORRENTING")
            player_source="torrenting"
            incognito_play_msg_emoji="ðŸ˜º"
            prompt="PLAY"
            ;;
        "$PLAY_METHOD_STREAMING")
            player_source="streaming"
            incognito_play_msg_emoji="ðŸ’¡"
            prompt="PLAY"
            ;;
        "PLAY")
            echo && line_to_remove
            printf "$MSG_INFO_COLOR      %s What anime do you want to watchâ”$RESET\n" "$incognito_play_msg_emoji" && line_to_remove
            printf "         ðŸ‘‰ " && line_to_remove
            read -r anime_title
            clear_lines
            [ -z "$anime_title" ] && clear_modifiers && continue
            anime_title="$(printf "%s" "$anime_title" | sed -E 's/[^a-zA-Z0-9 ]//g' | sed "s/[[:space:]]*$//g" | sed "s/^[[:space:]]*//g")"
            echo && line_to_remove
            printf "      %s Enter an episode number if applicable\n" "$incognito_play_msg_emoji" && line_to_remove
            printf "         ðŸ‘‰ " && line_to_remove
            read -r cur_anime_episode
            clear_lines
            cur_anime_episode="$(printf "%s" "$cur_anime_episode" | sed -E 's/[^0-9]//g')"
            if [ -z "$cur_anime_episode" ]; then
                cur_anime_episode=1
                show_type="movie"
            else
                show_type="tv"
            fi
            last_show_episode=0
            while true; do
                play_anime
                if [ "$play_status" = "$PLAY_STATUS_SELECT_SOURCE" ]; then
                    clear_modifiers
                    break # go to main menu
                elif [ "$play_status" = "$PLAY_STATUS_EXITED" ]; then
                    clear_modifiers
                    break # go to main menu
                fi
                media_player_menu
                clear_lines
                if [ "$media_player_exit_code" = "$PLAYER_MENU_SELECT_SEARCH_RES_CODE" ]; then
                    # new state already set by media_player_menu function
                    continue
                elif [ "$media_player_exit_code" = "$PLAYER_MENU_END_CODE" ]; then
                    clear_modifiers
                    break # go to main menu
                fi
            done
            ;;
        "$EXIT_INCOGNITO_MODE")
            INCOGNITO_MODE=0
            line_to_remove # remove incognito label
            clear_lines    # remove incognito label
            break
            ;;
        esac
    done
}

# Timeout the torrent process if the content is not readily available.
check_torrent_health() {
    # allow it to start first
    sleep 2
    check_torrent_health_waitingtime=0
    check_torrent_health_checkinterval=5
    check_torrent_health_torrent_status=$TORRENT_STATUS_STALLED
    check_torrent_health_webtorrentpid="$1"
    while [ $check_torrent_health_torrent_status = "$TORRENT_STATUS_STALLED" ] && [ $check_torrent_health_waitingtime -lt $TORRENT_TMOUT ]; do
        # if the torrent is not finding peers
        # before or after download start
        lastlog="$(tail -n20 "$WEBTORRENT_LOGFILE")"
        if [ -z "$(printf "%s" "$lastlog" | sed -n "/Streaming/p")" ] || [ -n "$(printf "%s" "$lastlog" | sed -n "/Peers: 0\/0/p")" ]; then
            check_torrent_health_waitingtime=$((check_torrent_health_waitingtime + check_torrent_health_checkinterval))
            sleep $check_torrent_health_checkinterval
        else
            break
        fi
    done
    if [ $check_torrent_health_waitingtime -eq $TORRENT_TMOUT ]; then
        # kill the process
        if ps "$check_torrent_health_webtorrentpid" >/dev/null 2>&1; then
            kill -9 "$check_torrent_health_webtorrentpid" >/dev/null 2>&1
        fi
        printf "%s" "$TORRENT_STATUS_ERRORED"
    else
        printf "%s" "$TORRENT_STATUS_OKPLAYING"
    fi
}

select_player_source() {
    if [ -z "$player_source" ]; then
        PLAY_METHOD_MENU="$PLAY_METHOD_TORRENTING\n$PLAY_METHOD_MAGNET\n$PLAY_METHOD_STREAMING"
        if has_cached_link; then
            PLAY_METHOD_MENU="$PLAY_METHOD_SAVED_LINK\n$PLAY_METHOD_MENU"
        fi
        if [ "$random_anime" -eq 1 ]; then
            menu_label="SELECT SOURCE: ðŸ”€ $(trim "$anime_title") â–¶ $cur_anime_episode"
            top_menu="$TO_MAIN_MENU"
        elif [ "$random_airing" -eq 1 ]; then
            menu_label="SELECT SOURCE: ðŸ†• $(trim "$anime_title") â–¶ $cur_anime_episode"
            top_menu="$BACK_TO_SUBMENU"
        elif [ -n "$sort_airing" ] && [ "$sort_airing" -eq 1 ]; then
            # if we come from airing list selection
            menu_label="SELECT SOURCE: ðŸ†• $(trim "$anime_title") â–¶ $cur_anime_episode"
            top_menu="$BACK_TO_SUBMENU"
        else
            menu_label="SELECT SOURCE: $(trim "$anime_title") â–¶ $cur_anime_episode"
            top_menu="$TO_MAIN_MENU"
        fi
        # we check the play status otherwise we would never be able to select source
        if [ "$TORRENT_ONLY" -eq 1 ] && [ "$play_status" != "$PLAY_STATUS_SELECT_SOURCE" ]; then
            if has_cached_link; then
                player_source="cached_link"
            else
                player_source="torrenting"
            fi
        else
            play_method_menu_opt="$(
                printf "%b" "$PLAY_METHOD_MENU\n$top_menu" |
                    $FZF -i --prompt="Select a source: " \
                        --border-label "â•¢ â™£  $menu_label â™£  â•Ÿ" \
                        --header "â‡… Navigation â”€ [ESC] Exit â”€ [Enter] Select" \
                        --header-first | cut -d " " -f1
            )"
            if [ "$play_method_menu_opt" = "â—‚" ] || [ -z "$play_method_menu_opt" ]; then
                return
            elif [ "$play_method_menu_opt" = "ðŸ’¡" ]; then
                player_source="streaming"
            elif [ "$play_method_menu_opt" = "ðŸ˜º" ]; then
                player_source="torrenting"
            elif [ "$play_method_menu_opt" = "ðŸ§²" ]; then
                player_source="self_magnet"
            elif [ "$play_method_menu_opt" = "ðŸ”–" ]; then
                player_source="cached_link"
            fi
        fi
    fi
}

watch_anime() {
    if [ -z "$anime_title" ] && [ -z "$cur_anime_episode" ]; then
        full_info=$(get_watching_shows)
        if [ ! "$full_info" ]; then
            full_info="Your watching list is empty"
            watch_choice=$(
                printf "%s\n%s" "$full_info" "$TO_MAIN_MENU" |
                    $FZF -i --prompt "Choose an anime to watch: " \
                        --border-label "â•¢ â™£  YOUR $(
                            if [ "$TRACKER_SERVICE" = "anilist" ]; then
                                printf "%s" "(RE)WATCHING LISTS"
                            else
                                printf "%s" "WATCHING LIST"
                            fi
                        ) â™£  â•Ÿ" \
                        --header "â‡… Navigation â”€ [ESC] Exit â”€ [Enter] Play â–¶" \
                        --header-first
            )
            return
        fi
        if [ "$random_anime" -eq 1 ]; then
            watch_choice=$(printf "%s" "$full_info" | shuf -n 1)
        elif [ "$random_airing" -eq 1 ]; then
            # format and filter airing shows, select one randomly
            watch_choice=$(printf "%s" "$full_info" | sed -n "/ðŸ†•/p" | shuf -n 1)
        else
            full_info="$(printf "%s" "$full_info")"
            WATCH_MENU_PREVIEW_CMD="TO_MAIN_MENU=\"$TO_MAIN_MENU\"; TRACKMA_STATUS_MENU_ENTRIES=\"$TRACKMA_STATUS_MENU_ENTRIES\"; TRACKMA_LIST_REGEX=\"$TRACKMA_LIST_REGEX\"; TRACKMA_ENTRY_REGEX=\"$TRACKMA_ENTRY_REGEX\"; GLOBAL_TRACKMA_FIFO=$GLOBAL_TRACKMA_FIFO; GLOBAL_TRACKMA_TMPFILE=$GLOBAL_TRACKMA_TMPFILE; $trackma_query_function_code; $filter_trackma_list_function_code; $get_trackma_status_code_function_code; $get_title_fragment_function_code; $get_entry_index_function_code; $format_anime_info_function_code; $get_mixed_anime_info_function_code; get_mixed_anime_info {}"
            watch_choice=$(
                printf "%s\n%s" "$TO_MAIN_MENU" "$full_info" |
                    $FZF -i --prompt "Choose an anime to watch: " \
                        --preview "$WATCH_MENU_PREVIEW_CMD" \
                        --preview-window "$PREVIEW_WINDOW_OPTS" \
                        --bind "shift-right:change-preview-window($MENU_PREVIEW_POS_MODES)+preview:$WATCH_MENU_PREVIEW_CMD" \
                        --preview-label ' Info ' \
                        --border-label "â•¢ â™£  YOUR $(
                            if [ "$TRACKER_SERVICE" = "anilist" ]; then
                                printf "%s" "(RE)WATCHING LISTS"
                            else
                                printf "%s" "WATCHING LIST"
                            fi
                        ) â™£  â•Ÿ" \
                        --header "â‡… Navigation â”€ [Ctrl-L] Toggle info â”€ [ESC] Exit â”€ [Enter] Play â–¶" \
                        --bind "ctrl-l:toggle-preview" \
                        --header-first --tac
            )
        fi
        [ "$watch_choice" = "$TO_MAIN_MENU" ] && prompt=$TO_MAIN_MENU && return
        if [ ! "$watch_choice" ]; then
            echo && line_to_remove
            printf "$MSG_WARN_COLOR%s$RESET\n" "      Nothing found!" && line_to_remove
            sleep 2
            clear_lines
            return
        fi
        watch_choice="$(clean_trackma_entry "$watch_choice")"
        title_fragment="$(get_title_fragment "$watch_choice")"
        #* we need to get the status and index before we get the full title.
        entry_index="$(get_entry_index "$watch_choice")"
        status="$(get_show_status)"
        anime_title=$(get_anime_title)
        last_watched_ep="$(get_last_watched_episode "$watch_choice")"
        last_show_episode="$(get_last_show_episode "$watch_choice")"
        # if we just don't know what the last episode is we increment anyways and give it a try
        if [ "$last_show_episode" = "?" ] || [ "$last_watched_ep" -lt "$last_show_episode" ]; then
            cur_anime_episode=$((last_watched_ep + 1))
        else
            cur_anime_episode="1"
        fi
    fi
    [ -z "$status" ] && printf "ðŸ’¥ Error no status" && kill $$
    if [ "$(get_trackma_status_code "$status")" != "$(get_trackma_status_code "Watching")" ] &&
        [ "$(get_trackma_status_code "$status")" != "$(get_trackma_status_code "Rewatching")" ]; then
        new_status="Watching"
        menu_play_options="Play â–¶\nðŸ”„ Set status as Watching + Play â–¶"
        if [ "$status" = "$(get_trackma_status_code "Completed")" ]; then
            menu_play_options="Play â–¶\nðŸ”„ Set status as Watching + Reset watched + Play â–¶"
            reset_episodes=1
            if [ "$TRACKER_SERVICE" = "anilist" ]; then
                new_status="Rewatching"
                menu_play_options="Play â–¶\nðŸ”„ Set status as Rewatching + Play â–¶"
            fi
        else
            reset_episodes=0
        fi
        selected_play_option=$(
            printf "%b\n%s" "$menu_play_options" "$TO_MAIN_MENU" |
                $FZF -i --prompt "Choose an option: " \
                    --border-label "â•¢ â™£  PLAY OPTIONS â™£  â•Ÿ" \
                    --header "â‡… Navigation â”€ [ESC] Exit â”€ [Enter] Select" \
                    --header-first | cut -d " " -f1
        )
        if [ "$selected_play_option" = "â—‚" ]; then
            return
        elif [ "$selected_play_option" = "ðŸ”„" ]; then
            # update episode before updating the status otherwise the index changes
            if [ "$reset_episodes" -eq 1 ]; then
                printf "filter %s\nupdate '%s' %s\n" "$(get_trackma_status_code "$status")" "$entry_index" "0" | trackma_query >>"$TRACKMA_LOGFILE"
                cur_anime_episode="1"
                last_watched_ep="0"
            fi
            # Update anime status
            printf "filter %s\nstatus %s %s\n" "$(get_trackma_status_code "$status")" "$entry_index" "$(get_trackma_status_code "$new_status")" | trackma_query >"$TRACKMA_LOGFILE" 2>&1
            status=$new_status
            # update series index after changing lists
            printf "filter %s\nsearch '^%s$'\n" "$(get_trackma_status_code "$status")" "$(printf "%s" "$anime_title" | sed "s/'/'\\\''/g")" | trackma_query >/dev/null 2>&1
            while ! grep "result" "$GLOBAL_TRACKMA_TMPFILE" >/dev/null 2>&1; do :; done
            res="$(cat "$GLOBAL_TRACKMA_TMPFILE")"
            entry_index="$(format_trackma_list "$res" | sed -En "s/$TRACKMA_ENTRY_REGEX/\1/p")"
        fi
    fi
    # We query trackma again because we want official english and romaji titles
    show_info=$(printf "filter %s\ninfo %s\n" "$(get_trackma_status_code "$status")" "$entry_index" | trackma_query)
    while ! grep "Status" "$GLOBAL_TRACKMA_TMPFILE" >/dev/null 2>&1; do :; done
    anime_title_ro="$(printf "%s" "$show_info" | sed -n "/Romaji/p" | cut -d ":" -f2 | sed "s/ //")"
    anime_title_en="$(printf "%s" "$show_info" | sed -n "/English/p" | cut -d ":" -f2 | sed "s/ //")"
    # give preference to Romaji, then Japanese, then English titles, as this gives better matching
    if [ -n "$anime_title_ro" ] && [ "$anime_title_ro" != "None" ]; then
        anime_title_match=$anime_title_ro
    else
        anime_title_match=$anime_title
    fi

    # player loop
    play_method_menu_opt=""
    media_player_exit_code=""
    if printf "%s" "$show_info" | grep "Type: " >/dev/null 2>&1; then
        show_type="$(printf "%b" "$show_info" | grep "Type: " | awk -F": " '{print $2}')"
    fi
    if printf "%s" "$show_info" | grep "Synonyms: " >/dev/null 2>&1; then
        show_synonyms="$(printf "%b" "$show_info" | grep "Synonyms: " | awk -F": " '{print $2}')"
        show_synonyms="$anime_title, $anime_title_en, $(printf "%s" "$show_synonyms" | sed "s/[]'[]//g")"
    fi
    #* SOURCE SELECT LOOP
    while true; do
        select_player_source
        if [ "$player_source" = "â—‚" ] || [ -z "$player_source" ]; then
            play_status="$PLAY_STATUS_EXITED"
            prompt="$TO_MAIN_MENU"
            break
        fi
        # play loop
        while true; do
            play_anime
            if [ "$play_status" = "$PLAY_STATUS_SEARCH_SYNONYM" ]; then
                # the user wants to search again with a title synonym
                case $anime_title_match in
                "$anime_title_en")
                    [ -z "$anime_title_ro" ] && continue # does not perform a new search
                    anime_title_match="$anime_title_ro"
                    ;;
                "$anime_title_ro")
                    [ -z "$anime_title_en" ] && continue # does not perform a new search
                    anime_title_match="$anime_title_en"
                    ;;
                esac
                nyaa_search_res="" # does perform a new search
                magnet_link=""
                file_list=""
                play_status=""
                continue
            elif [ "$play_status" = "$PLAY_STATUS_SELECT_SOURCE" ]; then
                player_source=""
                break # select player source
            elif [ "$play_status" = "$PLAY_STATUS_EXITED" ]; then
                clear_modifiers
                break 2 # go to main menu
            fi
            media_player_menu
            clear_lines
            # from media player menu the user should not be able to switch play sources
            if [ "$media_player_exit_code" = "$PLAYER_MENU_FILE_SELECT_CODE" ]; then
                # new state already set by media_player_menu function
                continue
            elif [ "$media_player_exit_code" = "$PLAYER_MENU_SELECT_SEARCH_RES_CODE" ]; then
                # new state already set by media_player_menu function
                continue
            elif [ "$media_player_exit_code" = "$PLAYER_MENU_END_CODE" ]; then
                break 2 # go to main menu
            else
                # Here we break in all other cases to avoid infinite loop (for
                # example the user sent signal to script). Do not clear
                # modifiers when in playlist mode.
                break 2 # go to main menu
            fi
        done
    done
}

#* ACCOUNT MENU
#
# The menu that is presented when the user selects a Trackma account.
account_menu() {
    prompt=""
    MAINMENU_ENTRIES="$WATCH_HISTORY\n$WATCH\n$WATCH_RANDOM\n$ADD_ANIME\n$LIST\n$UPDATE_STATUS\n$SCORE_SHOW\n$ENTER_INCOGNITO_MODE\n$TO_SUBMENU"
    SUBMENU_ENTRIES="$SWITCH_ACCOUNTS\n$DELETE_ANIME\n$WATCH_RAND_AIRING\n$LIST_AIRING\n$UPDATE_EPISODES\n$SET_ALTNAME\n$PULL\n$PUSH\n$LIST_BY_SCORE\n$PLAYLIST\n$TO_MAIN_MENU"
    MAINMENU_TITLE="MAIN MENU"
    SUBMENU_TITLE="MORE OPTIONS"
    menu_entries=$MAINMENU_ENTRIES
    menu_title=$MAINMENU_TITLE
    menu_help_text=$MAIN_MENU_HELPTEXT
    AM_USER_HOME_DIR="${CONFIG_PATH}/$(printf "%s" "$USERNAME" | sed -E 's/[^A-Za-z0-9._-]/_/g')"
    mkdir -p "$AM_USER_HOME_DIR"
    CHECKPOINTFILE="${AM_USER_HOME_DIR}/checkpoint"
    print_readme_first_msg
    [ "$MINIMAL" -eq 0 ] && paint_logo
    [ "$MINIMAL" -eq 0 ] && print_subheader
    LINK_CACHE_DIR="${AM_USER_HOME_DIR}/bookmarks"
    mkdir -p "$LINK_CACHE_DIR"
    WATCH_HISTORY_FILE="${AM_USER_HOME_DIR}/watch-history"
    [ ! -f "$WATCH_HISTORY_FILE" ] && touch "$WATCH_HISTORY_FILE"
    if [ "$TRACKER_SERVICE" = "anilist" ]; then
        # exception for anilist
        TRACKMA_STATUS_MENU_ENTRIES="$(printf "%b" "Watching\nCompleted\nRewatching\nPaused\nDropped\nPlan to Watch" | sort -r)"
    else
        TRACKMA_STATUS_MENU_ENTRIES="$(printf "%b" "Watching\nCompleted\nOn Hold\nDropped\nPlan to Watch" | sort -r)"
    fi
    # account menu loop
    while true; do
        if [ -z "$prompt" ]; then
            clear_modifiers
            FZF_MAIN_MENU_PREVIEW_WINDOW_CMD="printf \"%s\" \"$menu_help_text\""
            prompt=$(
                printf "%b" "$menu_entries" |
                    $FZF -i --prompt="Choose an action: " \
                        --border-label "â•¢ â™£  $menu_title â™£  â•Ÿ" \
                        --header "â‡… Navigation â”€ [ESC] Exit â”€ [Ctrl-L] Help â”€ [Enter] Select" \
                        --header-first \
                        --preview "$FZF_MAIN_MENU_PREVIEW_WINDOW_CMD" \
                        --preview-window "$PREVIEW_WINDOW_OPTS" \
                        --bind "shift-right:change-preview-window($MENU_PREVIEW_POS_MODES)+preview:$FZF_MAIN_MENU_PREVIEW_WINDOW_CMD" \
                        --bind "ctrl-l:toggle-preview" \
                        --preview-label " Help "
            )
        fi
        case $prompt in
        "$SWITCH_ACCOUNTS")
            line_to_remove # remove account label
            clear_lines    # remove account label
            printf "account\nq\n" | trackma_query >/dev/null 2>&1
            close_trackma
            # select_account
            break
            ;;
        "$ENTER_INCOGNITO_MODE")
            INCOGNITO_MODE=1
            line_to_remove # remove account label
            clear_lines    # remove account label
            close_trackma
            break
            ;;
        "$TO_MAIN_MENU")
            menu_entries=$MAINMENU_ENTRIES
            menu_title=$MAINMENU_TITLE
            menu_help_text=$MAIN_MENU_HELPTEXT
            clear_modifiers
            ;;
        "$TO_SUBMENU" | "$BACK_TO_SUBMENU")
            menu_entries=$SUBMENU_ENTRIES
            menu_title=$SUBMENU_TITLE
            menu_help_text=$SUB_MENU_HELPTEXT
            clear_modifiers
            ;;
        "$WATCH_HISTORY")
            clear_modifiers
            HIST="$(cat "$WATCH_HISTORY_FILE")"
            if [ -z "$HIST" ]; then
                sel=$(
                    printf "Your watch history is empty\n%s" "$TO_MAIN_MENU" |
                        $FZF -i --border-label "â•¢ â™£  WATCH HISTORY â™£  â•Ÿ" \
                            --header "â‡… Navigation â”€ [ESC] Exit" \
                            --header-first
                )
            else
                HIST=$(column -t -s "////" "$WATCH_HISTORY_FILE")
                HIST="$TO_MAIN_MENU\n$DELETE_HIST\n$HIST"
                watch_hist_choice=$(
                    printf "%b" "$HIST" |
                        $FZF -i --prompt="Select an anime: " \
                            --border-label "â•¢ â™£  WATCH HISTORY â™£  â•Ÿ" \
                            --header "â‡… Navigation â”€ [ESC] Exit â”€ [Enter] Play â–¶" \
                            --header-first --tac
                )
                [ "$watch_hist_choice" = "$TO_MAIN_MENU" ] && prompt=$TO_MAIN_MENU && continue
                [ "$watch_hist_choice" = "$DELETE_HIST" ] && delete_watch_history && continue
                anime_title="$(printf "%s" "$watch_hist_choice" | sed -En "s/^.*[AP]M[[:space:]]*\|[[:space:]]*[[:digit:]]*[[:space:]]*(.*)/\1/p")"
                watch_hist_entry="$(get_entry_from_title)"
                entry_index="$(get_entry_index "$watch_hist_entry")"
                title_fragment="$anime_title"
                status="$(get_show_status)"
                last_watched_ep="$(get_last_watched_episode "$watch_hist_entry")"
                last_show_episode="$(get_last_show_episode "$watch_hist_entry")"
                # only increment if it's not the last episode of the show
                # if we don't know the last aired apisode just attempt playing the next episode
                if [ "$last_show_episode" = "?" ] || [ "$last_watched_ep" -lt "$last_show_episode" ]; then
                    cur_anime_episode=$((last_watched_ep + 1))
                else
                    cur_anime_episode="1"
                fi
                prompt="$WATCH"
            fi
            ;;
        "$WATCH_RANDOM")
            random_anime=1
            prompt=$WATCH
            ;;
        "$WATCH_RAND_AIRING")
            random_airing=1
            prompt=$WATCH
            ;;
        "$WATCH")
            watch_anime
            clear_modifiers
            ;;
        "$ADD_ANIME")
            new_status="Plan to Watch"
            echo && line_to_remove
            printf "      ðŸ§© What anime do you plan to watchâ” \n         ðŸ‘‰ " && line_to_remove
            read -r series_title
            series_title="$(printf "%s" "$series_title" | sed -E 's/[^a-zA-Z0-9'\''" -]//g' | sed "s/'/'\\\''/g")"
            clear_lines
            if [ -z "$series_title" ]; then
                line_to_remove && clear_lines
                clear_modifiers
                continue
            fi
            results="$(printf "filter %s\nadd '%s'\n" "$(get_trackma_status_code "$new_status")" "$series_title" | trackma_query)"
            printf "$MSG_INFO_COLOR%s$RESET" "      ðŸ”Ž Searching the catalog ($TRACKER_SERVICE), please wait..." && line_to_remove
            while [ -z "$(sed -En "/Choose|DataError/p" "$GLOBAL_TRACKMA_TMPFILE")" ]; do :; done
            clear_lines
            results="$(sed -En "/^[0-9]+:/p" "$GLOBAL_TRACKMA_TMPFILE")"
            [ -z "$results" ] && results="No results found.\n$TO_MAIN_MENU"
            add_anime_choice="$(
                printf "%b" "$TO_MAIN_MENU\n$results" | sort -r --version-sort |
                    $FZF --prompt="Choose the anime to add: " \
                        --border-label "â•¢ â™£  ADD NEW ANIME ($new_status list) â™£  â•Ÿ" \
                        --header "â‡… Navigation â”€ [ESC] Exit â”€ [Enter] Add" \
                        --header-first --tac
            )"
            [ -z "$results" ] && clear_modifiers && continue
            if [ "$add_anime_choice" = "$TO_MAIN_MENU" ]; then
                printf "\n" >"$GLOBAL_TRACKMA_FIFO"
                clear_modifiers && continue
            fi
            add_anime_choice_id=$(printf "%s" "$add_anime_choice" | cut -d ':' -f1)
            printf "%b\n" "$add_anime_choice_id" >"$GLOBAL_TRACKMA_FIFO"
            clear_modifiers
            ;;
        "$DELETE_ANIME")
            status=$(
                printf "%b\n%s" "$TRACKMA_STATUS_MENU_ENTRIES" "$BACK_TO_SUBMENU" |
                    $FZF -i --prompt="Choose a status: " \
                        --border-label "â•¢ â™£  DELETE ANIME (Status select) â™£  â•Ÿ" \
                        --header "â‡… Navigation â”€ [ESC] Exit â”€ [Enter] Select" \
                        --header-first
            )
            [ "$status" = "$BACK_TO_SUBMENU" ] && prompt="$BACK_TO_SUBMENU" && continue
            status=$(get_trackma_status_code "$status")
            FULL_LIST=$(printf "filter %s\nls\n" "$status" | trackma_query)
            FULL_LIST=$(format_trackma_list "$FULL_LIST")
            [ -z "$FULL_LIST" ] && FULL_LIST="No anime found in this list..."
            FULL_LIST="$BACK_TO_SUBMENU\n$SWITCH_STATUS_MSG_MENU_ENTRY\n$FULL_LIST"
            anime_sel=$(
                printf "%b" "$FULL_LIST" |
                    $FZF -i --prompt="Choose an anime to DELETE: " \
                        --border-label "â•¢ â™£  DELETE ANIME ($status list) â™£  â•Ÿ" \
                        --header "â‡… Navigation â”€ [ESC] Exit â”€ [Enter] Delete" \
                        --header-first --tac
            )
            if [ "$anime_sel" = "$BACK_TO_SUBMENU" ]; then
                prompt="$BACK_TO_SUBMENU"
                continue
            elif [ "$anime_sel" = "$SWITCH_STATUS_MSG_MENU_ENTRY" ]; then
                continue
            fi
            del_confirm=$(
                printf "%b" "$anime_sel\n$BACK_TO_SUBMENU\n$SWITCH_STATUS_MSG_MENU_ENTRY" |
                    $FZF -i --prompt="ðŸ’¥ ðŸ’¥ ðŸ’¥ DELETE CONFIRMATION /// THIS IS PERMANENT ðŸ’¥ ðŸ’¥ ðŸ’¥ " \
                        --border-label "â•¢ â™£  ðŸ’¥ ðŸ’¥ ðŸ’¥ WARNING /// YOU ARE ABOUT TO DELETE AN ANIME!! ðŸ’¥ ðŸ’¥ ðŸ’¥  â•Ÿ" \
                        --header "â‡… Navigation â”€ [ESC] Exit â”€ [Enter] DELETE" \
                        --header-first | cut -d" " -f1
            )
            if [ "$del_confirm" = "â—‚" ]; then
                prompt="$BACK_TO_SUBMENU" && continue
            elif [ "$del_confirm" = "ðŸ”„" ]; then
                continue
            else
                printf "filter %s\ndelete %s\ny\n" "$status" "$del_confirm" | trackma_query >"$TRACKMA_LOGFILE" 2>&1
            fi
            ;;
        "$UPDATE_EPISODES" | "$UPDATE_STATUS")
            if [ "$prompt" = "$UPDATE_EPISODES" ]; then
                menuitem="$BACK_TO_SUBMENU"
                update_op_menu_label="UPDATE WATCHED EPISODES"
            else
                menuitem="$TO_MAIN_MENU"
                update_op_menu_label="UPDATE STATUS"
            fi
            # status select loop
            while true; do
                status=$(
                    printf "%s\n%s" "$TRACKMA_STATUS_MENU_ENTRIES" "$menuitem" |
                        $FZF -i --prompt="Choose a status: " \
                            --border-label "â•¢ â™£  ${update_op_menu_label} â™£  â•Ÿ" \
                            --header "â‡… Navigation â”€ [ESC] Exit â”€ [Enter] Select" \
                            --header-first
                )
                [ "$status" = "$menuitem" ] && prompt=$menuitem && break
                status=$(get_trackma_status_code "$status")
                # select anime loop
                while true; do
                    res="$(printf "filter %s\nls\n" "$status" | trackma_query)"
                    res="$(format_trackma_list "$res")"
                    if [ -z "$res" ]; then
                        res="This list has no items..."
                        printf "%b" "$res\n$menuitem" | $FZF -i --prompt="Choose an anime to update: " \
                            --border-label "â•¢ â™£  ${update_op_menu_label} ($status list) â™£  â•Ÿ" \
                            --header "â‡… Navigation â”€ [ESC] Exit â”€ [Enter] Select" \
                            --header-first
                        continue
                    fi
                    update_choice="$(
                        printf "%b" "$menuitem\n$SWITCH_STATUS_MSG_MENU_ENTRY\n$res" |
                            $FZF -i --prompt="Choose an anime to update: " \
                                --border-label "â•¢ â™£  ${update_op_menu_label} ($status list) â™£  â•Ÿ" \
                                --header "â‡… Navigation â”€ [ESC] Exit â”€ [Enter] Select" \
                                --header-first --tac
                    )"
                    if [ "$update_choice" = "$SWITCH_STATUS_MSG_MENU_ENTRY" ]; then
                        break
                    elif [ "$update_choice" = "$menuitem" ] || [ -z "$update_choice" ]; then
                        prompt=$menuitem
                        break 2
                    fi
                    #* set index first
                    entry_index="$(printf "%s" "$update_choice" | sed -En "s/$TRACKMA_ENTRY_REGEX/\1/p")"
                    anime_title="$(get_anime_title)"
                    last_watched_ep="$(printf "%s" "$update_choice" | sed -En "s/$TRACKMA_ENTRY_REGEX/\4/p")"
                    if [ "$prompt" = "$UPDATE_EPISODES" ]; then
                        echo && line_to_remove
                        printf "$MSG_INFO_COLOR%s$RESET\n" "      How many episodes of this anime have you watched so farâ”" && line_to_remove
                        printf "%s" "         ðŸ‘‰ " && line_to_remove
                        read -r new_episode_count
                        new_episode_count="$(start_substring "$new_episode_count" 4)"
                        new_episode_count="$(printf "%s" "$new_episode_count" | sed -E 's/[^0-9]//g')"
                        clear_lines
                        [ -z "$new_episode_count" ] && clear_modifiers && continue
                        if [ "$new_episode_count" -ne "$last_watched_ep" ]; then
                            # this will also change the status to completed if
                            # anime last episode = updated watched episode
                            # and if the user already scored the anime
                            printf "filter %s\nupdate '%s' %s\n" "$status" "$entry_index" "$new_episode_count" | trackma_query >"$TRACKMA_LOGFILE" 2>&1
                        fi
                    elif [ "$prompt" = "$UPDATE_STATUS" ]; then
                        update_choice=$(
                            printf "%b" "$TRACKMA_STATUS_MENU_ENTRIES\n$menuitem\n$SWITCH_STATUS_MSG_MENU_ENTRY" |
                                $FZF -i --prompt="Choose the new status: " \
                                    --border-label "â•¢ â™£  ${update_op_menu_label} â™£  â•Ÿ" \
                                    --header "â‡… Navigation â”€ [ESC] Exit â”€ [Enter] Select" \
                                    --header-first
                        )
                        if [ "$update_choice" = "$SWITCH_STATUS_MSG_MENU_ENTRY" ]; then
                            break
                        elif [ "$update_choice" = "$menuitem" ] || [ -z "$update_choice" ]; then
                            prompt=$menuitem
                            break 2
                        fi
                        new_status="$(get_trackma_status_code "$update_choice")"
                        if [ -n "$entry_index" ]; then
                            trackma_update_id="$entry_index"
                        else
                            trackma_update_id="$anime_title"
                            # escape single quotes for update query
                            trackma_update_id="$(printf "%s" "$anime_title" | sed "s/'/'\"'\"'/g")"
                        fi
                        printf "filter %s\nstatus '%s' %s\n" "$status" "$trackma_update_id" "$new_status" | trackma_query >/dev/null 2>&1
                        status="$new_status"
                    fi
                done
            done
            clear_modifiers
            ;;
        "$SCORE_SHOW")
            # status selection loop
            while true; do
                status=$(
                    printf "%b" "$TRACKMA_STATUS_MENU_ENTRIES\n$TO_MAIN_MENU" |
                        $FZF -i --prompt="Choose a status: " \
                            --border-label "â•¢ â™£  SCORE ANIME (Status select) â™£  â•Ÿ" \
                            --header "â‡… Navigation â”€ [ESC] Exit â”€ [Enter] Select" \
                            --header-first
                )
                status=$(get_trackma_status_code "$status")
                [ "$status" = "$TO_MAIN_MENU" ] && prompt=$TO_MAIN_MENU && clear_modifiers && break
                # anime selection loop
                while true; do
                    full_info="$(printf "filter %s\nls\n" "$status" | trackma_query)"
                    full_info="$(format_trackma_list "$full_info")"
                    full_info="$TO_MAIN_MENU\n$SWITCH_STATUS_MSG_MENU_ENTRY\n$full_info"
                    score_anime_choice="$(
                        printf "%b" "$full_info" |
                            $FZF -i --prompt="Choose an anime to score: " \
                                --border-label "â•¢ â™£  SCORE ANIME ($status) â™£  â•Ÿ" \
                                --header "â‡… Navigation â”€ [ESC] Exit â”€ [Enter] Select" \
                                --header-first --tac
                    )"
                    [ "$score_anime_choice" = "$TO_MAIN_MENU" ] && clear_modifiers && break 2
                    [ "$score_anime_choice" = "$SWITCH_STATUS_MSG_MENU_ENTRY" ] && break
                    entry_index="$(printf "%s" "$score_anime_choice" | cut -d" " -f1)"
                    anime_title=$(get_anime_title)
                    SCORE_MENU="(10) Masterpiece\n(9) Great\n(8) Very Good\n(7) Good\n(6) Fine\n(5) Average\n(4) Bad\n(3) Very Bad\n(2) Horrible\n(1) Appalling"
                    score=$(
                        printf "%b" "$SCORE_MENU" | $FZF -i --prompt="Select a score: " \
                            --border-label "â•¢ â™£  SCORING ANIME: $(trim "$anime_title") â™£  â•Ÿ" \
                            --header "â‡… Navigation â”€ [ESC] Exit â”€ [Enter] Select" \
                            --pointer ðŸŒŸ \
                            --header-first --tac | sed -En "s/\(([[:digit:]]+)\).*/\1/p"
                    )
                    clear_lines
                    printf "filter %s\nscore %s %s\n" "$status" "$entry_index" "$score" | trackma_query >/dev/null 2>&1
                done
            done
            ;;
        "$SET_ALTNAME")
            while true; do
                status=$(
                    printf "$TRACKMA_STATUS_MENU_ENTRIES\n%s" "$BACK_TO_SUBMENU" |
                        $FZF -i --prompt="Choose a status: " \
                            --border-label "â•¢ â™£  SET ALTERNATIVE NAME (Status select) â™£  â•Ÿ" \
                            --header "â‡… Navigation â”€ [ESC] Exit â”€ [Enter] Select" \
                            --header-first
                )
                [ "$status" = "$BACK_TO_SUBMENU" ] && prompt=$BACK_TO_SUBMENU && break
                status="$(get_trackma_status_code "$status")"
                while true; do
                    full_info="$(printf "filter %s\nls\n" "$status" | trackma_query)"
                    full_info=$(format_trackma_list "$full_info")
                    [ -z "$full_info" ] && full_info="No entries in this list."
                    full_info="$BACK_TO_SUBMENU\n$SWITCH_STATUS_MSG_MENU_ENTRY\n$full_info"
                    altname_choice="$(
                        printf "%b" "$full_info" |
                            $FZF -i --prompt="Choose an anime: " \
                                --border-label "â•¢ â™£  SET ALTERNATIVE NAME ($status list) â™£  â•Ÿ" \
                                --header "â‡… Navigation â”€ [ESC] Exit â”€ [Enter] Select" \
                                --header-first --tac
                    )"
                    [ "$altname_choice" = "$BACK_TO_SUBMENU" ] && prompt=$BACK_TO_SUBMENU && break 2
                    [ "$altname_choice" = "$SWITCH_STATUS_MSG_MENU_ENTRY" ] && break
                    entry_index=$(printf "%s" "$altname_choice" | cut -d" " -f1)
                    echo && line_to_remove
                    printf "%b" "      What is the altnameâ” (leave blank to clear it)\n      ðŸ‘‰ " && line_to_remove
                    read -r altname
                    line_to_remove # user intro
                    altname="$(printf "%s" "$altname" | sed -E 's/[^a-zA-Z0-9'\''" -]//g' | sed "s/'/'\\\''/g")"
                    printf "altname %s '%s'\n" "$entry_index" "$altname" | trackma_query >"$TRACKMA_LOGFILE" 2>&1
                    clear_lines
                done
            done
            ;;
        "$PULL")
            sel=$(
                printf "ðŸ”„ Pull remote list data... (does not overwrite local changes)\n%s" "$BACK_TO_SUBMENU" |
                    $FZF -i --prompt="Choose an option: " \
                        --border-label "â•¢ â™£  $PULL â™£  â•Ÿ" \
                        --header "â‡… Navigation â”€ [ESC] Exit â”€ [Enter] Select" \
                        --header-first | cut -d" " -f1
            )
            [ "$sel" = "$BACK_TO_SUBMENU" ] && prompt=$TO_MAIN_MENU && continue
            [ "$sel" = "ðŸ”„" ] &&
                printf "retrieve\n" | trackma_query >/dev/null 2>&1
            while ! sed -En "/>>|\?/p" "$GLOBAL_TRACKMA_TMPFILE" >/dev/null 2>&1; do :; done
            if grep "There are unqueued changes" "$GLOBAL_TRACKMA_TMPFILE" >/dev/null 2>&1; then
                pull_choice=$(printf "No, keep local list\nYes, overwrite local list" |
                    $FZF -i --prompt="There are unqueued changes. Overwrite local list?" \
                        --border-label "â•¢ â™£  $PULL â™£  â•Ÿ" \
                        --header "â‡… Navigation â”€ [ESC] Exit â”€ [Enter] Select" \
                        --header-first | cut -c1)
                if [ "$pull_choice" = "N" ]; then
                    printf "N\n" | trackma_query >/dev/null 2>&1
                elif [ "$pull_choice" = "Y" ]; then
                    printf "Y\n" | trackma_query >/dev/null 2>&1
                else
                    printf "\nðŸ’¥ An error occured while pulling from remote.\n"
                    exit 1
                fi
            fi
            clear_modifiers
            ;;
        "$PUSH")
            sel=$(
                printf "ðŸ”„ Overwrite remote lists\n%s" "$BACK_TO_SUBMENU" |
                    $FZF -i --prompt="Choose an option: " \
                        --border-label "â•¢ â™£  $PUSH â™£  â•Ÿ" \
                        --header "â‡… Navigation â”€ [ESC] Exit â”€ [Enter] Select" \
                        --header-first | cut -d" " -f1
            )
            [ "$sel" = "$BACK_TO_SUBMENU" ] && clear_modifiers && continue
            [ "$sel" = "ðŸ”„" ] &&
                printf "send\n" | trackma_query >/dev/null 2>&1
            clear_modifiers
            ;;
        "$PLAYLIST")
            playlist_mode=1
            AUTO_UPDATE=1
            # update subheader
            line_to_remove && clear_lines
            print_subheader
            create_playlist
            if [ "$cur_playlist" = "$BACK_TO_SUBMENU" ] || [ -z "$cur_playlist" ] || [ -z "$playlist_ep_count" ]; then
                playlist_mode=0
                # update subheader
                line_to_remove && clear_lines
                print_subheader
                clear_modifiers
                prompt="$BACK_TO_SUBMENU"
                continue
            fi
            while read -r playlist_item; do
                playlist_item="$(clean_trackma_entry "$playlist_item")"
                title_fragment="$(get_title_fragment "$playlist_item")"
                #* we need to get the status and index before we get the full title.
                entry_index="$(get_entry_index "$playlist_item")"
                status="$(get_show_status)"
                anime_title=$(get_anime_title)
                last_watched_ep="$(get_last_watched_episode "$playlist_item")"
                last_show_episode="$(get_last_show_episode "$playlist_item")"
                cur_anime_playlist_ep_count="$playlist_ep_count"
                if [ "$last_show_episode" != "?" ]; then
                    remaining_eps=$((last_show_episode - last_watched_ep))
                    if [ "$cur_anime_playlist_ep_count" -gt "$remaining_eps" ]; then
                        cur_anime_playlist_ep_count="$remaining_eps"
                    fi
                fi
                for i in $(seq 1 "$cur_anime_playlist_ep_count"); do
                    # if we don't know what the last episode is give it a try anyways
                    cur_anime_episode=$((last_watched_ep + 1))
                    watch_anime
                    if [ "$play_status" = "$PLAY_STATUS_EXITED" ]; then
                        # user cancelled the playlist
                        break 2
                    elif [ "$play_status" = "$PLAY_STATUS_ERRORED" ]; then
                        # an error occurred
                        printf "ðŸ’¥ Playlist ended"
                        break 2
                    fi
                    last_watched_ep="$cur_anime_episode"
                    if [ "$player_source" = "torrenting" ] || [ "$player_source" = "cached_link" ]; then
                        file_list="" # call file extractor for new episode
                    fi
                done
                # clear global state for the next anime queued in the playlist
                # queue. unsets animdl playthrough so the user will be prompted
                # again for the next anime
                clear_modifiers
            done <<EOF
$cur_playlist
EOF
            playlist_mode=0
            clear_modifiers
            prompt="$BACK_TO_SUBMENU"
            # update subheader
            line_to_remove && clear_lines
            print_subheader
            ;;
        "$LIST_AIRING")
            sort_airing=1
            prompt=$LIST
            ;;
        "$LIST_BY_SCORE")
            sort_score=1
            prompt=$LIST
            ;;
        "$LIST")
            if [ "$sort_score" -eq 1 ]; then
                top_menu_entry="$BACK_TO_SUBMENU"
            elif [ "$sort_airing" -eq 1 ]; then
                top_menu_entry="$BACK_TO_SUBMENU"
            else
                top_menu_entry="$TO_MAIN_MENU"
            fi
            status=$(
                printf "%s\n%s" "$TRACKMA_STATUS_MENU_ENTRIES" "$top_menu_entry" |
                    $FZF -i --prompt="Choose a status: " \
                        --border-label " â™£  LIST$(
                            if [ "$sort_score" -eq 1 ]; then
                                printf ' BY SCORE ðŸŒŸ'
                            elif [ "$sort_airing" -eq 1 ]; then
                                printf ' AIRING SHOWS ðŸ†•'
                            else
                                printf " SHOWS"
                            fi
                        ) (Status select) â™£  " \
                        --header "â‡… Navigation â”€ [ESC] Exit â”€ [Enter] Select" \
                        --header-first
            )
            [ "$status" = "$top_menu_entry" ] && prompt=$top_menu_entry && continue
            status=$(get_trackma_status_code "$status")
            if [ "$sort_score" -eq 1 ]; then
                # sort by score
                msg="$(printf "filter %s\nsort my_score\nls\n" "$status" | trackma_query)"
            else
                msg="$(printf "filter %s\nls\n" "$status" | trackma_query)"
            fi
            msg=$(format_trackma_list "$msg")
            if [ "$sort_airing" -eq 1 ]; then
                # filter airing show per user request
                msg=$(printf "%s" "$msg" | sed -n "/ðŸ†•/p")
            fi
            if [ ! "$msg" ]; then
                msg="This list has no items... "
                sel=$(
                    printf "%s\n%s\n%s" "$msg" "$top_menu_entry" "$SWITCH_STATUS_MSG_MENU_ENTRY" |
                        $FZF -i --border-label " â™£  LIST$(
                            if [ "$sort_score" -eq 1 ]; then
                                printf ' BY SCORE ðŸŒŸ'
                            elif [ "$sort_airing" -eq 1 ]; then
                                printf ' AIRING SHOWS ðŸ†•'
                            else
                                printf " SHOWS"
                            fi
                        ) ($status list) â™£  " \
                            --header "â‡… Navigation â”€ [Enter] Go back" \
                            --header-first \
                            --prompt ""
                )
                [ "$sel" = "$top_menu_entry" ] && prompt="$top_menu_entry" && continue
                continue
            fi
            export status
            while true; do
                FZF_PREVIEW_WINDOW_CMD="TRACKMA_LIST_REGEX=\"$TRACKMA_LIST_REGEX\"; TRACKMA_ENTRY_REGEX=\"$TRACKMA_ENTRY_REGEX\"; GLOBAL_TRACKMA_FIFO=$GLOBAL_TRACKMA_FIFO; GLOBAL_TRACKMA_TMPFILE=$GLOBAL_TRACKMA_TMPFILE; $trackma_query_function_code; $sanitize_ext_regex_function_code; $get_title_fragment_function_code; $get_trackma_status_code_function_code; $filter_trackma_list_function_code; $format_anime_info_function_code; $get_anime_info_function_code; get_anime_info {} $status"
                # watch choice is global state and will be used by the watch prompt
                list_choice=$(
                    printf "%s\n%s\n%s" "$top_menu_entry" "$SWITCH_STATUS_MSG_MENU_ENTRY" "$msg" |
                        $FZF -i --bind "ctrl-l:toggle-preview" \
                            --preview "$FZF_PREVIEW_WINDOW_CMD" \
                            --preview-window "$PREVIEW_WINDOW_OPTS" \
                            --bind "shift-right:change-preview-window($MENU_PREVIEW_POS_MODES)+preview:$FZF_PREVIEW_WINDOW_CMD" \
                            --preview-label ' Info ' \
                            --border-label " â™£  LIST$(
                                if [ "$sort_score" -eq 1 ]; then
                                    printf ' BY SCORE ðŸŒŸ'
                                elif [ "$sort_airing" -eq 1 ]; then
                                    printf ' AIRING SHOWS ðŸ†•'
                                else
                                    printf " SHOWS"
                                fi
                            ) ($status list) â™£  " \
                            --header "â‡… Navigation â”€ [Ctrl-L] Toggle info â”€ [ESC] Exit â”€ [Enter] Play â–¶" \
                            --header-first \
                            --prompt "" \
                            --tac
                )
                [ "$list_choice" = "$top_menu_entry" ] && clear_modifiers && break
                [ "$list_choice" = "$SWITCH_STATUS_MSG_MENU_ENTRY" ] && break
                #* trackma index needs to be set first!
                entry_index="$(printf "%s" "$list_choice" | sed -En "s/$TRACKMA_ENTRY_REGEX/\1/p")"
                anime_title=$(get_anime_title)
                last_show_episode="$(printf "%s" "$list_choice" | sed -En "s/$TRACKMA_ENTRY_REGEX/\5/p")"
                last_watched_ep="$(printf "%s" "$list_choice" | sed -En "s/$TRACKMA_ENTRY_REGEX/\4/p")"
                # only increment if it's not the last episode of the show
                # if we don't know the last aired apisode just attempt playing the next episode
                # last_show_episode can be a string or integer
                if [ "$last_show_episode" = "?" ]; then
                    cur_anime_episode=$((last_watched_ep + 1))
                elif [ "$last_watched_ep" -lt "$last_show_episode" ]; then
                    cur_anime_episode=$((last_watched_ep + 1))
                else
                    cur_anime_episode="1"
                fi
                prompt="$WATCH"
                break
            done
            ;;
        esac
    done
}

#*********************************
#* ENTRYPOINT
#*********************************

# Script entry point function
main() {
    check_setup
    # common fzf args
    PREVIEW_WINDOW_OPTS="right,70%,hidden,wrap"
    MENU_PREVIEW_POS_MODES="down,70%|left,70%|top,70%|"
    if [ "$MINIMAL" -eq 1 ]; then
        # initial preview options
        FZF="fzf -0 --ansi --cycle --ellipsis (...) --color dark --pointer > --border-label-pos 1 --reverse --border top --layout=reverse --info inline --no-separator --bind change:first --no-sort"
    else
        FZF="fzf -0 --ansi --cycle --ellipsis (...) --height 70% --border rounded --pointer ðŸ‘‰ --margin 5% --padding=1,0,0,0 --border-label-pos -1 --bind change:first --no-sort"
    fi
    while true; do
        if [ "$INCOGNITO_MODE" -eq 0 ]; then
            spawn_trackma
            check_trackma_config
        fi
        if [ "$INCOGNITO_MODE" -eq 0 ]; then
            account_menu
        else
            incognito_menu
        fi
    done
}

# Gracefully exit the script
#* Needs to be at the end of the script
on_exit() {
    onexit_last_exit_status="$?"
    onexit_parent_lineno="$1"
    onexit_message="${2:-(no message ($onexit_last_exit_status))}"
    onexit_exit_code="${3:-$onexit_last_exit_status}"
    [ "$AUTOINSTALL" -eq 1 ] && exit "$onexit_exit_code"
    if [ "$onexit_exit_code" -eq 130 ] || [ "$onexit_exit_code" -eq 0 ]; then
        tput clear && tput clear
    else
        printf "%s\n" "ERROR on line $onexit_parent_lineno - $onexit_message - exit code $onexit_exit_code"
    fi
    if [ "$INCOGNITO_MODE" -eq 0 ]; then
        close_trackma
    fi
    # cleanup, save disk space
    if [ "$DEBUG" -eq 0 ]; then
        reset_logs
        if [ "$TORRENT_DOWNLOADS_DIR" = "$DEFAULT_DOWNLOADS_DIR" ]; then
            rm -rf "$TORRENT_DOWNLOADS_DIR"
        fi
    fi
    clear_modifiers
    exit "$onexit_exit_code"
}
#* Must go before main function call
trap 'on_exit ${LINENO}' EXIT
main

#!/bin/sh
set -o errexit
set -o nounset

# override locale categories
eval export "$(locale)"
unset LC_ALL
LANG="C"
LC_ALL="C"
LC_COLLATE="C"
LC_CTYPE="C"
LC_MESSAGES="C"
LC_MONETARY="C"
LC_NUMERIC="C"
LC_TIME="C"
LC_ADDRESS="C"
LC_IDENTIFICATION="C"
LC_MEASUREMENT="C"
LC_NAME="C"
LC_PAPER="C"
LC_TELEPHONE="C"
LANGUAGE="en_US.UTF-8"
export LANG LC_ALL \
	LC_COLLATE \
	LC_CTYPE \
	LC_MESSAGES \
	LC_MONETARY \
	LC_NUMERIC \
	LC_TIME \
	LANGUAGE \
	LC_ADDRESS \
	LC_IDENTIFICATION \
	LC_MEASUREMENT \
	LC_NAME \
	LC_PAPER \
	LC_TELEPHONE

. ./lib/array

version="0.0.1"
OSTYPE="$(uname -s 2>/dev/null)"
parse_args() {
	# defaults
	debug=0
	small_logo=0
	monochrome_logo=0
	while true; do
		case "${1-}" in
		--small-logo) small_logo=1 ;;
		--monochrome-logo) monochrome_logo=1 ;;
		-d | --debug) debug=1 && set -x ;;
		-v | --version) printf "%s\n" "$version" && exit ;;
		-?*) printf "%s\n" "💥 Unknown option: $1" && exit 1 ;;
		*) break ;;
		esac
		shift
	done
}

case $# in
0) parse_args ;;
*) parse_args "$@" ;;
esac

# cleanly go to the main loop
# a 'modifier' for us is a flow control variable
clear_modifiers() {
	RANDOM_ANIME=0
	RANDOM_AIRING=0
	PROMPT=""
	LIST_AIRING=0
	SORT_SCORE=0
	ANIME_TITLE=""
	ANIME_TITLE_TRACKMA=""
	TRACKMA_SHOW_INDEX=""
	ANIME_EP=""
	STATUS=""
	NEW_STATUS=""
	LAST_WATCHED_EP=""
	NYAA_SEARCH_RES=""
	PLAY_STATUS=$PLAY_STATUS_WAITING
	PLAYER_SOURCE="torrenting"
	MAGNET_LINK=""
	PLAY_METHOD_MENU_OPT=""
	DEBUG_MATCH_INFO=""
	FILE_LIST=""
	FILE_INDEX=""
	ANIMDL_PLAYTHROUGH=0
	ANIMDL_SEARCH_INDEX=1
}

reset_logs() {
	echo > "$WEBTORRENT_LOGFILE"
	echo > "$TRACKMA_LOGFILE"
	echo > "$ANIMDL_LOGFILE"
	# echo > "$CURRENTLY_PLAYING_LOGFILE"
	echo > "$NYAA_SEARCH_LOGFILE"
	echo > "$NYAA_FID_LOGFILE"
}

onexit() {
	onexit_last_exit_status="$?"
	onexit_parent_lineno="$1"
	onexit_message="${2:-(no message ($onexit_last_exit_status))}"
	onexit_exit_code="${3:-$onexit_last_exit_status}"
	if [ "$onexit_exit_code" -eq 130 ] || [ "$onexit_exit_code" -eq 0 ]; then
		tput clear && tput clear
	else
		tput clear
		printf "%s\n" "ERROR on line $onexit_parent_lineno - $onexit_message - exit code $onexit_exit_code"
	fi
	# cleanup, save disk space
	[ $debug -eq 0 ] &&
		reset_logs &&
		rm -rf "$TORRENT_DOWNLOAD_DIR"
	clear_modifiers
	exit "$onexit_exit_code"
}

trap 'onexit ${LINENO}' 1 2 3 15

tput clear

# formats and prints a string
log() {
	printf "%b\n" "$1"
}

# returns true if the user has initialized an account
is_trackma_init() {
	if [ -n "$(printf "q\n" | trackma ls | sed -En "s/no account|Available accounts/&/p")" ]; then
		false
	else
		true
	fi
}

checkTrackmaConfig() {
	checkTrackmaConfig_trackma_config_file=""
	if [ -s "$HOME"/.trackma/config.json ]; then
		checkTrackmaConfig_trackma_config_file="$HOME/.trackma/config.json"
	elif [ -s "$HOME"/.config/trackma/config.json ]; then
		checkTrackmaConfig_trackma_config_file="$HOME/.config/trackma/config.json"
	fi
	AUTORET_VALUE="$(jq --raw-output '.autoretrieve' "$checkTrackmaConfig_trackma_config_file")"
	AUTOSEN_VALUE="$(jq --raw-output '.autosend' "$checkTrackmaConfig_trackma_config_file")"
	if [ "$AUTORET_VALUE" = "always" ] || [ "$AUTOSEN_VALUE" = "always" ]; then
		printf "%b" "
💥 Anime Manager was unable to start!
   Please change the 'autoretrieve' and 'autosave' options
   in '$checkTrackmaConfig_trackma_config_file'
   to a value other than 'always'.
"
		exit 1
	fi

	if ! is_trackma_init; then
		printf "LINK YOUR ACCOUNT TO TRACKMA\nNo account was found. Next steps:\n- 1. Open a new Terminal window or tab.\n- 2. Run 'trackma account' and follow the instructions to add and select your account.\n- 3. Come back to this prompt and press [Enter].\n(waiting...): "
		while ! is_trackma_init; do
			read -r KEY # TODO: -n1
			[ "$KEY" = "" ] && [ "$(is_trackma_init)" ] && break || printf "\n%s" "... Could not detect account, please try again... "
		done
		tput clear
	fi
}

# trim long show titles
trim() {
	MAX_LEN=20
	STRING="$1"
	C_COUNT=$(printf "%s" "$STRING" | wc -c | sed "s/ //g")
	if [ "$C_COUNT" -gt $MAX_LEN ]; then
		printf "%s" "$STRING" | cut -c 1-"$MAX_LEN" | sed "s/$/(...)/"
	else
		printf "%s" "$STRING"
	fi
}

line_to_remove() {
	LINES_TO_REMOVE="$((LINES_TO_REMOVE + 1))"
}

# clear n number of lines from output
# caveat: wrapped lines
clear_lines() {
	while [ $LINES_TO_REMOVE -gt 0 ]; do
		printf "%b" "${OVERWRITE}"
		LINES_TO_REMOVE=$((LINES_TO_REMOVE - 1))
	done
}

# check if we can run automatic install for missing dependencies
autoCompat() {
	if [ "$OSTYPE" = "Linux" ] && grep "Ubuntu" /etc/os-release >/dev/null 2>&1; then
		true
	elif [ "$OSTYPE" = "Darwin" ]; then
		true
	else
		log "Automatic installation does not support your platform yet\nbut we may add support for it in the future.\n\nPlease install the dependencies manually.\n\nMORE INFO: https://github.com/anma-dev/Anime-Manager#dependencies"
		exit 0
	fi
}

# get the shell configuration file path
getShellConfigFile() {
	getShellConfigFile_shell_cfig=""
	[ "$SHELL" = "/bin/bash" ] && touch "$HOME/.bash_profile" && getShellConfigFile_shell_cfig="$HOME/.bash_profile"
	# nvm on macos needs the shell config file
	[ "$SHELL" = "/bin/zsh" ] && touch "$HOME/.zshrc" && getShellConfigFile_shell_cfig="$HOME/.zshrc"
	printf "%s" "$getShellConfigFile_shell_cfig"
}

# install dependencies automatically if we can
install_dependencies() {
	shell_cfg="$(getShellConfigFile)"
	DEP_ERR=0
	install_dep_msg="🎉 Finished the autoinstall!\nRestart your Terminal app to start using Anime Manager."
	# Ubuntu (not WSL) and macOS support
	if ! which fzf pastel bat animdl trackma jq node >/dev/null 2>&1 || [ ! -s lib/webtorrent-cli/bin/cmd.js ]; then
		log "Anime Manager can automatically install its dependencies.\nSome dependencies were not found!" && line_to_remove
		DEP_ERR=1

		if autoCompat && [ $DEP_ERR -eq 1 ]; then
			printf "%s" "Install missing dependencies now? [y/N] " && line_to_remove
			read -r yn </dev/tty
			if [ -z "$yn" ]; then
				yn="n"
			fi
			case "$yn" in
			[Yy]*) ;;
			[Nn]*) exit 0 ;;
			*) printf "%s\n" "      Please answer 'yes' or 'no'." && line_to_remove ;;
			esac
		fi
		# begin installation
		if [ "$OSTYPE" = "Linux" ] && grep "Ubuntu" /etc/os-release >/dev/null 2>&1; then
			log "🐧 Installing Ubuntu dependencies."
			sudo -v
			[ $? -ne 0 ] && log "💥 Your current user account has no administrative privileges.\nRequired dependencies unable to install\nPlease contact your system administrator." && exit 1
			sudo apt update
			sudo apt -y install build-essential procps curl file git gawk python3-setuptools python3-pip bat jq
			# avoid batcat
			mkdir -p ~/.local/bin
			if [ ! -s ~/.local/bin/bat ]; then
				ln -s /usr/bin/batcat ~/.local/bin/bat
				printf "%s\n" 'export PATH="$HOME/.local/bin/:$PATH"' >>"$shell_cfg"
			fi
			if ! command -v fzf; then
				# require an fzf version with label and label coloring support
				git clone --depth 1 https://github.com/junegunn/fzf.git ~/.fzf
				~/.fzf/install --all --update-rc
			else
				fzf_version="$(fzf --version)"
				if [ -z "$(printf "%s" "$fzf_version" | awk -F. '$1 >= 0 && $2 >= 35 {print $0}')" ]; then
					printf "\n\n%s\n\n" "Please manually update your fzf installation to version >= 0.35.x."
				fi
			fi
			[ ! -d lib/webtorrent-cli/bin/cmd.js ] && ./utils/install-webtorrent.sh
			if ! command -v pastel; then
				# https://github.com/sharkdp/pastel
				wget "https://github.com/sharkdp/pastel/releases/download/v0.9.0/pastel_0.9.0_amd64.deb"
				sudo dpkg -i pastel_0.9.0_amd64.deb
				rm pastel_0.9.0_amd64.deb
			fi
			if ! command -v animdl; then
				# https://github.com/justfoolingaround/animdl
				pip3 install animdl
			fi
			if ! command -v trackma; then
				sudo apt install lsof
				# https://github.com/z411/trackma
				pip3 install pillow \
					PyQt5 \
					pydbus \
					setuptools \
					wheel \
					pyinotify \
					nyaapy \
					anitopy \
					'requests>=2.20.0' \
					beautifulsoup4==4.6.0 \
					lxml \
					dbus-python
				pip3 install Trackma
			fi
		elif [ "$OSTYPE" = "Darwin" ]; then
			log "🍏 Installing macOS dependencies."
			if ! pkgutil --pkg-info=com.apple.pkg.CLTools_Executables | grep version >/dev/null 2>&1; then
				# xcode command line tools is a dependency of nvm and homebrew
				xcode-select --install
			fi
			if ! command -v brew; then
				# Install homebrew unattended
				NONINTERACTIVE=1 /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
			fi
			if ! grep 'export PATH="/opt/homebrew/bin/:$PATH"' "$shell_cfg" >/dev/null 2>&1; then
				printf "%s\n" 'export PATH="/opt/homebrew/bin/:$PATH"' >>"$shell_cfg"
			fi
			# https://github.com/sharkdp/pastel
			brew install curl jq gawk grep axel openssl@1.1 ffmpeg git bat
			brew install patchelf cmake automake fzf pastel
			if ! command -v animdl; then
				# https://github.com/justfoolingaround/animdl
				pip3 install animdl
			fi
			[ ! -d lib/webtorrent-cli/bin/cmd.js ] && ./utils/install-webtorrent.sh
			if ! command -v trackma; then
				# https://github.com/z411/trackma
				# dbus-python module is broken on macOS and cannot be built. This means no trackma mpris support.
				# pip3 install dbus-python
				# inotify is not available on macosx-XX-arm64
				# pip3 install pyinotify
				# Installs qt5 for trackma gui
				pip3 install pillow \
					PyQt5 \
					pydbus \
					setuptools \
					setuptools_scm \
					scikit-build \
					nyaapy \
					anitopy \
					'requests>=2.20.0' \
					beautifulsoup4==4.6.0 \
					lxml \
					wheel \
					Trackma
			fi
		fi
		DEP_ERR=0
		echo
		log "$install_dep_msg"
		exit
	fi
	if ! grep "export LC_CTYPE=en_US.UTF-8" "$shell_cfg" >/dev/null 2>&1; then
		printf "%s\n" 'export LC_CTYPE=en_US.UTF-8' >"$shell_cfg"
	fi
	if ! grep "export LC_ALL=en_US.UTF-8" "$shell_cfg" >/dev/null 2>&1; then
		printf "%s\n" 'export LC_ALL=en_US.UTF-8' >"$shell_cfg"
	fi
}

# sanitizes a string to be used in an extended regular expression
sanitize_ext_regex_function_code='sanitize_ext_regex() {
	printf "%s" "$1" |
		sed "s,$(printf "\033")\\[[0-9;]*[a-zA-Z],," |
		sed "s,$(printf "\033")\\[[0-9;]*[a-zA-Z],,g" |
		sed "s/[]\/\$*.^+()[-]/\\\&/g" |
		sed "s/ $//"
}'
eval "$sanitize_ext_regex_function_code"

sanitize_bash() {
	printf "%s" "$1" | LC_ALL=C sed -e 's/[^a-zA-Z0-9,._+@%/-]/\\&/g; 1{$s/^$/""/}; 1!s/^/"/; $!s/$/"/'
}

LINES_TO_REMOVE=0
# Message color palette for pastel
MSG_INFO_COLOR="lightyellow"
MSG_WARN_COLOR="orange"
MSG_ERR_COLOR="red"
MSG_HELP_COLOR="deepskyblue"
TITLE_COLOR="yellow"
SUBTITLE_COLOR="lightblue"

DATE_MONTH=$(date "+%m")
DATE_DAY=$(date "+%d")
OVERWRITE='\r\033[1A\033[0K'
CONFIG_PATH="$HOME/.config/anime-manager"
TMP_PATH="/tmp/anime-manager"
CHECKPOINTFILE="$HOME/.config/anime-manager/checkpoint"
PLAYER_SOURCE="torrenting"

ANIMDL_PLAYTHROUGH=0
ANIMDL_SEARCH_INDEX=1
NYAA_SEARCH_BIN="lib/nyaa_search.py"
NYAA_SEARCH_LOGFILE="$CONFIG_PATH/nyaa_search.log"
NYAA_FID_LOGFILE="$CONFIG_PATH/get_torrent_fid.log"
GET_TORRENT_FID_BIN="lib/get_torrent_fid.py"
WEBTORRENT_CLI="lib/webtorrent-cli/bin/cmd.js"
TORRENT_DOWNLOAD_DIR="${TMP_PATH}/webtorrent"

# logfiles
WEBTORRENT_LOGFILE="$CONFIG_PATH/webtorrent.log"
TRACKMA_LOGFILE="$CONFIG_PATH/trackma.log"
# CURRENTLY_PLAYING_LOGFILE="$CONFIG_PATH/now_playing.log"
ANIMDL_LOGFILE="$CONFIG_PATH/animdl.log"
# webtorrent globals
# torrent status codes
TORRENT_TMOUT=60
TORRENT_STATUS_OKPLAYING=0
TORRENT_STATUS_STALLED=1
TORRENT_STATUS_ERRORED=2
FILE_LIST=""
webtorrentpid=""
# player status codes
PLAY_STATUS_WAITING=0
PLAY_STATUS_OKPLAYING=1
PLAY_STATUS_ERRORED=2
PLAY_STATUS_EXITED=3
# PLAY_STATUS_OFFLINE=4
PLAY_STATUS=$PLAY_STATUS_WAITING
# nyaapy scraper status codes
NYAA_SEARCH_ERROR_CODE="-2"
NYAAPY_FILE_SEL_CODE="-1"

mkdir -p "$TMP_PATH"
mkdir -p "$TORRENT_DOWNLOAD_DIR"
mkdir -p "$CONFIG_PATH"
[ ! -f "$TRACKMA_LOGFILE" ] && touch "$TRACKMA_LOGFILE"

# initial checks
if [ ! -f "$CHECKPOINTFILE" ]; then
	install_dependencies
	checkTrackmaConfig
	printf "%s" "
READ FIRST --

	This program comes with ABSOLUTELY NO WARRANTY.
Anime Manager is a file sharing program. When you run a torrent (Anime Manager can play content by the means of running a torrent), its data will be made available to others by means of upload. Any content you share is your sole responsibility. No further notices will be issued.

-------------

Do you agree with this? [yes/no]: "
	while true; do
		read -r ANSWER
		case "$ANSWER" in
		"yes") break ;;
		"no") exit ;;
		*) printf "%s" "Please answer 'yes' or 'no': " && line_to_remove ;;
		esac
	done
	printf "%s\n" "$ANSWER" >"$CHECKPOINTFILE"
	tput clear
fi

# Create a safe temporary filename in a posix-compliant way
posix_mktemp_file() {
	{
		posix_mktemp_file_file=$(
			(mktemp -u "$TMP_PATH/anmaXXXXXXXX") 2>/dev/null
		)
	} || {
		posix_mktemp_file_file=$TMP_PATH/anma$$-$(awk 'BEGIN { srand(); print int(rand()*32768) }' /dev/null)
	} || exit $?
	printf "%s" "$posix_mktemp_file_file"
}

# get the account in use in Trackma
get_account_name() {
	printf "%s" "$(printf "%s" "exit" | trackma | sed -En "s/.*using account (.*)\(.*/\1/p")" | sed "s/ $//g"
}

# gets the remote tracking service (mal, anilist, etc) used in trackma
# this is necessary because the lists differ between services
get_remote_tracker() {
	printf "%s" "$(printf "%s" "$(printf "%s" "exit" | trackma | sed -En "s/.*using account (.*)\((.*)\).*/\2/p")")"
}

get_trackma_tracker_name() {
	get_trackma_tracker_name_name="$1"
	case $get_trackma_tracker_name_name in
	"mal")
		printf "MAL"
		;;
	"anilist")
		printf "Anilist"
		;;
	esac
}

# returns a status code that trackma understands
get_trackma_status_code_function_code='get_trackma_status_code() {
	get_trackma_status_code_status_status="$1"
	case $get_trackma_status_code_status_status in
	"Watching" | "watching")
		printf "watching"
		;;
	"Plan to Watch" | "plantowatch")
		printf "plantowatch"
		;;
	"Rewatching" | "rewatching")
		printf "rewatching"
		;;
	"Dropped" | "dropped")
		printf "dropped"
		;;
	"Paused" | "paused")
		printf "paused"
		;;
	"Completed" | "completed")
		printf "completed"
		;;
	"On Hold" | "onhold")
		printf "onhold"
		;;
	"$to_mainmenu")
		printf "%s" "$to_mainmenu"
		;;
	"$SWITCH_STATUS_MSG_MENU_ENTRY")
		printf "%s" "$SWITCH_STATUS_MSG_MENU_ENTRY"
		;;
	esac
}'
eval "$get_trackma_status_code_function_code"

# Update Trackma and watch history
# ARGS in this order:
# name of the series as trackma sees it
# episode number
set_ep_as_watched() {
	ANIME_TITLE_TRACKMA="$1"
	ANIME_EP="$2"
	trackma update "$ANIME_TITLE_TRACKMA" "$ANIME_EP" >"$TRACKMA_LOGFILE" 2>&1
	# we check if theres actually something to save
	# save other shows and replace the new updated registry for this show
	PRESERVED_HISTORY=$(gawk "!/^$(sanitize_ext_regex "$ANIME_TITLE_TRACKMA").*$/" "$WATCH_HISTORY_FILE")
	# if there is content that is not replaced add a newline for the show to insert, and only in that case.
	[ -n "$PRESERVED_HISTORY" ] && printf "%b" "$PRESERVED_HISTORY\n" >"$WATCH_HISTORY_FILE" || printf "%b" "$PRESERVED_HISTORY" >"$WATCH_HISTORY_FILE"
	printf "%s\n" "$ANIME_TITLE_TRACKMA////$ANIME_EP" >>"$WATCH_HISTORY_FILE"
}

# set episode status on the anime tracker service
# ARGS in order
# TRACKMA_SHOW_INDEX the index of the show obtained from user input
set_show_status() {
	set_show_status_STATUS="$2"
	NEW_STATUS="$(get_trackma_status_code "$set_show_status_STATUS")"
	PROMPT="$update_status"
}

filter_trackma_list() {
	printf "%b" "$1" | sed -En "s/$TRACKMA_LIST_REGEX/\1/p"
}

# get all the shows the user has set as watching in their lists
# for presenting in unified way
get_watching_shows() {
	get_watching_shows_REWATCHING=""
	get_watching_shows_WATCHING="$(printf "filter %s\nls\n" "watching" | trackma)"
	get_watching_shows_WATCHING="$(filter_trackma_list "$get_watching_shows_WATCHING")"
	if [ "$TRACKER_SERVICE" = "anilist" ]; then
		# exception for anilist
		get_watching_shows_REWATCHING="$(printf "filter %s\nls\n" "rewatching" | trackma)"
		get_watching_shows_REWATCHING="$(filter_trackma_list "$get_watching_shows_REWATCHING")"
	fi
	printf "%b\n%b" "$get_watching_shows_WATCHING" "$get_watching_shows_REWATCHING"
}

# accepts a trackma entry and returns the cleaned show title
# to use with raw trackma entries only
get_show_title_function_code='get_show_title() {
	printf "%s" "$1" | sed -En "s/$TRACKMA_ENTRY_REGEX/\2/p" | sed "s/\.*$//g" | sed "s/ *$//g" | sed "s,$(printf "'"\033"'")\\[0-9;]*[a-zA-Z],," | sed "s,$(printf "'"\033"'")\\[0-9;]*[a-zA-Z],,g" | sed "s/📣 //g" | sed "s/\[.*\]//g" | sed "s/ $//g"
}'
eval "$get_show_title_function_code"

# gets the status of a show
get_show_status() {
	if [ -n "$STATUS" ]; then
		STATUS="$(get_trackma_status_code "$STATUS")"
		printf "%s" "$STATUS"
	else
		RES_TITLE=""
		ANIME_TITLE="$1"
		while read -r trackma_code; do
			# trackma search uses regex so we need to sanitize it
			FULL_ENTRY=$(printf "filter %s\nsearch '%s'\n" "$(get_trackma_status_code "$trackma_code")" "$(sanitize_ext_regex "$ANIME_TITLE")" | trackma)
			RES="$(filter_trackma_list "$FULL_ENTRY" | head -n1)"
			[ -n "$RES" ] && RES_TITLE="$(get_show_title "$RES")"
			if [ -n "$RES_TITLE" ] && [ "$RES_TITLE" = "$ANIME_TITLE" ]; then
				STATUS="$trackma_code"
				break
			fi
		done <<EOF
$TRACKMA_STATUS_MENU_ENTRIES
EOF
		if [ -z "$STATUS" ]; then
			printf "%b\n" "💥 ERROR getting show status.\nPlease report this error message to the developer."
			exit 1
		fi
		printf "%s" "$STATUS"
	fi
}

# checks internet connection
connectivity_check() {
	printf "%b" "GET https://ubuntu.com HTTP/1.0\n\n" | nc ubuntu.com 443 >/dev/null 2>&1
	if [ $? -eq 0 ]; then
		true
	else
		false
	fi
}

# get shows info from Trackma
get_show_info_function_code='get_show_info() {
	if [ -n "$(printf "%s" "$1" | sed -En "/[[:digit:]]+[[:space:]]+\/[[:space:]]+[[:digit:]]+[[:space:]]+[[:digit:]]/p")" ]; then
		# raw entry
		get_show_info_SHOW_TITLE="$(get_show_title "$1")"
	else
		get_show_info_SHOW_TITLE="$1"
	fi
	get_show_info_STATUS="$(get_trackma_status_code "$2")"
	if [ "$1" = "$to_mainmenu" ]; then
		printf "%s\n" "Go back to the main menu"
	elif [ "$1" = "$SWITCH_STATUS_MSG_MENU_ENTRY" ]; then
		printf "%s\n" "Switch to another list"
	else
		get_show_info_info="$(printf "filter %s\ninfo \"%s\"" "$get_show_info_STATUS" "$get_show_info_SHOW_TITLE" | trackma | sed -n "/https/,/Status/p" | sed -e "s/<[^>]*>//g")"
		printf "\n%b" "$get_show_info_info"
	fi
}'
eval "$get_show_info_function_code"

# get the last episode from a show in the re/watching list
# used when the user plays a show from the watch or watch history
# ARGS in order
# ANIME_TITLE the title of the show as trackma sees it
get_last_show_ep() {
	# removes altname and trailing spaces, trackma cant find shows if the altname is in the query
	get_last_show_ep_ANIME_TITLE="$(printf "%s" "$1" | sed "s/\[.*\]//g" | sed "s/ $//g")"
	get_last_show_ep_FULL_ENTRY=$(get_show_entry "$get_last_show_ep_ANIME_TITLE")
	[ -z "$get_last_show_ep_FULL_ENTRY" ] && exit 1
	LAST_EP="$(printf "%b" "$get_last_show_ep_FULL_ENTRY" | sed -En "s/$TRACKMA_ENTRY_REGEX/\5/p")"
	printf "%s" "$LAST_EP"
}

# get anime series across lists or from a particular list
# this is used to play any episode from the watch history
# the status code argument should be parseable by trackma
get_show_entry() {
	play_episode_ANIME_TITLE="$1"
	STATUS="$(get_show_status "$play_episode_ANIME_TITLE")"
	# trackma search uses regex so we need to sanitize it
	get_show_entry_FULL_ENTRY=$(printf "filter %s\nsearch '%s'\n" "$(get_trackma_status_code "$STATUS")" "$(sanitize_ext_regex "$play_episode_ANIME_TITLE")" | trackma)
	get_show_entry_LIST="$(printf "%b" "$get_show_entry_FULL_ENTRY" | sed -En "s/$TRACKMA_LIST_REGEX/\1/p" | head -n1)"
	# we assume we should find a result
	[ -z "$get_show_entry_LIST" ] &&
		printf "%b\n" "💥 ERROR getting show entry.\nPlease report this error message to the developer." && exit 1
	printf "%b" "$get_show_entry_LIST"
}

torrentIsPlaying() {
	process_name="$(ps -p "$webtorrentpid" -o comm=)"
	if [ "$process_name" = "WebTorrent" ]; then
		true
	else
		false
	fi
}

# attempts to play a series episode
play_episode() {
	reset_logs
	while ! connectivity_check; do
		echo && line_to_remove
		pastel paint $MSG_WARN_COLOR "      🌴🦕 NO INTERNET CONNECTION ・・・" && line_to_remove
		pastel paint $MSG_WARN_COLOR "      Please check your connection and press [Enter]" && line_to_remove
		read -r KEY # TODO: -n1
		[ "$KEY" = "" ] && clear_lines && continue
	done

	play_episode_ANIME_TITLE="$1"
	play_episode_ANIME_EPISODE="$2"
	PLAYER_SOURCE="$3"
	STATUS="$4"
	SHOW_TYPE="$5"
	SHOW_SYNONYMS="$6"

	if [ "$PLAYER_SOURCE" = "torrenting" ]; then
		if [ -z "$MAGNET_LINK" ]; then
			# get magnet link and play it with webtorrent-cli
			if [ -z "$NYAA_SEARCH_RES" ]; then
				echo && line_to_remove
				pastel paint $MSG_INFO_COLOR "      😺 Searching Nyaa. Please wait..." && line_to_remove
				NYAA_SEARCH_RES="$(python3 "$NYAA_SEARCH_BIN" --title "$play_episode_ANIME_TITLE" --episode "$play_episode_ANIME_EPISODE" --quality 1080 --show-type "$SHOW_TYPE")"
				if [ "$NYAA_SEARCH_RES" = "-1" ]; then
					echo && line_to_remove
					pastel paint $MSG_WARN_COLOR "      🚫 We found no results." && line_to_remove
					PLAY_STATUS=$PLAY_STATUS_ERRORED
					return
				elif [ "$NYAA_SEARCH_RES" = "-2" ]; then
					echo && line_to_remove
					pastel paint $MSG_WARN_COLOR "      🚫 We couldn't search nyaa.si" && line_to_remove
					pastel paint $MSG_WARN_COLOR "      Please contact development to work this out:" && line_to_remove
					pastel paint $MSG_WARN_COLOR "      https://github.com/anma-dev/Anime-Manager/issues" && line_to_remove
					PLAY_STATUS=$PLAY_STATUS_ERRORED
					return
				fi
			fi
			clear_lines
			CHOICE=$(printf "%b" "{\"name\": \"$to_mainmenu\"}\n$NYAA_SEARCH_RES" | jq '.name' | sed "s/\"//g" |
				$FZF -i --prompt "Choose a search result: " --border-label "╢ ♣  SEARCH RESULTS (nyaa.si): $(trim "$play_episode_ANIME_TITLE") ▶ $play_episode_ANIME_EPISODE ♣  ╟" --header "⇅ Navigation ─ [ESC] Exit ─ [Ctrl-L] Expand ─ [Enter] Stream (torrenting) ▸" --header-first --preview "printf \"\n%s\n\n%b\" {} '────────────\nColor code: \n🟢 Trusted\n🔴 Remake\n⚪️ No category\n\nMore info: https://nyaa.si/help'" --preview-window "50,hidden,wrap" --preview-label ' Expanded view ' --bind "ctrl-l:toggle-preview")
			[ "$CHOICE" = "$to_mainmenu" ] && PLAY_STATUS="$PLAY_STATUS_EXITED" && return
			CHOICE=$(printf "%s" "$CHOICE" | sed "s/🔴 //g" | sed "s/🟢 //g" | sed "s/⚪️ //g")
			FILTERED_JSON="$(printf "%s" "$NYAA_SEARCH_RES" | sed "s/\\\ud83d\\\udd34|\\\u26aa\\\ufe0f|\\\ud83d\\\udfe2//g" | sed -En "/$(sanitize_ext_regex "$CHOICE")/p")"
			MAGNET_LINK="$(printf "%s" "$FILTERED_JSON" | jq --raw-output ".magnet")"
		fi
		if [ -z "$FILE_LIST" ]; then
			echo && line_to_remove
			pastel paint $MSG_INFO_COLOR "      🗃️  Searching for matching file (60s timeout)..." && line_to_remove
			play_episode_TORRENT_INFO="$(python3 "$GET_TORRENT_FID_BIN" --title "$play_episode_ANIME_TITLE, $(printf "%s" "$SHOW_SYNONYMS")" --magnet-link "$MAGNET_LINK" --episode "$play_episode_ANIME_EPISODE" --show-type "$SHOW_TYPE")"
			EP_DATA="$(printf "%s" "$play_episode_TORRENT_INFO" | awk -F"////" '{print $1}')"
			FILE_LIST="$(printf "%s" "$play_episode_TORRENT_INFO" | awk -F"////" '{print $2}')"
			FILE_INDEX="$(printf "%s" "$play_episode_TORRENT_INFO" | awk -F"////" '{print $3}')"
			DEBUG_MATCH_INFO=$EP_DATA
		fi

		if [ "$FILE_INDEX" = "$NYAAPY_FILE_SEL_CODE" ]; then
			if [ "$FILE_LIST" = "None" ]; then
				pastel paint $MSG_WARN_COLOR "      🚫 No matching files, please select another source" && line_to_remove
				MAGNET_LINK=""
				FILE_LIST=""
				PLAY_STATUS=$PLAY_STATUS_ERRORED
				return
			fi
			FILE_INDEX=$(printf "%b" "$FILE_LIST\n◀ Now Playing" | sed "s/\"//g" |
				$FZF -i --prompt "Choose a file: " --border-label "╢ ♣  🗃️  FILE SELECTION: $(trim "$play_episode_ANIME_TITLE") ▶ $play_episode_ANIME_EPISODE ♣  ╟" --header "⇅ Navigation ─ [ESC] Exit ─ [Ctrl-L] Expand ─ [Enter] Stream (torrenting) ▸" --header-first --preview "printf \"\n%s\n\n%b\" {}" --preview-window "50,hidden,wrap" --preview-label ' Expanded view ' --bind "ctrl-l:toggle-preview" | cut -d " " -f1)
		fi

		[ "$FILE_INDEX" = "◀" ] && FILE_LIST="" && FILE_INDEX="" && return

		if [ "$FILE_INDEX" != "$NYAA_SEARCH_ERROR_CODE" ]; then
			# run completely detached from terminal for availability
			set +m
			(nohup node "$WEBTORRENT_CLI" download "$MAGNET_LINK" --select "$FILE_INDEX" --out "$TORRENT_DOWNLOAD_DIR" --"$MEDIA_PLAYER" >"$WEBTORRENT_LOGFILE" 2>&1 &) &
			webtorrentpid=$!
			set -m
			# printf "%s" "$EP_DATA" | jq '.name' >"$CURRENTLY_PLAYING_LOGFILE"
			# remove from job queue to avoid info messages if we have to end the process with kill
			echo && line_to_remove
			pastel paint $MSG_INFO_COLOR "      🚀 Torrent is playing soon (hold my beer...)" && line_to_remove
			play_episode_torrent_status=$(check_torrent_health $webtorrentpid)
			if [ "$play_episode_torrent_status" -eq $TORRENT_STATUS_ERRORED ]; then
				pastel paint $MSG_WARN_COLOR "      🚫 Unable to play torrent" && line_to_remove
				MAGNET_LINK=""
				PLAY_STATUS=$PLAY_STATUS_ERRORED
			else
				PLAY_STATUS=$PLAY_STATUS_OKPLAYING
			fi
		else
			pastel paint $MSG_WARN_COLOR "      🚫 Unable to get file index" && line_to_remove
			MAGNET_LINK=""
			FILE_LIST=""
			PLAY_STATUS=$PLAY_STATUS_ERRORED
		fi
	elif [ "$PLAYER_SOURCE" = "streaming" ]; then
		stream_providers=$(array "allanime" "zoro" "animepahe" "animeout" "gogoanime" "tenshi")
		echo && line_to_remove
		pastel paint $MSG_INFO_COLOR "      💡 Streaming (animdl)" && line_to_remove
		while IFS= read -r provider; do
			d_provider=$(printf '%s\n' "$provider" | array_element_decode)
			if [ "$ANIMDL_PLAYTHROUGH" -eq 0 ]; then
				play_episode_stream_fifo_write="$(posix_mktemp_file)"
				mkfifo -m 600 "$play_episode_stream_fifo_write"
				# TODO: can't stream with iina
				set +m
				nohup animdl stream "$d_provider:$play_episode_ANIME_TITLE" --range "$ANIME_EP" --player "mpv" --log-file "$ANIMDL_LOGFILE" <"$play_episode_stream_fifo_write" >"$ANIMDL_LOGFILE" 2>&1 &
				animdl_pid=$!
				set -m
				exec 3>"$play_episode_stream_fifo_write"
				pastel paint $MSG_INFO_COLOR "      🔎 Please wait, searching the stream provider ($d_provider)..." && line_to_remove
				stream_health=10
				while [ $stream_health -gt 0 ]; do
					# check for search result prompt
					if ! grep "Select the search result" "$ANIMDL_LOGFILE" >/dev/null 2>&1; then
						if [ -z "$(sed -En "s/AV:|libmpv|A-V/&/p" "$ANIMDL_LOGFILE")" ]; then
							stream_health=$((stream_health - 1))
						else
							# stream started automatically
							PLAY_STATUS=$PLAY_STATUS_OKPLAYING
							pastel paint $MSG_INFO_COLOR "      🚀 The stream is starting (hold my beer...)" && line_to_remove
							return
						fi
					else
						break
					fi
					sleep 1
				done
				if [ $stream_health -eq 0 ]; then
					pastel paint $MSG_WARN_COLOR "      🚫 No results found ($d_provider), next..." && line_to_remove
					PLAY_STATUS=$PLAY_STATUS_ERRORED
					# next provider
					echo "" >"$ANIMDL_LOGFILE"
					continue
				fi
				clear_lines
				results=$(sed -En '/^[[:space:]]+[0-9]+\./p' "$ANIMDL_LOGFILE")
				ANIMDL_SEARCH_INDEX="$(printf "%b" "$to_mainmenu\n$results" | sed "s/^[[:space:]]*//" | $FZF --prompt="Select a search result: " --border-label "╢ ♣  SEARCH RESULTS ($d_provider): $(trim "$play_episode_ANIME_TITLE") ▶ Episode $ANIME_EP ♣  ╟" --header "⇅ Navigation ─ [ESC] Exit ─ [Enter] Play" --header-first | cut -d '.' -f1)"
				[ -z "$ANIMDL_SEARCH_INDEX" ] && exit 1
				[ "$ANIMDL_SEARCH_INDEX" = "$to_mainmenu" ] && PLAY_STATUS=$PLAY_STATUS_EXITED && ANIMDL_SEARCH_INDEX="" && return
				printf "%b" "$ANIMDL_SEARCH_INDEX\n" >&3
				3>&-:
				sleep 2 # wait for the stream to start
				stream_health=15
				pastel paint $MSG_INFO_COLOR "      Trying to stream with $d_provider" && line_to_remove
				while [ $stream_health -gt 0 ]; do
					if [ -z "$(sed -En "s/AV:|libmpv|A-V/&/p" "$ANIMDL_LOGFILE")" ]; then
						stream_health=$((stream_health - 1))
					else
						break
					fi
					sleep 1
				done
				if [ $stream_health -eq 0 ]; then
					echo && line_to_remove
					pastel paint $MSG_WARN_COLOR "      🚫 Unable to stream with $d_provider, next..." && line_to_remove
					PLAY_STATUS=$PLAY_STATUS_ERRORED
					# next provider
					echo "" >"$ANIMDL_LOGFILE"
					continue
				else
					rm "$play_episode_stream_fifo_write"
					unset stream_tmpfile
					unset stream_fifo_write
					pastel paint $MSG_INFO_COLOR "      🚀 The stream is starting (hold my beer...)" && line_to_remove
					PLAY_STATUS=$PLAY_STATUS_OKPLAYING
					return
				fi
			else
				[ -z "$ANIMDL_SEARCH_INDEX" ] && exit 1
				# TODO: can't stream with iina
				set +m
				nohup animdl stream "$d_provider:$play_episode_ANIME_TITLE" --index "$ANIMDL_SEARCH_INDEX" --range "$ANIME_EP" --player "mpv" >"$ANIMDL_LOGFILE" 2>&1 &
				set -m
				sleep 2 # wait for the stream to start before presenting the streaming options
				stream_health=10
				while [ $stream_health -gt 0 ]; do
					if [ -z "$(sed -En "s/AV:|libmpv|A-V/&/p" "$ANIMDL_LOGFILE")" ]; then
						stream_health=$((stream_health - 1))
					else
						break
					fi
					sleep 1
				done
				if [ $stream_health -eq 0 ]; then
					echo && line_to_remove
					pastel paint $MSG_WARN_COLOR "      🚫 Unable to stream with $d_provider" && line_to_remove
					PLAY_STATUS=$PLAY_STATUS_ERRORED
					# next provider
					continue
				else
					PLAY_STATUS=$PLAY_STATUS_OKPLAYING
					return
				fi
			fi
		done <<EOF
$stream_providers
EOF
	elif [ "$PLAYER_SOURCE" = "self_magnet" ]; then
		echo && line_to_remove
		pastel paint $MSG_INFO_COLOR "      🧲 Paste your magnet link and press Enter (silent input): " && line_to_remove
		stty_orig=$(stty -g)
		stty -echo
		read -r MAGNET_LINK
		stty "$stty_orig"
		MAGNET_LINK="$(printf "%s" "$MAGNET_LINK" | sed "s/;//g" | tr -d '\012')" # newline esc seq in octal
		clear_lines
		PLAYER_SOURCE="torrenting"
		play_episode "$ANIME_TITLE_TRACKMA" "$ANIME_EP" "$PLAYER_SOURCE" "$STATUS" "$SHOW_TYPE" "$SHOW_SYNONYMS"
	fi
}

check_torrent_health() {
	# allow it to start first
	sleep 2
	check_torrent_health_waitingtime=0
	check_torrent_health_checkinterval=5
	check_torrent_health_torrent_status=$TORRENT_STATUS_STALLED
	check_torrent_health_webtorrentpid="$1"
	while [ $check_torrent_health_torrent_status = "$TORRENT_STATUS_STALLED" ] && [ $check_torrent_health_waitingtime -lt $TORRENT_TMOUT ]; do
		# if the torrent is not finding peers
		# before or after download start
		lastlog="$(tail -n20 "$WEBTORRENT_LOGFILE")"
		if [ -z "$(printf "%s" "$lastlog" | sed -n "/Streaming/p")" ] || [ -n "$(printf "%s" "$lastlog" | sed -n "/Peers: 0\/0/p")" ]; then
			check_torrent_health_waitingtime=$((check_torrent_health_waitingtime + check_torrent_health_checkinterval))
			sleep $check_torrent_health_checkinterval
		else
			break
		fi
	done
	if [ $check_torrent_health_waitingtime -eq $TORRENT_TMOUT ]; then
		# kill the process
		kill -9 "$check_torrent_health_webtorrentpid" >/dev/null 2>&1
		printf "%s" "$TORRENT_STATUS_ERRORED"
	else
		printf "%s" "$TORRENT_STATUS_OKPLAYING"
	fi
}

USERNAME="$(get_account_name)"
TRACKER_SERVICE="$(get_remote_tracker)"
LOGO_MONOCHROME="H4sIAEdnvWMAA+Pi4lIAg/DUnOT83FSFknwF0sGjOSugxjya1vFoWgMYdSBzWoCciWDWRLhwC7oyhccNDbhlsZiIXaYByURkNchObAEjqLaJYATiNEDUw4Ub4DIYTkSXxWEiFhk0TyOpaYA7sQFmRgMWTgOaMJoMxIlYZInkoNiAYheYU2agZ6BnyAUAdHKfkjoCAAA="
LOGO_DEFAULT_B64="H4sIAEFjvWMAA73WO24bMRAG4F5XcMMTBHzvLuYgKVIG7mKkCVKrcKFWTaocIOdyLpJ/tPIuZ4aSFoHkQpbxYTgkxeHj6UsaKVIs5fTxL7un/xEnJDxK8gD5bOTZyDcjX418FxIhL0aejTgjP4yIzPhPtfpQyQ8T/yiJpqLuJqaiHidh+EBJjxJvKupuYirqgWJq7CRvv/8Y221o10qY6h3l7ddBWDjZfqPZtu5W1DjYbFfs1ZjrRB03ZpNxuvZm0eNNnWypM7ZO3DDZfCdzm6L62aTpypvl735LlO4zd/J7O9Oz9eIOxtymKJWt1ot2MOY2Rels8aK9GnOdqMOtbKVThWc7GHObonS2TsVdNNeJOtwnW+7Ub+7U6hWzbXdC9L16PzE1mjs1mju7oGuBgm6bBoqyB0gyUSNlfT7hBVSMFaqmbaFB9RBp1L80bDItEwWzJIxB5fMUomkMTHp8seJX0BnjgLIxkUAzlRlF3zHjjDBxfOCabvjGMRgYZUZ8myOSUc06jEyq5zDh6WXm4vGqND2fUUSGihe7yXlC2Teqppi4TLHqmruI5kcLgdFpGntxoxk4vieNeGNFU1R+oqT21Ew6rlIKeuAX0ZSfT4xOk9lZ77gOHAWFB1uSZcroZzxYdIICJbk2acV9g9NIqXZtzYddibHItVrt9aoFmgoluQ9ggW3XSqTU7gG/ScaJcrOOOJU3SaUc2hHlcbFjawPleMHWtgPhWZWbZWbJlJOOCrOt2SqNvmOIE+u+2NoDTtNRR80m1jfnvhU21wpmL6ogp8WOtwyzH4TFxfateba110ADZiUq44LVQZs/m2sFM53aIzNNVAubM9LkYktUxMsbf7fZQNVTEbW0mLsaVRc7NlZGKqLicG++2761wrb2kM/SRsEwXlFdKfUt6rawQKWpONzM2G5F1DQMm6mIWzPx8nFLZQMVUV+4mFHWpalCljK3XKIitm5WLdnS3OtqWHoMcNAWuO3SAy5ulInKhncO5iCqC++DpMfLxsvTZIMU3SeOuoyFbWfPhvGKmsN7AT+KagvzHLf2kHBzcZ8/Wxk5v18En8qtPrXCRdPE4K5MMgYSOSYsgoeA58z/APGbmLr7FAAA"
LOGO_XMAS_B64="H4sIALYVt2MAA8XXPW4UQRAF4NynWC6A+r9nVGcgBgkngMiwkAAhk22wAQFCckLqu8EFOAKvZtbWdvWb8RpYO7DX+lRb1d1T3dM+v/SvX8ZBgoScpx93cXZ+LG6OQn8ifG4wVeBbhu8YvmH4nuGFxcAKBTLOCT8x7Aqxr+Ovx8T0UOgeCAPrz5Mga9rHRV9PhL+vv++sRxas+Iyh3UoTfjgGnfbtF4a2+oQvGNrdPeEri9q3Hxk+YdhVT9NCfbtmbo9WnoH18wnQjwX488dXztt7MU3SFfQ81vPMq7xjbAsOdYq94mwzr0UvZLZTWcoc6Zj3vBDd5SZbbSm2jjTzGtvME/7aHheb+CgSL5foaqxHd7lZR0+4EEsyr/JRBQvv/sL3yjrb9ShsC5XACwaeeZVpElsw80bPvNH/gruCvKMz3ytr/G+ZE98re7ZJJj5jaEfBkVwt/guSkTrabetMk3QFeWws4smxGqsEzpElGSR1BWOWQh4RuLIUQQYWHWTsM0fxdC5wOhknPrDk8LgQn0j+UNGP3WhUy0I0W4CQcFwx1xdGn13fnuSkx93S9ysT8MlWRp2tjB9mt9n9iNsriQ8ON3qWf3I7Gl/w/xSJxnU1ZNLOi54ksBWevasKZR3m/ezdGsCHFe/y4LNfedxWoX20GyWyrbvoRaJneSbvqkIDi46z2zmpR/K8b7zJgz7FFTiana3qVEm0l5ht9rjo4yDRPL4bNLlxCNSZd4YxvrrMTUEvY5Y4tO8BoFfcHINBonnwjuMwSnJ3I142M7YjVS6S7H5Nw128NVwlhbZgFVxJkz0LlZMkexQqe8JFBjfz1jCi2265RROLd8CwyLZVUtrzxmDmsViNYscc78tYJttBKex5Y9CRWC8VE7evtGUuVbnJ7KRg2vbwV87Kh7Fx3GOb94AP54ffJUq2/07dzU3uKsVJbs+kWzSx5ZavWsYls+cseZBsu1Q5K28YmtgkOEuybd0lhgWSBOwltx2NCwn2crbdD8a2zdlm1oetKXrGxO3tAPcObJjcNrpinlPY2NSnCDhP4jwOy6FPEtBfXpNsDDqSAicwZmhbVxkztP0f8GKqXWZgJrE4lhMaxCySMqZiexrXJ30G3TjATqObghEvZY39bHDQcu4Q8VP0608Nai+2kbgWxC4SOA3KHyIuRU4L/QEhaktX3RcAAA=="
LOGO_HALLOWEEN_B64="H4sIADEPt2MAA8XXO24UQRAG4NynWC6A+j09qgtwAwJIAJHxChCPbCUcECE5IeUg3AYuwBH4a2ZtbVf/PV4DNoG91qfaqu6e6p724w/+6aNYJUjIeflxL88en4q7k9DfEj40mCbgc4YvGD5j+JrhS4uBFQpknAu+ZdgVYl/HX/8T012huyMMrD9vBVnT3i3++vblk3E/keAFHzB8wvDNSRiBHxl21SOrHln1SDayqyO0+2vB9wztRuaoffuK4T2GdpoL/vp28Z25PVp5BtbPt4B+LsAfXz9z3t+IaZKuoOexnmfe5HPGtmCdltgLzjbzVvQgs53KKHOkYz7wILrLTXbVKHaaaeYttpkX/Lk/LTbxUSReLtHV2I7ucrOOXnAQSzJv8kkFC+/+wvfKNtv1KGwLlcALBp55k2kSWzDzRs+80f+Au4K8ozPfK1v8d5kT3ysHtkkWPmNoR8GRXC3+CZKROtpt20yTdAV5bCziybEaJwmcI0tSJXUFY5ZCHhF4YimCVBYdZO4zR/F0LnA6GSc+sOTwOIhPJH+Y0I/daFTLIJotQEg4rpjrC6PPrm9PctLjbun7lQn4ZCujzlbG19Vtdj/j9krig8ONnuVf3I7GF/w/RaJxVw2ZtPPQkwS2wqt3VaGsw7xfvVsDeN3wLg8++5XHbRXaR7tZItu6Qy8SPcuzeFcVGlh0XN3OST2S533pTR70Ka7A0exsVadKor3EbLPHoc9Vonl8l2hy4xCYVj43jPFNY24KepmzxNq+B4BecXcKBonmwTuOdZbkrke8bFZsR6pcJNn9mup1vDc8SQptwUlwJU32LFROkuxRqOwJF6lu5b1hRLfdcoUmFu+AOmTbKikdeGcw81isRrFjjjdlLJPtoBQOvDPoSKyXCRO3r7Qxl0m5yeykYNr28FfOysexcT5gm/eIj+eH3yVKtv9OXc9N7kmKk9yeSVdoYssVX7SMS2bPWXKVbLtUOSvvGJrYJDhLsm3dEcMCSQL2ktuOxoUEeznb7gdj2+ZsM+vD1hQ9Y+L2doB7BzZMbhtdMa8pbGzqUwScJ3Edh+XQJwnoL69JdgYdSYETGDO0rauMGdr+D3gxTV1mYCaxOJYTGsQskjKmYnsa1yd9Bt04wE6jm4IRL2WNfWewajl3jPgp+vX7BrUX20hcC2IXCVwG5Y8RlyKnhc5+AyB6tXLeFwAA"
SWITCH_STATUS_MSG_MENU_ENTRY="🔄 SWITCH STATUS"

if [ "$OSTYPE" = "Darwin" ]; then
	MEDIA_PLAYER="iina"
else
	MEDIA_PLAYER="mpv"
fi

export BACK_MSG
export SWITCH_STATUS_MSG_MENU_ENTRY
export TRACKMA_ENTRY_REGEX
export TRACKMA_LOGFILE

# fzf colors
export FZF_DEFAULT_OPTS='--color=fg:#d0d0d0,bg:-1,hl:#ba9c41 --color=fg+:#ffbf00,bg+:#262626,hl+:#5fd7ff --color=info:#d0d0d0,prompt:#ffbf00,pointer:#af5fff --color=marker:#87ff00,spinner:#af5fff,header:#d7005f --color=label:#ffbf00'

# common fzf args
FZF="fzf -0 --ansi --cycle --ellipsis (...) --height 50% --border rounded --pointer 👉 --margin 5% --padding=1,0,0,0 --border-label-pos -1"
# regex for extracting trackma results
# gets the whole series list
TRACKMA_LIST_REGEX="^\|[[:space:]]+([0-9]+[[:space:]]+.*[0-9]+[[:space:]]+\/[[:space:]]+[0-9?]+[[:space:]]+[0-9]+).*\|$"
# gets the multiple parts of an entry, by matching groups
#	1- list index
#	2- series title
#	3- unused
#	4- last watched ep
#	5- end episode
#	6- series score
# Caveat: removing possesive quantifier makes the \2 match to end
# with a residual dot, we will have to remove it with sed.
# We also have no way of making a distinction between series that
# actually end with a dot from a residual dot.
TRACKMA_ENTRY_REGEX="^([[:digit:]]+)[[:space:]]+(([^.]*|.*))\.*[[:space:]]+([[:digit:]]+)[[:space:]]\/[[:space:]]([[:digit:]]+|\?)[[:space:]]+([[:digit:]]+)$"

# print the logos
tput clear
[ "$monochrome_logo" -eq 1 ] && LOGO_B64=$LOGO_MONOCHROME || LOGO_B64=$LOGO_DEFAULT_B64
# special dates
[ "$DATE_MONTH" -eq 10 ] && [ "$DATE_DAY" -eq 31 ] && LOGO_B64=$LOGO_HALLOWEEN_B64
[ "$DATE_MONTH" -eq 12 ] && [ "$DATE_DAY" -eq 24 ] || [ "$DATE_DAY" -eq 25 ] && LOGO_B64=$LOGO_XMAS_B64
# [ $DATE_MONTH -eq 12 ] && [ $DATE_DAY -eq 31 ] && LOGO_B64=$LOGO_NEWYEAR_B64

if [ $debug -eq 0 ]; then
	if [ $small_logo = 0 ]; then
		printf "%b\n" "$(
			base64 -d <<EOF | gunzip
$LOGO_B64
EOF
		)"
	else
		printf "%s\n" "      ♣️  ── ANIME MANGER ── ♣️"
	fi
fi

pastel paint $TITLE_COLOR "      🍿 Play and Track Anime Series from Your Terminal"
pastel paint $MSG_HELP_COLOR "         Use arrow keys/mouse scroll to navigate. Type to filter results" && echo
pastel paint $SUBTITLE_COLOR "      👤 Account ─ ${USERNAME} │"
# mainmenu entries
watch_history="👁️  Watch History"
watch="📺 Watch"
watch_random="🔀 Watch Random"
add_show="🧩 Add Series"
list="📙 Lists"
update_status="🔄 Update Series Status"
score_show="👍 Score Series"
to_submenu="🐇 SUBMENU ▸"
# submenu entries
delete_show="Delete Series 🗑️"
watch_rand_airing="Watch Random Series (Currently Airing 📣)"
list_airing="List Series (Currently Airing 📣)"
update_episodes="Update Series Episodes 🔄"
set_altname="Set Alternative Name 📝"
pull="Pull Lists from Remote ↓"
push="Push Local Lists to Remote ↑"
list_by_score="List Series (Sort by Rating 🌟)"
to_mainmenu="◂ MAINMENU"

MAIN_MENU_HELPTEXT="
🐇  Follow the white rabbit for more menu options
👍  Rate a series or change a series score. It syncs immediately with the tracking service
🔄  Update the status of a series. It syncs immediately with the tracking service
📙  Browse all your lists. It can also play series
🧩  Add a new series to your watching list
🔀  Select one random series from your currently watching lists (watching, rewatching) and open it for streaming
📺  Opens a list with all your currently watching series (watching, rewatching) and lets you pick one for streaming
👁️  Your watching history with series titles and episode count
"

SUB_MENU_HELPTEXT="
🌟  Display your lists in descending order by score
↑  Upload your local progress to your tracking service.
↓  Download your remote progress and update your local lists.
📝  Set the alternative name for a series
🔄  Update your progress on a series
📣  Display your lists by showing only those shows currently airing
📣  Start watching a random series episodes that is also currently airing
🗑️  Delete a series from your lists. You will lose all your progress on that series
"
MENU_HELPTEXT=$MAIN_MENU_HELPTEXT
WATCH_HISTORY_FILE="${CONFIG_PATH}/$(printf "%s" "$USERNAME" | sed -E 's/[^a-zA-Z0-9]//g')-watch-history"
[ ! -f "$WATCH_HISTORY_FILE" ] && touch "$WATCH_HISTORY_FILE"

# prepare the menus
PROMPT=""
MAINMENU_ENTRIES="$watch_history\n$watch\n$watch_random\n$add_show\n$list\n$update_status\n$score_show\n$to_submenu"
SUBMENU_ENTRIES="$delete_show\n$watch_rand_airing\n$list_airing\n$update_episodes\n$set_altname\n$pull\n$push\n$list_by_score\n$to_mainmenu"
MAINMENU_TITLE="MAIN MENU"
SUBMENU_TITLE="SUB 🐰 MENU"
MENU_ENTRIES=$MAINMENU_ENTRIES
MENU_TITLE=$MAINMENU_TITLE
if [ "$TRACKER_SERVICE" = "anilist" ]; then
	# exception for anilist
	TRACKMA_STATUS_MENU_ENTRIES="$(printf "%b" "Watching\nCompleted\nRewatching\nPaused\nDropped\nPlan to Watch" | sort -r)"
else
	TRACKMA_STATUS_MENU_ENTRIES="$(printf "%b" "Watching\nCompleted\nOn Hold\nDropped\nPlan to Watch" | sort -r)"
fi

# main loop
while true; do
	[ -z "$PROMPT" ] &&
		clear_modifiers &&
		PROMPT=$(printf "%b" "$MENU_ENTRIES" | $FZF -i --prompt="Choose an action: " --border-label "╢ ♣  $MENU_TITLE ♣  ╟" --header "⇅ Navigation ─ [ESC] Exit ─ [Ctrl-L] Help ─ [Enter] Select" --header-first --preview "printf \"%s\n\" \"$MENU_HELPTEXT\"" --bind "ctrl-l:toggle-preview" --preview-window "50,hidden,wrap" --preview-label "Help")
	case $PROMPT in
	"$to_mainmenu")
		MENU_ENTRIES=$MAINMENU_ENTRIES
		MENU_TITLE=$MAINMENU_TITLE
		MENU_HELPTEXT=$MAIN_MENU_HELPTEXT
		clear_modifiers
		;;
	"$to_submenu")
		MENU_ENTRIES=$SUBMENU_ENTRIES
		MENU_TITLE=$SUBMENU_TITLE
		MENU_HELPTEXT=$SUB_MENU_HELPTEXT
		clear_modifiers
		;;
	"$watch_history")
		clear_modifiers
		if [ ! -s "$WATCH_HISTORY_FILE" ]; then
			SEL=$(printf "Your watch history is empty\n%s" "$to_mainmenu" | $FZF -i --border-label "╢ ♣  YOUR WATCH HISTORY ♣  ╟" --header "⇅ Navigation ─ [ESC] Exit" --header-first)
		else
			HIST=$(column -t -s "////" "$WATCH_HISTORY_FILE")
			HIST="$to_mainmenu\n$HIST"
			SEL=$(printf "%b" "$HIST" | $FZF -i --prompt="Select an anime: " --border-label "╢ ♣  WATCH HISTORY ♣  ╟" --header "[Enter] Play ▸ new episode" --header "⇅ Navigation ─ [ESC] Exit ─ [Enter] Play ▸" --header-first --tac --no-sort)
			[ "$SEL" = "$to_mainmenu" ] && PROMPT=$to_mainmenu && continue
			ANIME_TITLE_TRACKMA=$(printf "%s" "$SEL" | sed -En "s/^(.*)[[:space:]]+([[:digit:]]+)$/\1/p" | sed "s/[[:space:]]*$//")
			LAST_SHOW_EP="$(get_last_show_ep "$ANIME_TITLE_TRACKMA")"
			[ -z "$LAST_SHOW_EP" ] && printf "couldnt get last series episode" && exit 1
			LAST_WATCHED_EP=$(printf "%s" "$SEL" | sed -En "s/^(.*)[[:space:]]+([[:digit:]]+)$/\2/p" | sed "s/[[:space:]]*$//")
			# only increment if it's not the last episode of the show
			# if we don't know the last aired apisode just attempt playing the next episode
			[ "$LAST_SHOW_EP" = "?" ] || [ "$LAST_WATCHED_EP" -lt "$LAST_SHOW_EP" ] && ANIME_EP=$((LAST_WATCHED_EP + 1)) || ANIME_EP="1"
			STATUS="$(get_show_status "$(printf "%s" "$ANIME_TITLE_TRACKMA" | sed "s/\[.*\]//g" | sed "s/ $//g")")"
			PROMPT="$watch"
		fi
		;;
	"$watch_random")
		RANDOM_ANIME=1
		PROMPT=$watch
		;;
	"$watch_rand_airing")
		RANDOM_AIRING=1
		PROMPT=$watch
		;;
	"$watch")
		# This section plays shows currently being watched by default or one specified show
		if [ -z "$ANIME_TITLE_TRACKMA" ] && [ -z "$ANIME_EP" ]; then
			FULL_INFO=$(get_watching_shows)

			if [ ! "$FULL_INFO" ]; then
				FULL_INFO="Your watching list is empty"
				CHOICE=$(printf "%s\n%s" "$FULL_INFO" "$to_mainmenu" |
					$FZF -i --prompt "Choose an anime to watch: " --border-label "╢ ♣  YOUR $(
						if [ "$TRACKER_SERVICE" = "anilist" ]; then
							printf "%s" "(RE)WATCHING LISTS"
						else
							printf "%s" "WATCHING LIST"
						fi
					) ♣  ╟" --header "⇅ Navigation ─ [ESC] Exit ─ [Enter] Play ▸" --header-first)
				clear_modifiers
				continue
			fi

			# remove character sequences and add an emoji next to shows currently airing
			FULL_INFO=$(printf '%s\n' "$FULL_INFO" | sed "s,$(printf '\033')\\[[0-9;]*[a-zA-Z],📣 ," | sed "s,$(printf '\033')\\[[0-9;]*[a-zA-Z],,g" | sed -E "/📣/ s/(.*)\.{3}(.*)/\1\2/")

			if [ "$RANDOM_ANIME" -eq 1 ]; then
				CHOICE=$(printf "%s" "$FULL_INFO" | shuf -n 1)
			elif [ "$RANDOM_AIRING" -eq 1 ]; then
				# format and filter airing shows, select one randomly
				CHOICE=$(printf "%s" "$FULL_INFO" | sed "s,$(printf '\033')\\[[0-9;]*[a-zA-Z],📣 ," | sed -n "/📣/p" | shuf -n 1)
			else
				FULL_INFO="$(printf "%s" "$FULL_INFO" | sort -r --version-sort)"
				CHOICE=$(printf "%s\n%s" "$to_mainmenu" "$FULL_INFO" |
					$FZF -i --prompt "Choose an anime to watch: " --border-label "╢ ♣  YOUR $(
						if [ "$TRACKER_SERVICE" = "anilist" ]; then
							printf "%s" "(RE)WATCHING LISTS"
						else
							printf "%s" "WATCHING LIST"
						fi
					) ♣  ╟" --header "⇅ Navigation ─ [ESC] Exit ─ [Enter] Play ▸" --header-first)
			fi

			[ "$CHOICE" = "$to_mainmenu" ] && PROMPT=$to_mainmenu && continue

			if [ ! "$CHOICE" ]; then
				echo && line_to_remove
				pastel paint $MSG_WARN_COLOR "      We couldn't find any series of this type!" && line_to_remove
				sleep 2
				clear_lines
				clear_modifiers
				continue
			fi
			TRACKMA_INDEX="$(printf "%s" "$CHOICE" | sed -En "s/$TRACKMA_ENTRY_REGEX/\1/p")"
			ANIME_TITLE_TRACKMA=$(get_show_title "$CHOICE")
			STATUS="$(get_show_status "$(printf "%s" "$ANIME_TITLE_TRACKMA" | sed "s/\[.*\]//g" | sed "s/ $//g")")"
			TRACKMA_SHOW_INDEX=$(printf "%s" "$CHOICE" | cut -d " " -f1)
			LAST_WATCHED_EP="$(printf "%s" "$CHOICE" | sed -En "s/.*[[:space:]]+([0-9]*) \/.*/\1/p")"
			LAST_SHOW_EP="$(get_last_show_ep "$ANIME_TITLE_TRACKMA")"

			[ -z "$LAST_SHOW_EP" ] && printf "Couldn't get last series episode" && exit 1
			# if we just don't know what the last episode is we increment anyways and give it a try
			[ "$LAST_SHOW_EP" = "?" ] || [ "$LAST_WATCHED_EP" -lt "$LAST_SHOW_EP" ] && ANIME_EP=$((LAST_WATCHED_EP + 1)) || ANIME_EP="1"
		fi

		[ -z "$STATUS" ] && printf "Couldn't get series status" && exit 1

		if [ "$(get_trackma_status_code "$STATUS")" != "$(get_trackma_status_code "Watching")" ] && [ "$(get_trackma_status_code "$STATUS")" != "$(get_trackma_status_code "Rewatching")" ]; then
			NEW_STATUS="Watching"
			PLAY_OPTIONS_MENU="▶️  Play\n🔄 Set series status as watching + Play"
			if [ "$STATUS" = "$(get_trackma_status_code "Completed")" ]; then
				PLAY_OPTIONS_MENU="▶️ Play\n🔄 Set series status as watching + Reset watched episodes + Continue Playing"
				RESET_EPISODES=1
				if [ "$TRACKER_SERVICE" = "anilist" ]; then
					NEW_STATUS="Rewatching"
					PLAY_OPTIONS_MENU="▶️ Play\n🔄 Set series status as rewatching + Continue Playing"
				fi
			else
				RESET_EPISODES=0
			fi

			SEL_PLAY_OPTION=$(printf "%b\n%s" "$PLAY_OPTIONS_MENU" "$to_mainmenu" |
				$FZF -i --prompt "Choose an option: " --border-label "╢ ♣  PLAY OPTIONS ♣  ╟" --header "⇅ Navigation ─ [ESC] Exit ─ [Enter] Select" --header-first | cut -d " " -f1)
			[ "$SEL_PLAY_OPTION" = "◂" ] && clear_modifiers && continue
			if [ "$SEL_PLAY_OPTION" = "🔄" ]; then
				printf "filter %s\nstatus '%s' %s" "$(get_trackma_status_code "$STATUS")" "$TRACKMA_INDEX" "$(get_trackma_status_code "$NEW_STATUS")" | trackma >"$TRACKMA_LOGFILE" 2>&1
				if [ $RESET_EPISODES -eq 1 ]; then
					printf "filter %s\nupdate '%s' %s" "$(get_trackma_status_code "$STATUS")" "$ANIME_TITLE_TRACKMA" "0" | trackma >>"$TRACKMA_LOGFILE"
					ANIME_EP="1"
					LAST_WATCHED_EP="0"
				fi
				STATUS=$NEW_STATUS
				# update series index after changing lists
				TRACKMA_INDEX="$(printf "%s" "filter %s\nsearch '%s'\n" "$(get_trackma_status_code "$STATUS")" "$(sanitize_ext_regex "$ANIME_TITLE_TRACKMA")" | trackma | sed -En "s/$TRACKMA_ENTRY_REGEX/\1/p")"
			fi
		fi

		# We query trackma again because we want official english and romaji titles
		ANI_INFO=$(printf "filter %s\ninfo %s\n" "$STATUS" "$TRACKMA_INDEX" | trackma)
		ANIME_TITLE_RO="$(printf "%s" "$ANI_INFO" | sed -n "/Romaji/p" | cut -d ":" -f2 | sed "s/ //")"
		ANIME_TITLE_EN="$(printf "%s" "$ANI_INFO" | sed -n "/English/p" | cut -d ":" -f2 | sed "s/ //")"
		# give preference to Romaji, then Japanese, then English titles, as this gives better matching
		if [ -n "$ANIME_TITLE_RO" ] && [ "$ANIME_TITLE_RO" != "None" ]; then
			ANIME_TITLE=$ANIME_TITLE_RO
		else
			ANIME_TITLE=$ANIME_TITLE_TRACKMA
		fi
		SHOW_TYPE=""
		SHOW_SYNONYMS=""
		# player loop
		PLAY_METHOD_MENU_OPT=""
		PLAYER_SOURCE=""
		while true; do
			if [ -z "$PLAYER_SOURCE" ]; then
				PLAY_METHOD_MENU="😺 Search nyaa.si (torrenting)\n🧲 Paste a magnet link (torrenting)\n💡 Stream with animdl (streaming)\n$to_mainmenu"
				if [ "$RANDOM_ANIME" -eq 1 ]; then
					MENU_LABEL="SELECT SOURCE: 🔀 $(trim "$ANIME_TITLE_TRACKMA") ▶ $ANIME_EP"
				elif [ "$RANDOM_AIRING" -eq 1 ]; then
					MENU_LABEL="SELECT SOURCE: 📣 $(trim "$ANIME_TITLE_TRACKMA") ▶ $ANIME_EP"
				else
					MENU_LABEL="SELECT SOURCE: $(trim "$ANIME_TITLE_TRACKMA") ▶ $ANIME_EP"
				fi
				PLAY_METHOD_MENU_OPT="$(printf "%b" "$PLAY_METHOD_MENU" | $FZF -i --prompt="Select a source: " --border-label "╢ ♣  $MENU_LABEL ♣  ╟" --header "⇅ Navigation ─ [ESC] Exit ─ [Enter] Select" --header-first | cut -d " " -f1)"
				if [ "$PLAY_METHOD_MENU_OPT" = "◂" ]; then
					PROMPT="$to_mainmenu"
					clear_modifiers
					break
				elif [ "$PLAY_METHOD_MENU_OPT" = "💡" ]; then
					PLAYER_SOURCE="streaming"
				elif [ "$PLAY_METHOD_MENU_OPT" = "😺" ]; then
					PLAYER_SOURCE="torrenting"
				elif [ "$PLAY_METHOD_MENU_OPT" = "🧲" ]; then
					PLAYER_SOURCE="self_magnet"
				fi
			fi

			if [ -z "$SHOW_TYPE" ]; then
				SHOW_INFO="$(get_show_info "$ANIME_TITLE_TRACKMA" "$STATUS")"
				if printf "%s" "$SHOW_INFO" | grep "Type: " >/dev/null 2>&1; then
					SHOW_TYPE="$(printf "%b" "$SHOW_INFO" | grep "Type: " | awk -F": " '{print $2}')"
				fi
			fi
			if [ -z "$SHOW_SYNONYMS" ]; then
				SHOW_INFO="$(get_show_info "$ANIME_TITLE_TRACKMA" "$STATUS")"
				if printf "%s" "$SHOW_INFO" | grep "Synonyms: " >/dev/null 2>&1; then
					SHOW_SYNONYMS="$(printf "%b" "$SHOW_INFO" | grep "Synonyms: " | awk -F": " '{print $2}')"
					SHOW_SYNONYMS="$ANIME_TITLE_TRACKMA, $ANIME_TITLE_EN, $(printf "%s" "$SHOW_SYNONYMS" | sed "s/[]'[]//g")"
				fi
			fi

			# finally, play the show and hope for the best
			play_episode "$ANIME_TITLE" "$ANIME_EP" "$PLAYER_SOURCE" "$STATUS" "$SHOW_TYPE" "$SHOW_SYNONYMS"

			# block until the play status is set up
			while [ "$PLAY_STATUS" -eq "$PLAY_STATUS_WAITING" ]; do
				sleep 1
			done
			if [ "$PLAY_STATUS" -eq "$PLAY_STATUS_ERRORED" ]; then
				# fatal error, go back to mainmenu
				echo && line_to_remove
				if [ "$PLAYER_SOURCE" = "streaming" ]; then
					pastel paint $MSG_ERR_COLOR "      💥 Unable to play the episode via streaming." && line_to_remove
				else
					pastel paint $MSG_ERR_COLOR "      💥 Unable to stream the episode via torrenting." && line_to_remove
				fi
				printf "%s\n" "      [Enter]  Source selection ▶" && line_to_remove
				# recovery menu loop
				while true; do
					read -r KEY # TODO: -n1
					if [ "$KEY" = "" ]; then
						PLAYER_SOURCE=""
						NYAA_SEARCH_RES=""
						# dont clear modifiers let the user select another source
						clear_lines
						break # to player loop
					fi
				done
				continue
			elif [ "$PLAY_STATUS" = "$PLAY_STATUS_EXITED" ]; then
				clear_lines
				clear_modifiers
				break
			fi
			clear_lines
			ANIME_MENU_TITLE=$(trim "$ANIME_TITLE_TRACKMA")
			# configure the menu entries
			if [ "$LAST_SHOW_EP" != "?" ] && [ "$ANIME_EP" -eq "$LAST_SHOW_EP" ]; then
				PLAYING_MENU="🏁 Set as Watched + Move to Completed list"
				[ "$SHOW_TYPE" != "movie" ] && ANIME_MENU_TITLE="🏁 END! ─ $ANIME_MENU_TITLE"
			else
				PLAYING_MENU="⏭️  Set as Watched + Play next\n✅ Set as Watched"
			fi
			# player reset options
			if [ "$PLAYER_SOURCE" = "torrenting" ]; then
				PLAYING_MENU="$PLAYING_MENU\n🔎 Select another search result\n💡 Switch to streaming\n🙈 Unexpected? Select another file ▸"
			elif [ "$PLAYER_SOURCE" = "streaming" ]; then
				PLAYING_MENU="$PLAYING_MENU\n🔎 Select another search result\n😺 Switch to torrenting"
			fi
			OPT=$(printf "%b" "$PLAYING_MENU\n$to_mainmenu" |
				$FZF -i --prompt="Choose an action: " --border-label "╢ 📺  NOW PLAYING$([ -n "$SHOW_TYPE" ] && printf "%s" " ($SHOW_TYPE)" | tr '[:lower:]' '[:upper:]') ─ ${ANIME_MENU_TITLE}$([ -n "$SHOW_TYPE" ] && [ "$SHOW_TYPE" != "movie" ] && printf " ▶ Episode %s" "$ANIME_EP") ╟" --header "⇅ Navigation ─ [ESC] Exit ─ [Enter] Select" --header-first --preview "printf \"%s\" '$DEBUG_MATCH_INFO' | jq | bat -p --language=json" --bind "ctrl-l:toggle-preview" --preview-label "STREAM DEBUG" --preview-window "50,hidden,wrap")
			OPT=$(printf "%s" "$OPT" | cut -d " " -f1)
			[ "$OPT" = "◂" ] && PROMPT="$to_mainmenu" && clear_modifiers && break
			if [ "$OPT" = "✅" ]; then
				set_ep_as_watched "$ANIME_TITLE_TRACKMA" "$ANIME_EP"
				clear_modifiers
				break
			elif [ "$OPT" = "⏭️" ]; then
				set_ep_as_watched "$ANIME_TITLE_TRACKMA" "$ANIME_EP"
				if [ "$PLAYER_SOURCE" = "torrenting" ]; then
					NYAA_SEARCH_RES="" # will query nyaa again
					MAGNET_LINK=""
					FILE_LIST=""
				elif [ "$PLAYER_SOURCE" = "streaming" ]; then
					ANIMDL_PLAYTHROUGH=1
				fi
				PLAY_METHOD_MENU_OPT=""
				ANIME_EP=$((ANIME_EP + 1))
			elif [ "$OPT" = "🏁" ]; then
				set_ep_as_watched "$ANIME_TITLE_TRACKMA" "$ANIME_EP"
				set_show_status "$TRACKMA_SHOW_INDEX" "Completed"
				break
			elif [ "$OPT" = "💡" ]; then
				PLAYER_SOURCE="streaming"
				MAGNET_LINK=""
				NYAA_SEARCH_RES=""
			elif [ "$OPT" = "😺" ]; then
				PLAYER_SOURCE="torrenting"
			elif [ "$OPT" = "🔎" ]; then
				[ "$PLAYER_SOURCE" = "streaming" ] && ANIMDL_PLAYTHROUGH=0
				[ "$PLAYER_SOURCE" = "torrenting" ] && NYAA_SEARCH_RES="" && MAGNET_LINK=""
			elif [ "$OPT" = "🙈" ]; then
				FILE_INDEX="$NYAAPY_FILE_SEL_CODE"
			fi
		done
		set +u nounset
		if ps "$animdl_pid" >/dev/null 2>&1; then
			kill -9 "$animdl_pid"
		fi
		set -u nounset
		;;
	"$add_show")
		STATUS="Plan to Watch"
		echo && line_to_remove
		printf "      🧩 What anime do you plan to watch❔ \n         👉 " && line_to_remove
		read -r ANIME
		ANIME="$(printf "%s" "$ANIME" | sed -E 's/[^a-zA-Z0-9 ]//g')"
		clear_lines
		[ -z "$ANIME" ] && clear_modifiers && continue
		tmpfile="$(posix_mktemp_file)"
		fifo_write="$(posix_mktemp_file)"
		mkfifo -m 600 "$fifo_write"
		trackma <"$fifo_write" >"$tmpfile" 2>"$TRACKMA_LOGFILE" &
		exec 3>"$fifo_write"
		printf "%b" "filter $(get_trackma_status_code "$STATUS")\nadd '$ANIME'\n" >&3
		pastel paint $MSG_INFO_COLOR "      🔎 Searching the anime tracker ($TRACKER_SERVICE), please wait..." && line_to_remove
		while ! grep "Choose" "$tmpfile" >/dev/null 2>&1; do :; done
		clear_lines
		results=$(sed -En '/^[0-9]+\:/p' "$tmpfile")
		choice="$(printf "%b" "$results" | $FZF --prompt="Choose the anime to add: " --border-label "╢ ♣  ADD NEW ANIME ($STATUS list) ♣  ╟" --header "⇅ Navigation ─ [ESC] Exit ─ [Enter] Add" --header-first | cut -d ':' -f1)"
		[ -z "$choice" ] && exit
		printf "%b" "$choice\n" >"$fifo_write"
		rm "$fifo_write" "$tmpfile"
		unset tmpfile
		unset fifo_write
		3>&-:
		clear_modifiers
		;;
	"$delete_show")
		STATUS=$(printf "%b\n%s" "$TRACKMA_STATUS_MENU_ENTRIES" "$to_submenu" | $FZF -i --prompt="Choose a status: " --border-label "╢ ♣  DELETE SERIES (Status select) ♣  ╟" --header "⇅ Navigation ─ [ESC] Exit ─ [Enter] Select" --header-first)
		[ "$STATUS" = "$to_submenu" ] && PROMPT="$to_submenu" && continue
		STATUS=$(get_trackma_status_code "$STATUS")
		FULL_LIST=$(printf "filter %s\nls" "$STATUS" | trackma | sed -En "s/$TRACKMA_LIST_REGEX/\1/p" | sed "s,$(printf '\033')\\[[0-9;]*[a-zA-Z],📣 ," | sed "s,$(printf '\033')\\[[0-9;]*[a-zA-Z],,g" | sed -E "/📣/ s/(.*)\.{3}(.*)/\1\2/" | sort -r --version-sort)
		[ -z "$FULL_LIST" ] && FULL_LIST="No entries found in this list..."
		FULL_LIST="$FULL_LIST\n$to_submenu\n$SWITCH_STATUS_MSG_MENU_ENTRY"
		TRACKMA_SHOW_INDEX=$(printf "%b" "$FULL_LIST" |
			$FZF -i --prompt="Choose a series to DELETE: " --border-label "╢ ♣  DELETE SERIES ♣  ╟" --header "⇅ Navigation ─ [ESC] Exit ─ [Enter] Delete" --header-first | cut -d" " -f1)
		[ "$TRACKMA_SHOW_INDEX" = "🐇" ] && PROMPT="$to_submenu" && continue
		[ "$TRACKMA_SHOW_INDEX" = "🔄" ] && continue
		printf "filter %s\ndelete %s\ny" "$STATUS" "$TRACKMA_SHOW_INDEX" | trackma >"$TRACKMA_LOGFILE" 2>&1
		;;
	"$update_episodes" | "$update_status")
		if [ "$PROMPT" = "$update_episodes" ]; then
			menuitem="$to_submenu"
		else
			menuitem="$to_mainmenu"
		fi
		if [ -z "$NEW_STATUS" ] && [ -z "$TRACKMA_SHOW_INDEX" ]; then
			# let the user select a show
			STATUS=$(printf "$TRACKMA_STATUS_MENU_ENTRIES\n%s" "$menuitem" | $FZF -i --prompt="Choose a status: " --border-label "╢ ♣  UPDATE EPISODE (Select series to update) ♣  ╟" --header "⇅ Navigation ─ [ESC] Exit ─ [Enter] Select" --header-first)
			[ "$STATUS" = "$menuitem" ] && PROMPT=$menuitem && continue

			STATUS=$(get_trackma_status_code "$STATUS")

			RES="$(printf "filter %s\nls" "$STATUS" | trackma | sed -En "s/$TRACKMA_LIST_REGEX/\1/p" | sort -r)"
			if [ -z "$RES" ]; then
				RES="This list has no items..."
				TRACKMA_SHOW_INDEX="$(printf "%b" "$RES\n$menuitem" | $FZF -i --prompt="Choose an anime: " --border-label "╢ ♣  UPDATE EPISODE ($STATUS list) ♣  ╟" --header "⇅ Navigation ─ [ESC] Exit ─ [Enter] Select" --header-first | cut -d" " -f1)"
				PROMPT=$menuitem && continue
			fi

			TRACKMA_SHOW_INDEX="$(printf "%b" "$RES\n$menuitem" | $FZF -i --prompt="Choose an anime: " --border-label "╢ ♣  UPDATE EPISODE ($STATUS list) ♣  ╟" --header "⇅ Navigation ─ [ESC] Exit ─ [Enter] Select" --header-first | cut -d" " -f1)"
			[ "$TRACKMA_SHOW_INDEX" = "🐇" ] && PROMPT=$menuitem && continue

		fi
		if [ "$PROMPT" = "$update_episodes" ]; then
			printf "      How many episodes of this anime have you watched so far❔\n" && line_to_remove
			read -r NEW_EPISODE_COUNT # TODO: -n4
			NEW_EPISODE_COUNT="$(printf "%s" "$NEW_EPISODE_COUNT" | sed -E 's/[^0-9]//g')"
			clear_lines
			[ -z "$NEW_EPISODE_COUNT" ] && clear_modifiers && continue
			printf "filter %s\nupdate '%s' %s" "$STATUS" "$TRACKMA_SHOW_INDEX" "$NEW_EPISODE_COUNT" | trackma >"$TRACKMA_LOGFILE" 2>&1
		else
			if [ -z "$NEW_STATUS" ]; then
				NEW_STATUS=$(printf "%b" "$menuitem\n$TRACKMA_STATUS_MENU_ENTRIES" | $FZF -i --prompt="Choose the new status: " --border-label "╢ ♣  UPDATE EPISODE STATUS (Select the NEW status) ♣  ╟" --header "⇅ Navigation ─ [ESC] Exit ─ [Enter] Select" --header-first)
				[ "$NEW_STATUS" = "$menuitem" ] && PROMPT=$menuitem && clear_modifiers && continue
				NEW_STATUS="$(get_trackma_status_code "$NEW_STATUS")"
			fi
			[ -n "$TRACKMA_SHOW_INDEX" ] && TRACKMA_ID="$TRACKMA_SHOW_INDEX" || TRACKMA_ID="$ANIME_TITLE_TRACKMA"
			printf "filter %s\nstatus '%s' %s" "$STATUS" "$TRACKMA_ID" "$NEW_STATUS" | trackma >"$TRACKMA_LOGFILE" 2>&1
		fi
		clear_modifiers
		;;
	"$score_show")
		STATUS=$(printf "%b" "$to_mainmenu\n$TRACKMA_STATUS_MENU_ENTRIES" | $FZF -i --prompt="Choose a status: " --border-label "╢ ♣  RATE SERIES (Status select) ♣  ╟" --header "⇅ Navigation ─ [ESC] Exit ─ [Enter] Select" --header-first)

		STATUS=$(get_trackma_status_code "$STATUS")

		[ "$STATUS" = "$to_mainmenu" ] && PROMPT=$to_mainmenu && clear_modifiers && continue

		while true; do
			FULL_INFO="$(printf "filter %s\nls" "$STATUS" | trackma | sort -r | sed -En "s/$TRACKMA_LIST_REGEX/\1/p")"
			# remove character sequences and add an emoji next to airing shows
			FULL_INFO=$(printf '%s\n' "$FULL_INFO" | sed "s,$(printf '\033')\\[[0-9;]*[a-zA-Z],📣 ," | sed "s,$(printf '\033')\\[[0-9;]*[a-zA-Z],,g" | sed -E "/📣/ s/(.*)\.{3}(.*)/\1\2/")
			FULL_INFO="$FULL_INFO\n$to_mainmenu"
			TRACKMA_SHOW_INDEX="$(printf "%b" "$FULL_INFO" | $FZF -i --prompt="Choose an anime: " --border-label "╢ ♣  RATE SERIES ($STATUS) ♣  ╟" --header "⇅ Navigation ─ [ESC] Exit ─ [Enter] Select" --header-first | cut -d" " -f1)"
			[ "$TRACKMA_SHOW_INDEX" = "<" ] && unset PROMPT && break
			[ "$TRACKMA_SHOW_INDEX" = "*" ] && break
			echo && line_to_remove
			printf "      🌟 What do you score this anime (0-10)❔ " && line_to_remove
			read -r SCORE
			clear_lines
			[ "$SCORE" -lt 0 ] && SCORE=0
			[ "$SCORE" -gt 10 ] && SCORE=10
			printf "filter %s\nscore %s %s" "$STATUS" "$TRACKMA_SHOW_INDEX" "$SCORE" | trackma >"$TRACKMA_LOGFILE" 2>&1
			clear_modifiers
			break
		done
		;;
	"$set_altname")
		STATUS=$(printf "$TRACKMA_STATUS_MENU_ENTRIES\n%s" "$to_submenu" | $FZF -i --prompt="Choose a status: " --border-label "╢ ♣  SET ALTERNATIVE NAME (Status select) ♣  ╟" --header "⇅ Navigation ─ [ESC] Exit ─ [Enter] Select" --header-first)

		[ "$STATUS" = "$to_submenu" ] && PROMPT=$to_submenu && continue

		while true; do
			FULL_INFO="$(printf "filter %s\nls" "$STATUS" | trackma | sort -r | sed -En "s/$TRACKMA_LIST_REGEX/\1/p")"
			FULL_INFO=$(printf '%s\n' "$FULL_INFO" | sed "s,$(printf '\033')\\[[0-9;]*[a-zA-Z],📣 ," | sed "s,$(printf '\033')\\[[0-9;]*[a-zA-Z],,g" | sed -E "/📣/ s/(.*)\.{3}(.*)/\1\2/")
			FULL_INFO="$FULL_INFO\n$to_submenu\n$SWITCH_STATUS_MSG_MENU_ENTRY"
			TRACKMA_SHOW_INDEX="$(printf "%b" "$FULL_INFO" | $FZF -i --prompt="Choose an anime: " --border-label "╢ ♣  SET ALTERNATIVE NAME ($STATUS list) ♣  ╟" --header "⇅ Navigation ─ [ESC] Exit ─ [Enter] Select" --header-first)"
			[ "$TRACKMA_SHOW_INDEX" = "$to_submenu" ] && PROMPT=$to_submenu && break
			[ "$TRACKMA_SHOW_INDEX" = "$SWITCH_STATUS_MSG_MENU_ENTRY" ] && break
			TRACKMA_SHOW_INDEX=$(printf "%s" "$TRACKMA_SHOW_INDEX" | cut -d" " -f1)
			printf "%b" "
			     ℹ  What is the altname❔ "
			read -r NEWNAME
			printf "altname %s '%s'" "$TRACKMA_SHOW_INDEX" "$NEWNAME" | trackma >"$TRACKMA_LOGFILE" 2>&1
		done
		clear_modifiers
		;;
	"$pull")
		SEL=$(printf "🔄 Overwrite local lists\n%s" "$to_mainmenu" | $FZF -i --prompt="Choose an option: " --border-label "╢ ♣  $pull ♣  ╟" --header "⇅ Navigation ─ [ESC] Exit ─ [Enter] Select" --header-first | cut -d" " -f1)
		[ "$SEL" = "$to_mainmenu" ] && PROMPT=$to_mainmenu && continue
		[ "$SEL" = "🔄" ] &&
			trackma retrieve >"$TRACKMA_LOGFILE" 2>&1
		clear_modifiers
		;;
	"$push")
		SEL=$(printf "🔄 Overwrite remote lists\n%s" "$to_mainmenu" | $FZF -i --prompt="Choose an option: " --border-label "╢ ♣  $push ♣  ╟" --header "⇅ Navigation ─ [ESC] Exit ─ [Enter] Select" --header-first | cut -d" " -f1)
		[ "$SEL" = "$to_mainmenu" ] && clear_modifiers && continue
		[ "$SEL" = "🔄" ] &&
			trackma send >"$TRACKMA_LOGFILE" 2>&1
		clear_modifiers
		;;
	"$list_airing")
		LIST_AIRING=1
		PROMPT=$list
		;;
	"$list_by_score")
		SORT_SCORE=1
		PROMPT=$list
		;;
	"$list")
		STATUS=$(printf "%s\n%s" "$TRACKMA_STATUS_MENU_ENTRIES" "$to_mainmenu" | $FZF -i --prompt="Choose a status: " --border-label " ♣  LIST$([ "$SORT_SCORE" -eq 1 ] && printf ' BY SCORE' || [ "$LIST_AIRING" -eq 1 ] && printf ' AIRING SHOWS' || printf " SHOWS") (Status select) ♣  " --header "⇅ Navigation ─ [ESC] Exit ─ [Enter] Select" --header-first)
		[ "$STATUS" = "$to_mainmenu" ] && PROMPT=$to_mainmenu && continue

		STATUS=$(get_trackma_status_code "$STATUS")

		if [ "$SORT_SCORE" -eq 1 ]; then
			# sort by score
			MSG=$(printf 'filter %s\nsort my_score\nls' "$STATUS" | trackma | sed -En "s/$TRACKMA_LIST_REGEX/\1/p" | sort -r)
		else
			MSG=$(printf 'filter %s\nls' "$STATUS" | trackma | sed -En "s/$TRACKMA_LIST_REGEX/\1/p" | sort -r --version-sort)
		fi
		# remove character sequences and add an emoji next to airing shows
		MSG=$(printf '%s\n' "$MSG" | sed "s,$(printf '\033')\\[[0-9;]*[a-zA-Z],📣 ," | sed "s,$(printf '\033')\\[[0-9;]*[a-zA-Z],,g" | sed -E "/📣/ s/(.*)\.{3}(.*)/\1\2/")

		if [ "$LIST_AIRING" -eq 1 ]; then
			# filter airing show per user request
			MSG=$(printf "%s" "$MSG" | sed -n "/📣/p")
		fi

		if [ ! "$MSG" ]; then
			MSG="This list has no items... "
			SEL=$(printf "%s\n%s\n%s" "$MSG" "$to_mainmenu" "$SWITCH_STATUS_MSG_MENU_ENTRY" | $FZF -i --bind "ctrl-l:toggle-preview" --preview-window "50,hidden,wrap" --preview "$sanitize_ext_regex_function_code; $get_show_title_function_code; $get_trackma_status_code_function_code; $get_show_info_function_code; get_show_info {} $STATUS | bat --style=plain --color=always --language=yaml" --preview-label ' Info ' --border-label " ♣  LIST$([ "$SORT_SCORE" -eq 1 ] && printf ' BY SCORE 🌟' || [ "$LIST_AIRING" -eq 1 ] && printf ' AIRING SHOWS 📣' || printf " SHOWS") ($STATUS list) ♣  " --header "⇅ Navigation - [Enter] Go back" --prompt "")
			[ "$SEL" = "$to_mainmenu" ] && PROMPT="$to_mainmenu" && continue
			continue
		fi

		export STATUS
		while true; do
			SEL=$(printf "%s\n%s\n%s" "$MSG" "$to_mainmenu" "$SWITCH_STATUS_MSG_MENU_ENTRY" | $FZF -i --bind "ctrl-l:toggle-preview" --preview-window "50,hidden,wrap" --preview "$sanitize_ext_regex_function_code; $get_show_title_function_code; $get_trackma_status_code_function_code; $get_show_info_function_code; get_show_info {} $STATUS | bat --style=plain --color=always --language=yaml" --preview-label ' Info ' --border-label " ♣  LIST$([ "$SORT_SCORE" -eq 1 ] && printf ' BY SCORE 🌟' || [ "$LIST_AIRING" -eq 1 ] && printf ' AIRING SHOWS 📣' || printf " SHOWS") ($STATUS list) ♣  " --header "⇅ Navigation - [Ctrl-L] toggle info - [ESC] Exit - [Enter] Play ▸" --prompt "Choose an anime: ")
			[ "$SEL" = "$to_mainmenu" ] && clear_modifiers && break
			[ "$SEL" = "$SWITCH_STATUS_MSG_MENU_ENTRY" ] && break
			ANIME_TITLE_TRACKMA=$(get_show_title "$SEL")
			LAST_SHOW_EP="$(get_last_show_ep "$ANIME_TITLE_TRACKMA")"
			[ -z "$LAST_SHOW_EP" ] && printf "Couldn't get last show episode" && exit 1
			LAST_WATCHED_EP="$(printf "%s" "$SEL" | sed -En "s/$TRACKMA_ENTRY_REGEX/\4/p")"
			# only increment if it's not the last episode of the show
			# if we don't know the last aired apisode just attempt playing the next episode
			# LAST_SHOW_EP can be a string or integer
			if [ "$LAST_SHOW_EP" = "?" ]; then
				ANIME_EP=$((LAST_WATCHED_EP + 1))
			elif [ "$LAST_WATCHED_EP" -lt "$LAST_SHOW_EP" ]; then
				ANIME_EP=$((LAST_WATCHED_EP + 1))
			else
				ANIME_EP="1"
			fi
			TRACKMA_INDEX="$(printf "%s" "$SEL" | sed -En "s/$TRACKMA_ENTRY_REGEX/\1/p")"
			PROMPT="$watch"
			break
		done
		;;
	esac
done
trap - 1 2 3 15

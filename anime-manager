#!/bin/sh
set -o errexit
set -o nounset

# override locale categories
eval export "$(locale)"
unset LC_ALL
LANG="C"
LC_ALL="C"
LC_COLLATE="C"
LC_CTYPE="C"
LC_MESSAGES="C"
LC_MONETARY="C"
LC_NUMERIC="C"
LC_TIME="C"
LC_ADDRESS="C"
LC_IDENTIFICATION="C"
LC_MEASUREMENT="C"
LC_NAME="C"
LC_PAPER="C"
LC_TELEPHONE="C"
LANGUAGE="en_US.UTF-8"
export LANG LC_ALL \
	LC_COLLATE \
	LC_CTYPE \
	LC_MESSAGES \
	LC_MONETARY \
	LC_NUMERIC \
	LC_TIME \
	LANGUAGE \
	LC_ADDRESS \
	LC_IDENTIFICATION \
	LC_MEASUREMENT \
	LC_NAME \
	LC_PAPER \
	LC_TELEPHONE

. ./lib/array

version="0.0.1"
OSTYPE="$(uname -s 2>/dev/null)"
parse_args() {
	# defaults
	debug=0
	small_logo=0
	monochrome_logo=0
	while true; do
		case "${1-}" in
		--small-logo) small_logo=1 ;;
		--monochrome-logo) monochrome_logo=1 ;;
		-d | --debug) debug=1 && set -x ;;
		-v | --version) printf "%s\n" "$version" && exit ;;
		-?*) printf "%s\n" "ðŸ’¥ Unknown option: $1" && exit 1 ;;
		*) break ;;
		esac
		shift
	done
}

case $# in
0) parse_args ;;
*) parse_args "$@" ;;
esac

# cleanly go to the main loop
# a 'modifier' for us is a flow control variable
clear_modifiers() {
	RANDOM_ANIME=0
	RANDOM_AIRING=0
	PROMPT=""
	LIST_AIRING=0
	SORT_SCORE=0
	ANIME_TITLE=""
	ANIME_TITLE_TRACKMA=""
	TRACKMA_SHOW_INDEX=""
	ANIME_EP=""
	STATUS=""
	NEW_STATUS=""
	LAST_WATCHED_EP=""
	NYAA_SEARCH_RES=""
	PLAY_STATUS=$PLAY_STATUS_WAITING
	PLAYER_SOURCE="torrenting"
	MAGNET_LINK=""
	PLAY_METHOD_MENU_OPT=""
	DEBUG_MATCH_INFO=""
	FILE_LIST=""
	FILE_INDEX=""
	ANIMDL_PLAYTHROUGH=0
	ANIMDL_SEARCH_INDEX=1
}

reset_logs() {
	echo > "$WEBTORRENT_LOGFILE"
	echo > "$TRACKMA_LOGFILE"
	echo > "$ANIMDL_LOGFILE"
	# echo > "$CURRENTLY_PLAYING_LOGFILE"
	echo > "$NYAA_SEARCH_LOGFILE"
	echo > "$NYAA_FID_LOGFILE"
}

onexit() {
	onexit_last_exit_status="$?"
	onexit_parent_lineno="$1"
	onexit_message="${2:-(no message ($onexit_last_exit_status))}"
	onexit_exit_code="${3:-$onexit_last_exit_status}"
	if [ "$onexit_exit_code" -eq 130 ] || [ "$onexit_exit_code" -eq 0 ]; then
		tput clear && tput clear
	else
		tput clear
		printf "%s\n" "ERROR on line $onexit_parent_lineno - $onexit_message - exit code $onexit_exit_code"
	fi
	# cleanup, save disk space
	[ $debug -eq 0 ] &&
		reset_logs &&
		rm -rf "$TORRENT_DOWNLOAD_DIR"
	clear_modifiers
	exit "$onexit_exit_code"
}

trap 'onexit ${LINENO}' 1 2 3 15

tput clear

# formats and prints a string
log() {
	printf "%b\n" "$1"
}

# returns true if the user has initialized an account
is_trackma_init() {
	if [ -n "$(printf "q\n" | trackma ls | sed -En "s/no account|Available accounts/&/p")" ]; then
		false
	else
		true
	fi
}

checkTrackmaConfig() {
	checkTrackmaConfig_trackma_config_file=""
	if [ -s "$HOME"/.trackma/config.json ]; then
		checkTrackmaConfig_trackma_config_file="$HOME/.trackma/config.json"
	elif [ -s "$HOME"/.config/trackma/config.json ]; then
		checkTrackmaConfig_trackma_config_file="$HOME/.config/trackma/config.json"
	fi
	AUTORET_VALUE="$(jq --raw-output '.autoretrieve' "$checkTrackmaConfig_trackma_config_file")"
	AUTOSEN_VALUE="$(jq --raw-output '.autosend' "$checkTrackmaConfig_trackma_config_file")"
	if [ "$AUTORET_VALUE" = "always" ] || [ "$AUTOSEN_VALUE" = "always" ]; then
		printf "%b" "
ðŸ’¥ Anime Manager was unable to start!
   Please change the 'autoretrieve' and 'autosave' options
   in '$checkTrackmaConfig_trackma_config_file'
   to a value other than 'always'.
"
		exit 1
	fi

	if ! is_trackma_init; then
		printf "LINK YOUR ACCOUNT TO TRACKMA\nNo account was found. Next steps:\n- 1. Open a new Terminal window or tab.\n- 2. Run 'trackma account' and follow the instructions to add and select your account.\n- 3. Come back to this prompt and press [Enter].\n(waiting...): "
		while ! is_trackma_init; do
			read -r KEY # TODO: -n1
			[ "$KEY" = "" ] && [ "$(is_trackma_init)" ] && break || printf "\n%s" "... Could not detect account, please try again... "
		done
		tput clear
	fi
}

# trim long show titles
trim() {
	MAX_LEN=20
	STRING="$1"
	C_COUNT=$(printf "%s" "$STRING" | wc -c | sed "s/ //g")
	if [ "$C_COUNT" -gt $MAX_LEN ]; then
		printf "%s" "$STRING" | cut -c 1-"$MAX_LEN" | sed "s/$/(...)/"
	else
		printf "%s" "$STRING"
	fi
}

line_to_remove() {
	LINES_TO_REMOVE="$((LINES_TO_REMOVE + 1))"
}

# clear n number of lines from output
# caveat: wrapped lines
clear_lines() {
	while [ $LINES_TO_REMOVE -gt 0 ]; do
		printf "%b" "${OVERWRITE}"
		LINES_TO_REMOVE=$((LINES_TO_REMOVE - 1))
	done
}

# check if we can run automatic install for missing dependencies
autoCompat() {
	if [ "$OSTYPE" = "Linux" ] && grep "Ubuntu" /etc/os-release >/dev/null 2>&1; then
		true
	elif [ "$OSTYPE" = "Darwin" ]; then
		true
	else
		log "Automatic installation does not support your platform yet\nbut we may add support for it in the future.\n\nPlease install the dependencies manually.\n\nMORE INFO: https://github.com/anma-dev/Anime-Manager#dependencies"
		exit 0
	fi
}

# get the shell configuration file path
getShellConfigFile() {
	getShellConfigFile_shell_cfig=""
	[ "$SHELL" = "/bin/bash" ] && touch "$HOME/.bash_profile" && getShellConfigFile_shell_cfig="$HOME/.bash_profile"
	# nvm on macos needs the shell config file
	[ "$SHELL" = "/bin/zsh" ] && touch "$HOME/.zshrc" && getShellConfigFile_shell_cfig="$HOME/.zshrc"
	printf "%s" "$getShellConfigFile_shell_cfig"
}

# install dependencies automatically if we can
install_dependencies() {
	shell_cfg="$(getShellConfigFile)"
	DEP_ERR=0
	install_dep_msg="ðŸŽ‰ Finished the autoinstall!\nRestart your Terminal app to start using Anime Manager."
	# Ubuntu (not WSL) and macOS support
	if ! which fzf pastel bat animdl trackma jq node >/dev/null 2>&1 || [ ! -s lib/webtorrent-cli/bin/cmd.js ]; then
		log "Anime Manager can automatically install its dependencies.\nSome dependencies were not found!" && line_to_remove
		DEP_ERR=1

		if autoCompat && [ $DEP_ERR -eq 1 ]; then
			printf "%s" "Install missing dependencies now? [y/N] " && line_to_remove
			read -r yn </dev/tty
			if [ -z "$yn" ]; then
				yn="n"
			fi
			case "$yn" in
			[Yy]*) ;;
			[Nn]*) exit 0 ;;
			*) printf "%s\n" "      Please answer 'yes' or 'no'." && line_to_remove ;;
			esac
		fi
		# begin installation
		if [ "$OSTYPE" = "Linux" ] && grep "Ubuntu" /etc/os-release >/dev/null 2>&1; then
			log "ðŸ§ Installing Ubuntu dependencies."
			sudo -v
			[ $? -ne 0 ] && log "ðŸ’¥ Your current user account has no administrative privileges.\nRequired dependencies unable to install\nPlease contact your system administrator." && exit 1
			sudo apt update
			sudo apt -y install build-essential procps curl file git gawk python3-setuptools python3-pip bat jq
			# avoid batcat
			mkdir -p ~/.local/bin
			if [ ! -s ~/.local/bin/bat ]; then
				ln -s /usr/bin/batcat ~/.local/bin/bat
				printf "%s\n" 'export PATH="$HOME/.local/bin/:$PATH"' >>"$shell_cfg"
			fi
			if ! command -v fzf; then
				# require an fzf version with label and label coloring support
				git clone --depth 1 https://github.com/junegunn/fzf.git ~/.fzf
				~/.fzf/install --all --update-rc
			else
				fzf_version="$(fzf --version)"
				if [ -z "$(printf "%s" "$fzf_version" | awk -F. '$1 >= 0 && $2 >= 35 {print $0}')" ]; then
					printf "\n\n%s\n\n" "Please manually update your fzf installation to version >= 0.35.x."
				fi
			fi
			[ ! -d lib/webtorrent-cli/bin/cmd.js ] && ./utils/install-webtorrent.sh
			if ! command -v pastel; then
				# https://github.com/sharkdp/pastel
				wget "https://github.com/sharkdp/pastel/releases/download/v0.9.0/pastel_0.9.0_amd64.deb"
				sudo dpkg -i pastel_0.9.0_amd64.deb
				rm pastel_0.9.0_amd64.deb
			fi
			if ! command -v animdl; then
				# https://github.com/justfoolingaround/animdl
				pip3 install animdl
			fi
			if ! command -v trackma; then
				sudo apt install lsof
				# https://github.com/z411/trackma
				pip3 install pillow \
					PyQt5 \
					pydbus \
					setuptools \
					wheel \
					pyinotify \
					nyaapy \
					anitopy \
					'requests>=2.20.0' \
					beautifulsoup4==4.6.0 \
					lxml \
					dbus-python
				pip3 install Trackma
			fi
		elif [ "$OSTYPE" = "Darwin" ]; then
			log "ðŸ Installing macOS dependencies."
			if ! pkgutil --pkg-info=com.apple.pkg.CLTools_Executables | grep version >/dev/null 2>&1; then
				# xcode command line tools is a dependency of nvm and homebrew
				xcode-select --install
			fi
			if ! command -v brew; then
				# Install homebrew unattended
				NONINTERACTIVE=1 /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
			fi
			if ! grep 'export PATH="/opt/homebrew/bin/:$PATH"' "$shell_cfg" >/dev/null 2>&1; then
				printf "%s\n" 'export PATH="/opt/homebrew/bin/:$PATH"' >>"$shell_cfg"
			fi
			# https://github.com/sharkdp/pastel
			brew install curl jq gawk grep axel openssl@1.1 ffmpeg git bat
			brew install patchelf cmake automake fzf pastel
			if ! command -v animdl; then
				# https://github.com/justfoolingaround/animdl
				pip3 install animdl
			fi
			[ ! -d lib/webtorrent-cli/bin/cmd.js ] && ./utils/install-webtorrent.sh
			if ! command -v trackma; then
				# https://github.com/z411/trackma
				# dbus-python module is broken on macOS and cannot be built. This means no trackma mpris support.
				# pip3 install dbus-python
				# inotify is not available on macosx-XX-arm64
				# pip3 install pyinotify
				# Installs qt5 for trackma gui
				pip3 install pillow \
					PyQt5 \
					pydbus \
					setuptools \
					setuptools_scm \
					scikit-build \
					nyaapy \
					anitopy \
					'requests>=2.20.0' \
					beautifulsoup4==4.6.0 \
					lxml \
					wheel \
					Trackma
			fi
		fi
		DEP_ERR=0
		echo
		log "$install_dep_msg"
		exit
	fi
	if ! grep "export LC_CTYPE=en_US.UTF-8" "$shell_cfg" >/dev/null 2>&1; then
		printf "%s\n" 'export LC_CTYPE=en_US.UTF-8' >"$shell_cfg"
	fi
	if ! grep "export LC_ALL=en_US.UTF-8" "$shell_cfg" >/dev/null 2>&1; then
		printf "%s\n" 'export LC_ALL=en_US.UTF-8' >"$shell_cfg"
	fi
}

# sanitizes a string to be used in an extended regular expression
sanitize_ext_regex_function_code='sanitize_ext_regex() {
	printf "%s" "$1" |
		sed "s,$(printf "\033")\\[[0-9;]*[a-zA-Z],," |
		sed "s,$(printf "\033")\\[[0-9;]*[a-zA-Z],,g" |
		sed "s/[]\/\$*.^+()[-]/\\\&/g" |
		sed "s/ $//"
}'
eval "$sanitize_ext_regex_function_code"

sanitize_bash() {
	printf "%s" "$1" | LC_ALL=C sed -e 's/[^a-zA-Z0-9,._+@%/-]/\\&/g; 1{$s/^$/""/}; 1!s/^/"/; $!s/$/"/'
}

LINES_TO_REMOVE=0
# Message color palette for pastel
MSG_INFO_COLOR="lightyellow"
MSG_WARN_COLOR="orange"
MSG_ERR_COLOR="red"
MSG_HELP_COLOR="deepskyblue"
TITLE_COLOR="yellow"
SUBTITLE_COLOR="lightblue"

DATE_MONTH=$(date "+%m")
DATE_DAY=$(date "+%d")
OVERWRITE='\r\033[1A\033[0K'
CONFIG_PATH="$HOME/.config/anime-manager"
TMP_PATH="/tmp/anime-manager"
CHECKPOINTFILE="$HOME/.config/anime-manager/checkpoint"
PLAYER_SOURCE="torrenting"

ANIMDL_PLAYTHROUGH=0
ANIMDL_SEARCH_INDEX=1
NYAA_SEARCH_BIN="lib/nyaa_search.py"
NYAA_SEARCH_LOGFILE="$CONFIG_PATH/nyaa_search.log"
NYAA_FID_LOGFILE="$CONFIG_PATH/get_torrent_fid.log"
GET_TORRENT_FID_BIN="lib/get_torrent_fid.py"
WEBTORRENT_CLI="lib/webtorrent-cli/bin/cmd.js"
TORRENT_DOWNLOAD_DIR="${TMP_PATH}/webtorrent"

# logfiles
WEBTORRENT_LOGFILE="$CONFIG_PATH/webtorrent.log"
TRACKMA_LOGFILE="$CONFIG_PATH/trackma.log"
# CURRENTLY_PLAYING_LOGFILE="$CONFIG_PATH/now_playing.log"
ANIMDL_LOGFILE="$CONFIG_PATH/animdl.log"
# webtorrent globals
# torrent status codes
TORRENT_TMOUT=60
TORRENT_STATUS_OKPLAYING=0
TORRENT_STATUS_STALLED=1
TORRENT_STATUS_ERRORED=2
FILE_LIST=""
webtorrentpid=""
# player status codes
PLAY_STATUS_WAITING=0
PLAY_STATUS_OKPLAYING=1
PLAY_STATUS_ERRORED=2
PLAY_STATUS_EXITED=3
# PLAY_STATUS_OFFLINE=4
PLAY_STATUS=$PLAY_STATUS_WAITING
# nyaapy scraper status codes
NYAA_SEARCH_ERROR_CODE="-2"
NYAAPY_FILE_SEL_CODE="-1"

mkdir -p "$TMP_PATH"
mkdir -p "$TORRENT_DOWNLOAD_DIR"
mkdir -p "$CONFIG_PATH"
[ ! -f "$TRACKMA_LOGFILE" ] && touch "$TRACKMA_LOGFILE"

# initial checks
if [ ! -f "$CHECKPOINTFILE" ]; then
	install_dependencies
	checkTrackmaConfig
	printf "%s" "
READ FIRST --

	This program comes with ABSOLUTELY NO WARRANTY.
Anime Manager is a file sharing program. When you run a torrent (Anime Manager can play content by the means of running a torrent), its data will be made available to others by means of upload. Any content you share is your sole responsibility. No further notices will be issued.

-------------

Do you agree with this? [yes/no]: "
	while true; do
		read -r ANSWER
		case "$ANSWER" in
		"yes") break ;;
		"no") exit ;;
		*) printf "%s" "Please answer 'yes' or 'no': " && line_to_remove ;;
		esac
	done
	printf "%s\n" "$ANSWER" >"$CHECKPOINTFILE"
	tput clear
fi

# Create a safe temporary filename in a posix-compliant way
posix_mktemp_file() {
	{
		posix_mktemp_file_file=$(
			(mktemp -u "$TMP_PATH/anmaXXXXXXXX") 2>/dev/null
		)
	} || {
		posix_mktemp_file_file=$TMP_PATH/anma$$-$(awk 'BEGIN { srand(); print int(rand()*32768) }' /dev/null)
	} || exit $?
	printf "%s" "$posix_mktemp_file_file"
}

# get the account in use in Trackma
get_account_name() {
	printf "%s" "$(printf "%s" "exit" | trackma | sed -En "s/.*using account (.*)\(.*/\1/p")" | sed "s/ $//g"
}

# gets the remote tracking service (mal, anilist, etc) used in trackma
# this is necessary because the lists differ between services
get_remote_tracker() {
	printf "%s" "$(printf "%s" "$(printf "%s" "exit" | trackma | sed -En "s/.*using account (.*)\((.*)\).*/\2/p")")"
}

get_trackma_tracker_name() {
	get_trackma_tracker_name_name="$1"
	case $get_trackma_tracker_name_name in
	"mal")
		printf "MAL"
		;;
	"anilist")
		printf "Anilist"
		;;
	esac
}

# returns a status code that trackma understands
get_trackma_status_code_function_code='get_trackma_status_code() {
	get_trackma_status_code_status_status="$1"
	case $get_trackma_status_code_status_status in
	"Watching" | "watching")
		printf "watching"
		;;
	"Plan to Watch" | "plantowatch")
		printf "plantowatch"
		;;
	"Rewatching" | "rewatching")
		printf "rewatching"
		;;
	"Dropped" | "dropped")
		printf "dropped"
		;;
	"Paused" | "paused")
		printf "paused"
		;;
	"Completed" | "completed")
		printf "completed"
		;;
	"On Hold" | "onhold")
		printf "onhold"
		;;
	"$to_mainmenu")
		printf "%s" "$to_mainmenu"
		;;
	"$SWITCH_STATUS_MSG_MENU_ENTRY")
		printf "%s" "$SWITCH_STATUS_MSG_MENU_ENTRY"
		;;
	esac
}'
eval "$get_trackma_status_code_function_code"

# Update Trackma and watch history
# ARGS in this order:
# name of the series as trackma sees it
# episode number
set_ep_as_watched() {
	ANIME_TITLE_TRACKMA="$1"
	ANIME_EP="$2"
	trackma update "$ANIME_TITLE_TRACKMA" "$ANIME_EP" >"$TRACKMA_LOGFILE" 2>&1
	# we check if theres actually something to save
	# save other shows and replace the new updated registry for this show
	PRESERVED_HISTORY=$(gawk "!/^$(sanitize_ext_regex "$ANIME_TITLE_TRACKMA").*$/" "$WATCH_HISTORY_FILE")
	# if there is content that is not replaced add a newline for the show to insert, and only in that case.
	[ -n "$PRESERVED_HISTORY" ] && printf "%b" "$PRESERVED_HISTORY\n" >"$WATCH_HISTORY_FILE" || printf "%b" "$PRESERVED_HISTORY" >"$WATCH_HISTORY_FILE"
	printf "%s\n" "$ANIME_TITLE_TRACKMA////$ANIME_EP" >>"$WATCH_HISTORY_FILE"
}

# set episode status on the anime tracker service
# ARGS in order
# TRACKMA_SHOW_INDEX the index of the show obtained from user input
set_show_status() {
	set_show_status_STATUS="$2"
	NEW_STATUS="$(get_trackma_status_code "$set_show_status_STATUS")"
	PROMPT="$update_status"
}

filter_trackma_list() {
	printf "%b" "$1" | sed -En "s/$TRACKMA_LIST_REGEX/\1/p"
}

# get all the shows the user has set as watching in their lists
# for presenting in unified way
get_watching_shows() {
	get_watching_shows_REWATCHING=""
	get_watching_shows_WATCHING="$(printf "filter %s\nls\n" "watching" | trackma)"
	get_watching_shows_WATCHING="$(filter_trackma_list "$get_watching_shows_WATCHING")"
	if [ "$TRACKER_SERVICE" = "anilist" ]; then
		# exception for anilist
		get_watching_shows_REWATCHING="$(printf "filter %s\nls\n" "rewatching" | trackma)"
		get_watching_shows_REWATCHING="$(filter_trackma_list "$get_watching_shows_REWATCHING")"
	fi
	printf "%b\n%b" "$get_watching_shows_WATCHING" "$get_watching_shows_REWATCHING"
}

# accepts a trackma entry and returns the cleaned show title
# to use with raw trackma entries only
get_show_title_function_code='get_show_title() {
	printf "%s" "$1" | sed -En "s/$TRACKMA_ENTRY_REGEX/\2/p" | sed "s/\.*$//g" | sed "s/ *$//g" | sed "s,$(printf "'"\033"'")\\[0-9;]*[a-zA-Z],," | sed "s,$(printf "'"\033"'")\\[0-9;]*[a-zA-Z],,g" | sed "s/ðŸ“£ //g" | sed "s/\[.*\]//g" | sed "s/ $//g"
}'
eval "$get_show_title_function_code"

# gets the status of a show
get_show_status() {
	if [ -n "$STATUS" ]; then
		STATUS="$(get_trackma_status_code "$STATUS")"
		printf "%s" "$STATUS"
	else
		RES_TITLE=""
		ANIME_TITLE="$1"
		while read -r trackma_code; do
			# trackma search uses regex so we need to sanitize it
			FULL_ENTRY=$(printf "filter %s\nsearch '%s'\n" "$(get_trackma_status_code "$trackma_code")" "$(sanitize_ext_regex "$ANIME_TITLE")" | trackma)
			RES="$(filter_trackma_list "$FULL_ENTRY" | head -n1)"
			[ -n "$RES" ] && RES_TITLE="$(get_show_title "$RES")"
			if [ -n "$RES_TITLE" ] && [ "$RES_TITLE" = "$ANIME_TITLE" ]; then
				STATUS="$trackma_code"
				break
			fi
		done <<EOF
$TRACKMA_STATUS_MENU_ENTRIES
EOF
		if [ -z "$STATUS" ]; then
			printf "%b\n" "ðŸ’¥ ERROR getting show status.\nPlease report this error message to the developer."
			exit 1
		fi
		printf "%s" "$STATUS"
	fi
}

# checks internet connection
connectivity_check() {
	printf "%b" "GET https://ubuntu.com HTTP/1.0\n\n" | nc ubuntu.com 443 >/dev/null 2>&1
	if [ $? -eq 0 ]; then
		true
	else
		false
	fi
}

# get shows info from Trackma
get_show_info_function_code='get_show_info() {
	if [ -n "$(printf "%s" "$1" | sed -En "/[[:digit:]]+[[:space:]]+\/[[:space:]]+[[:digit:]]+[[:space:]]+[[:digit:]]/p")" ]; then
		# raw entry
		get_show_info_SHOW_TITLE="$(get_show_title "$1")"
	else
		get_show_info_SHOW_TITLE="$1"
	fi
	get_show_info_STATUS="$(get_trackma_status_code "$2")"
	if [ "$1" = "$to_mainmenu" ]; then
		printf "%s\n" "Go back to the main menu"
	elif [ "$1" = "$SWITCH_STATUS_MSG_MENU_ENTRY" ]; then
		printf "%s\n" "Switch to another list"
	else
		get_show_info_info="$(printf "filter %s\ninfo \"%s\"" "$get_show_info_STATUS" "$get_show_info_SHOW_TITLE" | trackma | sed -n "/https/,/Status/p" | sed -e "s/<[^>]*>//g")"
		printf "\n%b" "$get_show_info_info"
	fi
}'
eval "$get_show_info_function_code"

# get the last episode from a show in the re/watching list
# used when the user plays a show from the watch or watch history
# ARGS in order
# ANIME_TITLE the title of the show as trackma sees it
get_last_show_ep() {
	# removes altname and trailing spaces, trackma cant find shows if the altname is in the query
	get_last_show_ep_ANIME_TITLE="$(printf "%s" "$1" | sed "s/\[.*\]//g" | sed "s/ $//g")"
	get_last_show_ep_FULL_ENTRY=$(get_show_entry "$get_last_show_ep_ANIME_TITLE")
	[ -z "$get_last_show_ep_FULL_ENTRY" ] && exit 1
	LAST_EP="$(printf "%b" "$get_last_show_ep_FULL_ENTRY" | sed -En "s/$TRACKMA_ENTRY_REGEX/\5/p")"
	printf "%s" "$LAST_EP"
}

# get anime series across lists or from a particular list
# this is used to play any episode from the watch history
# the status code argument should be parseable by trackma
get_show_entry() {
	play_episode_ANIME_TITLE="$1"
	STATUS="$(get_show_status "$play_episode_ANIME_TITLE")"
	# trackma search uses regex so we need to sanitize it
	get_show_entry_FULL_ENTRY=$(printf "filter %s\nsearch '%s'\n" "$(get_trackma_status_code "$STATUS")" "$(sanitize_ext_regex "$play_episode_ANIME_TITLE")" | trackma)
	get_show_entry_LIST="$(printf "%b" "$get_show_entry_FULL_ENTRY" | sed -En "s/$TRACKMA_LIST_REGEX/\1/p" | head -n1)"
	# we assume we should find a result
	[ -z "$get_show_entry_LIST" ] &&
		printf "%b\n" "ðŸ’¥ ERROR getting show entry.\nPlease report this error message to the developer." && exit 1
	printf "%b" "$get_show_entry_LIST"
}

torrentIsPlaying() {
	process_name="$(ps -p "$webtorrentpid" -o comm=)"
	if [ "$process_name" = "WebTorrent" ]; then
		true
	else
		false
	fi
}

# attempts to play a series episode
play_episode() {
	reset_logs
	while ! connectivity_check; do
		echo && line_to_remove
		pastel paint $MSG_WARN_COLOR "      ðŸŒ´ðŸ¦• NO INTERNET CONNECTION ãƒ»ãƒ»ãƒ»" && line_to_remove
		pastel paint $MSG_WARN_COLOR "      Please check your connection and press [Enter]" && line_to_remove
		read -r KEY # TODO: -n1
		[ "$KEY" = "" ] && clear_lines && continue
	done

	play_episode_ANIME_TITLE="$1"
	play_episode_ANIME_EPISODE="$2"
	PLAYER_SOURCE="$3"
	STATUS="$4"
	SHOW_TYPE="$5"
	SHOW_SYNONYMS="$6"

	if [ "$PLAYER_SOURCE" = "torrenting" ]; then
		if [ -z "$MAGNET_LINK" ]; then
			# get magnet link and play it with webtorrent-cli
			if [ -z "$NYAA_SEARCH_RES" ]; then
				echo && line_to_remove
				pastel paint $MSG_INFO_COLOR "      ðŸ˜º Searching Nyaa. Please wait..." && line_to_remove
				NYAA_SEARCH_RES="$(python3 "$NYAA_SEARCH_BIN" --title "$play_episode_ANIME_TITLE" --episode "$play_episode_ANIME_EPISODE" --quality 1080 --show-type "$SHOW_TYPE")"
				if [ "$NYAA_SEARCH_RES" = "-1" ]; then
					echo && line_to_remove
					pastel paint $MSG_WARN_COLOR "      ðŸš« We found no results." && line_to_remove
					PLAY_STATUS=$PLAY_STATUS_ERRORED
					return
				elif [ "$NYAA_SEARCH_RES" = "-2" ]; then
					echo && line_to_remove
					pastel paint $MSG_WARN_COLOR "      ðŸš« We couldn't search nyaa.si" && line_to_remove
					pastel paint $MSG_WARN_COLOR "      Please contact development to work this out:" && line_to_remove
					pastel paint $MSG_WARN_COLOR "      https://github.com/anma-dev/Anime-Manager/issues" && line_to_remove
					PLAY_STATUS=$PLAY_STATUS_ERRORED
					return
				fi
			fi
			clear_lines
			CHOICE=$(printf "%b" "{\"name\": \"$to_mainmenu\"}\n$NYAA_SEARCH_RES" | jq '.name' | sed "s/\"//g" |
				$FZF -i --prompt "Choose a search result: " --border-label "â•¢ â™£  SEARCH RESULTS (nyaa.si): $(trim "$play_episode_ANIME_TITLE") â–¶ $play_episode_ANIME_EPISODE â™£  â•Ÿ" --header "â‡… Navigation â”€ [ESC] Exit â”€ [Ctrl-L] Expand â”€ [Enter] Stream (torrenting) â–¸" --header-first --preview "printf \"\n%s\n\n%b\" {} 'â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nColor code: \nðŸŸ¢ Trusted\nðŸ”´ Remake\nâšªï¸ No category\n\nMore info: https://nyaa.si/help'" --preview-window "50,hidden,wrap" --preview-label ' Expanded view ' --bind "ctrl-l:toggle-preview")
			[ "$CHOICE" = "$to_mainmenu" ] && PLAY_STATUS="$PLAY_STATUS_EXITED" && return
			CHOICE=$(printf "%s" "$CHOICE" | sed "s/ðŸ”´ //g" | sed "s/ðŸŸ¢ //g" | sed "s/âšªï¸ //g")
			FILTERED_JSON="$(printf "%s" "$NYAA_SEARCH_RES" | sed "s/\\\ud83d\\\udd34|\\\u26aa\\\ufe0f|\\\ud83d\\\udfe2//g" | sed -En "/$(sanitize_ext_regex "$CHOICE")/p")"
			MAGNET_LINK="$(printf "%s" "$FILTERED_JSON" | jq --raw-output ".magnet")"
		fi
		if [ -z "$FILE_LIST" ]; then
			echo && line_to_remove
			pastel paint $MSG_INFO_COLOR "      ðŸ—ƒï¸  Searching for matching file (60s timeout)..." && line_to_remove
			play_episode_TORRENT_INFO="$(python3 "$GET_TORRENT_FID_BIN" --title "$play_episode_ANIME_TITLE, $(printf "%s" "$SHOW_SYNONYMS")" --magnet-link "$MAGNET_LINK" --episode "$play_episode_ANIME_EPISODE" --show-type "$SHOW_TYPE")"
			EP_DATA="$(printf "%s" "$play_episode_TORRENT_INFO" | awk -F"////" '{print $1}')"
			FILE_LIST="$(printf "%s" "$play_episode_TORRENT_INFO" | awk -F"////" '{print $2}')"
			FILE_INDEX="$(printf "%s" "$play_episode_TORRENT_INFO" | awk -F"////" '{print $3}')"
			DEBUG_MATCH_INFO=$EP_DATA
		fi

		if [ "$FILE_INDEX" = "$NYAAPY_FILE_SEL_CODE" ]; then
			if [ "$FILE_LIST" = "None" ]; then
				pastel paint $MSG_WARN_COLOR "      ðŸš« No matching files, please select another source" && line_to_remove
				MAGNET_LINK=""
				FILE_LIST=""
				PLAY_STATUS=$PLAY_STATUS_ERRORED
				return
			fi
			FILE_INDEX=$(printf "%b" "$FILE_LIST\nâ—€ Now Playing" | sed "s/\"//g" |
				$FZF -i --prompt "Choose a file: " --border-label "â•¢ â™£  ðŸ—ƒï¸  FILE SELECTION: $(trim "$play_episode_ANIME_TITLE") â–¶ $play_episode_ANIME_EPISODE â™£  â•Ÿ" --header "â‡… Navigation â”€ [ESC] Exit â”€ [Ctrl-L] Expand â”€ [Enter] Stream (torrenting) â–¸" --header-first --preview "printf \"\n%s\n\n%b\" {}" --preview-window "50,hidden,wrap" --preview-label ' Expanded view ' --bind "ctrl-l:toggle-preview" | cut -d " " -f1)
		fi

		[ "$FILE_INDEX" = "â—€" ] && FILE_LIST="" && FILE_INDEX="" && return

		if [ "$FILE_INDEX" != "$NYAA_SEARCH_ERROR_CODE" ]; then
			# run completely detached from terminal for availability
			set +m
			(nohup node "$WEBTORRENT_CLI" download "$MAGNET_LINK" --select "$FILE_INDEX" --out "$TORRENT_DOWNLOAD_DIR" --"$MEDIA_PLAYER" >"$WEBTORRENT_LOGFILE" 2>&1 &) &
			webtorrentpid=$!
			set -m
			# printf "%s" "$EP_DATA" | jq '.name' >"$CURRENTLY_PLAYING_LOGFILE"
			# remove from job queue to avoid info messages if we have to end the process with kill
			echo && line_to_remove
			pastel paint $MSG_INFO_COLOR "      ðŸš€ Torrent is playing soon (hold my beer...)" && line_to_remove
			play_episode_torrent_status=$(check_torrent_health $webtorrentpid)
			if [ "$play_episode_torrent_status" -eq $TORRENT_STATUS_ERRORED ]; then
				pastel paint $MSG_WARN_COLOR "      ðŸš« Unable to play torrent" && line_to_remove
				MAGNET_LINK=""
				PLAY_STATUS=$PLAY_STATUS_ERRORED
			else
				PLAY_STATUS=$PLAY_STATUS_OKPLAYING
			fi
		else
			pastel paint $MSG_WARN_COLOR "      ðŸš« Unable to get file index" && line_to_remove
			MAGNET_LINK=""
			FILE_LIST=""
			PLAY_STATUS=$PLAY_STATUS_ERRORED
		fi
	elif [ "$PLAYER_SOURCE" = "streaming" ]; then
		stream_providers=$(array "allanime" "zoro" "animepahe" "animeout" "gogoanime" "tenshi")
		echo && line_to_remove
		pastel paint $MSG_INFO_COLOR "      ðŸ’¡ Streaming (animdl)" && line_to_remove
		while IFS= read -r provider; do
			d_provider=$(printf '%s\n' "$provider" | array_element_decode)
			if [ "$ANIMDL_PLAYTHROUGH" -eq 0 ]; then
				play_episode_stream_fifo_write="$(posix_mktemp_file)"
				mkfifo -m 600 "$play_episode_stream_fifo_write"
				# TODO: can't stream with iina
				set +m
				nohup animdl stream "$d_provider:$play_episode_ANIME_TITLE" --range "$ANIME_EP" --player "mpv" --log-file "$ANIMDL_LOGFILE" <"$play_episode_stream_fifo_write" >"$ANIMDL_LOGFILE" 2>&1 &
				animdl_pid=$!
				set -m
				exec 3>"$play_episode_stream_fifo_write"
				pastel paint $MSG_INFO_COLOR "      ðŸ”Ž Please wait, searching the stream provider ($d_provider)..." && line_to_remove
				stream_health=10
				while [ $stream_health -gt 0 ]; do
					# check for search result prompt
					if ! grep "Select the search result" "$ANIMDL_LOGFILE" >/dev/null 2>&1; then
						if [ -z "$(sed -En "s/AV:|libmpv|A-V/&/p" "$ANIMDL_LOGFILE")" ]; then
							stream_health=$((stream_health - 1))
						else
							# stream started automatically
							PLAY_STATUS=$PLAY_STATUS_OKPLAYING
							pastel paint $MSG_INFO_COLOR "      ðŸš€ The stream is starting (hold my beer...)" && line_to_remove
							return
						fi
					else
						break
					fi
					sleep 1
				done
				if [ $stream_health -eq 0 ]; then
					pastel paint $MSG_WARN_COLOR "      ðŸš« No results found ($d_provider), next..." && line_to_remove
					PLAY_STATUS=$PLAY_STATUS_ERRORED
					# next provider
					echo "" >"$ANIMDL_LOGFILE"
					continue
				fi
				clear_lines
				results=$(sed -En '/^[[:space:]]+[0-9]+\./p' "$ANIMDL_LOGFILE")
				ANIMDL_SEARCH_INDEX="$(printf "%b" "$to_mainmenu\n$results" | sed "s/^[[:space:]]*//" | $FZF --prompt="Select a search result: " --border-label "â•¢ â™£  SEARCH RESULTS ($d_provider): $(trim "$play_episode_ANIME_TITLE") â–¶ Episode $ANIME_EP â™£  â•Ÿ" --header "â‡… Navigation â”€ [ESC] Exit â”€ [Enter] Play" --header-first | cut -d '.' -f1)"
				[ -z "$ANIMDL_SEARCH_INDEX" ] && exit 1
				[ "$ANIMDL_SEARCH_INDEX" = "$to_mainmenu" ] && PLAY_STATUS=$PLAY_STATUS_EXITED && ANIMDL_SEARCH_INDEX="" && return
				printf "%b" "$ANIMDL_SEARCH_INDEX\n" >&3
				3>&-:
				sleep 2 # wait for the stream to start
				stream_health=15
				pastel paint $MSG_INFO_COLOR "      Trying to stream with $d_provider" && line_to_remove
				while [ $stream_health -gt 0 ]; do
					if [ -z "$(sed -En "s/AV:|libmpv|A-V/&/p" "$ANIMDL_LOGFILE")" ]; then
						stream_health=$((stream_health - 1))
					else
						break
					fi
					sleep 1
				done
				if [ $stream_health -eq 0 ]; then
					echo && line_to_remove
					pastel paint $MSG_WARN_COLOR "      ðŸš« Unable to stream with $d_provider, next..." && line_to_remove
					PLAY_STATUS=$PLAY_STATUS_ERRORED
					# next provider
					echo "" >"$ANIMDL_LOGFILE"
					continue
				else
					rm "$play_episode_stream_fifo_write"
					unset stream_tmpfile
					unset stream_fifo_write
					pastel paint $MSG_INFO_COLOR "      ðŸš€ The stream is starting (hold my beer...)" && line_to_remove
					PLAY_STATUS=$PLAY_STATUS_OKPLAYING
					return
				fi
			else
				[ -z "$ANIMDL_SEARCH_INDEX" ] && exit 1
				# TODO: can't stream with iina
				set +m
				nohup animdl stream "$d_provider:$play_episode_ANIME_TITLE" --index "$ANIMDL_SEARCH_INDEX" --range "$ANIME_EP" --player "mpv" >"$ANIMDL_LOGFILE" 2>&1 &
				set -m
				sleep 2 # wait for the stream to start before presenting the streaming options
				stream_health=10
				while [ $stream_health -gt 0 ]; do
					if [ -z "$(sed -En "s/AV:|libmpv|A-V/&/p" "$ANIMDL_LOGFILE")" ]; then
						stream_health=$((stream_health - 1))
					else
						break
					fi
					sleep 1
				done
				if [ $stream_health -eq 0 ]; then
					echo && line_to_remove
					pastel paint $MSG_WARN_COLOR "      ðŸš« Unable to stream with $d_provider" && line_to_remove
					PLAY_STATUS=$PLAY_STATUS_ERRORED
					# next provider
					continue
				else
					PLAY_STATUS=$PLAY_STATUS_OKPLAYING
					return
				fi
			fi
		done <<EOF
$stream_providers
EOF
	elif [ "$PLAYER_SOURCE" = "self_magnet" ]; then
		echo && line_to_remove
		pastel paint $MSG_INFO_COLOR "      ðŸ§² Paste your magnet link and press Enter (silent input): " && line_to_remove
		stty_orig=$(stty -g)
		stty -echo
		read -r MAGNET_LINK
		stty "$stty_orig"
		MAGNET_LINK="$(printf "%s" "$MAGNET_LINK" | sed "s/;//g" | tr -d '\012')" # newline esc seq in octal
		clear_lines
		PLAYER_SOURCE="torrenting"
		play_episode "$ANIME_TITLE_TRACKMA" "$ANIME_EP" "$PLAYER_SOURCE" "$STATUS" "$SHOW_TYPE" "$SHOW_SYNONYMS"
	fi
}

check_torrent_health() {
	# allow it to start first
	sleep 2
	check_torrent_health_waitingtime=0
	check_torrent_health_checkinterval=5
	check_torrent_health_torrent_status=$TORRENT_STATUS_STALLED
	check_torrent_health_webtorrentpid="$1"
	while [ $check_torrent_health_torrent_status = "$TORRENT_STATUS_STALLED" ] && [ $check_torrent_health_waitingtime -lt $TORRENT_TMOUT ]; do
		# if the torrent is not finding peers
		# before or after download start
		lastlog="$(tail -n20 "$WEBTORRENT_LOGFILE")"
		if [ -z "$(printf "%s" "$lastlog" | sed -n "/Streaming/p")" ] || [ -n "$(printf "%s" "$lastlog" | sed -n "/Peers: 0\/0/p")" ]; then
			check_torrent_health_waitingtime=$((check_torrent_health_waitingtime + check_torrent_health_checkinterval))
			sleep $check_torrent_health_checkinterval
		else
			break
		fi
	done
	if [ $check_torrent_health_waitingtime -eq $TORRENT_TMOUT ]; then
		# kill the process
		kill -9 "$check_torrent_health_webtorrentpid" >/dev/null 2>&1
		printf "%s" "$TORRENT_STATUS_ERRORED"
	else
		printf "%s" "$TORRENT_STATUS_OKPLAYING"
	fi
}

USERNAME="$(get_account_name)"
TRACKER_SERVICE="$(get_remote_tracker)"
LOGO_MONOCHROME="H4sIAEdnvWMAA+Pi4lIAg/DUnOT83FSFknwF0sGjOSugxjya1vFoWgMYdSBzWoCciWDWRLhwC7oyhccNDbhlsZiIXaYByURkNchObAEjqLaJYATiNEDUw4Ub4DIYTkSXxWEiFhk0TyOpaYA7sQFmRgMWTgOaMJoMxIlYZInkoNiAYheYU2agZ6BnyAUAdHKfkjoCAAA="
LOGO_DEFAULT_B64="H4sIAEFjvWMAA73WO24bMRAG4F5XcMMTBHzvLuYgKVIG7mKkCVKrcKFWTaocIOdyLpJ/tPIuZ4aSFoHkQpbxYTgkxeHj6UsaKVIs5fTxL7un/xEnJDxK8gD5bOTZyDcjX418FxIhL0aejTgjP4yIzPhPtfpQyQ8T/yiJpqLuJqaiHidh+EBJjxJvKupuYirqgWJq7CRvv/8Y221o10qY6h3l7ddBWDjZfqPZtu5W1DjYbFfs1ZjrRB03ZpNxuvZm0eNNnWypM7ZO3DDZfCdzm6L62aTpypvl735LlO4zd/J7O9Oz9eIOxtymKJWt1ot2MOY2Rels8aK9GnOdqMOtbKVThWc7GHObonS2TsVdNNeJOtwnW+7Ub+7U6hWzbXdC9L16PzE1mjs1mju7oGuBgm6bBoqyB0gyUSNlfT7hBVSMFaqmbaFB9RBp1L80bDItEwWzJIxB5fMUomkMTHp8seJX0BnjgLIxkUAzlRlF3zHjjDBxfOCabvjGMRgYZUZ8myOSUc06jEyq5zDh6WXm4vGqND2fUUSGihe7yXlC2Teqppi4TLHqmruI5kcLgdFpGntxoxk4vieNeGNFU1R+oqT21Ew6rlIKeuAX0ZSfT4xOk9lZ77gOHAWFB1uSZcroZzxYdIICJbk2acV9g9NIqXZtzYddibHItVrt9aoFmgoluQ9ggW3XSqTU7gG/ScaJcrOOOJU3SaUc2hHlcbFjawPleMHWtgPhWZWbZWbJlJOOCrOt2SqNvmOIE+u+2NoDTtNRR80m1jfnvhU21wpmL6ogp8WOtwyzH4TFxfateba110ADZiUq44LVQZs/m2sFM53aIzNNVAubM9LkYktUxMsbf7fZQNVTEbW0mLsaVRc7NlZGKqLicG++2761wrb2kM/SRsEwXlFdKfUt6rawQKWpONzM2G5F1DQMm6mIWzPx8nFLZQMVUV+4mFHWpalCljK3XKIitm5WLdnS3OtqWHoMcNAWuO3SAy5ulInKhncO5iCqC++DpMfLxsvTZIMU3SeOuoyFbWfPhvGKmsN7AT+KagvzHLf2kHBzcZ8/Wxk5v18En8qtPrXCRdPE4K5MMgYSOSYsgoeA58z/APGbmLr7FAAA"
LOGO_XMAS_B64="H4sIALYVt2MAA8XXPW4UQRAF4NynWC6A+r9nVGcgBgkngMiwkAAhk22wAQFCckLqu8EFOAKvZtbWdvWb8RpYO7DX+lRb1d1T3dM+v/SvX8ZBgoScpx93cXZ+LG6OQn8ifG4wVeBbhu8YvmH4nuGFxcAKBTLOCT8x7Aqxr+Ovx8T0UOgeCAPrz5Mga9rHRV9PhL+vv++sRxas+Iyh3UoTfjgGnfbtF4a2+oQvGNrdPeEri9q3Hxk+YdhVT9NCfbtmbo9WnoH18wnQjwX488dXztt7MU3SFfQ81vPMq7xjbAsOdYq94mwzr0UvZLZTWcoc6Zj3vBDd5SZbbSm2jjTzGtvME/7aHheb+CgSL5foaqxHd7lZR0+4EEsyr/JRBQvv/sL3yjrb9ShsC5XACwaeeZVpElsw80bPvNH/gruCvKMz3ytr/G+ZE98re7ZJJj5jaEfBkVwt/guSkTrabetMk3QFeWws4smxGqsEzpElGSR1BWOWQh4RuLIUQQYWHWTsM0fxdC5wOhknPrDk8LgQn0j+UNGP3WhUy0I0W4CQcFwx1xdGn13fnuSkx93S9ysT8MlWRp2tjB9mt9n9iNsriQ8ON3qWf3I7Gl/w/xSJxnU1ZNLOi54ksBWevasKZR3m/ezdGsCHFe/y4LNfedxWoX20GyWyrbvoRaJneSbvqkIDi46z2zmpR/K8b7zJgz7FFTiana3qVEm0l5ht9rjo4yDRPL4bNLlxCNSZd4YxvrrMTUEvY5Y4tO8BoFfcHINBonnwjuMwSnJ3I142M7YjVS6S7H5Nw128NVwlhbZgFVxJkz0LlZMkexQqe8JFBjfz1jCi2265RROLd8CwyLZVUtrzxmDmsViNYscc78tYJttBKex5Y9CRWC8VE7evtGUuVbnJ7KRg2vbwV87Kh7Fx3GOb94AP54ffJUq2/07dzU3uKsVJbs+kWzSx5ZavWsYls+cseZBsu1Q5K28YmtgkOEuybd0lhgWSBOwltx2NCwn2crbdD8a2zdlm1oetKXrGxO3tAPcObJjcNrpinlPY2NSnCDhP4jwOy6FPEtBfXpNsDDqSAicwZmhbVxkztP0f8GKqXWZgJrE4lhMaxCySMqZiexrXJ30G3TjATqObghEvZY39bHDQcu4Q8VP0608Nai+2kbgWxC4SOA3KHyIuRU4L/QEhaktX3RcAAA=="
LOGO_HALLOWEEN_B64="H4sIADEPt2MAA8XXO24UQRAG4NynWC6A+j09qgtwAwJIAJHxChCPbCUcECE5IeUg3AYuwBH4a2ZtbVf/PV4DNoG91qfaqu6e6p724w/+6aNYJUjIeflxL88en4q7k9DfEj40mCbgc4YvGD5j+JrhS4uBFQpknAu+ZdgVYl/HX/8T012huyMMrD9vBVnT3i3++vblk3E/keAFHzB8wvDNSRiBHxl21SOrHln1SDayqyO0+2vB9wztRuaoffuK4T2GdpoL/vp28Z25PVp5BtbPt4B+LsAfXz9z3t+IaZKuoOexnmfe5HPGtmCdltgLzjbzVvQgs53KKHOkYz7wILrLTXbVKHaaaeYttpkX/Lk/LTbxUSReLtHV2I7ucrOOXnAQSzJv8kkFC+/+wvfKNtv1KGwLlcALBp55k2kSWzDzRs+80f+Au4K8ozPfK1v8d5kT3ysHtkkWPmNoR8GRXC3+CZKROtpt20yTdAV5bCziybEaJwmcI0tSJXUFY5ZCHhF4YimCVBYdZO4zR/F0LnA6GSc+sOTwOIhPJH+Y0I/daFTLIJotQEg4rpjrC6PPrm9PctLjbun7lQn4ZCujzlbG19Vtdj/j9krig8ONnuVf3I7GF/w/RaJxVw2ZtPPQkwS2wqt3VaGsw7xfvVsDeN3wLg8++5XHbRXaR7tZItu6Qy8SPcuzeFcVGlh0XN3OST2S533pTR70Ka7A0exsVadKor3EbLPHoc9Vonl8l2hy4xCYVj43jPFNY24KepmzxNq+B4BecXcKBonmwTuOdZbkrke8bFZsR6pcJNn9mup1vDc8SQptwUlwJU32LFROkuxRqOwJF6lu5b1hRLfdcoUmFu+AOmTbKikdeGcw81isRrFjjjdlLJPtoBQOvDPoSKyXCRO3r7Qxl0m5yeykYNr28FfOysexcT5gm/eIj+eH3yVKtv9OXc9N7kmKk9yeSVdoYssVX7SMS2bPWXKVbLtUOSvvGJrYJDhLsm3dEcMCSQL2ktuOxoUEeznb7gdj2+ZsM+vD1hQ9Y+L2doB7BzZMbhtdMa8pbGzqUwScJ3Edh+XQJwnoL69JdgYdSYETGDO0rauMGdr+D3gxTV1mYCaxOJYTGsQskjKmYnsa1yd9Bt04wE6jm4IRL2WNfWewajl3jPgp+vX7BrUX20hcC2IXCVwG5Y8RlyKnhc5+AyB6tXLeFwAA"
SWITCH_STATUS_MSG_MENU_ENTRY="ðŸ”„ SWITCH STATUS"

if [ "$OSTYPE" = "Darwin" ]; then
	MEDIA_PLAYER="iina"
else
	MEDIA_PLAYER="mpv"
fi

export BACK_MSG
export SWITCH_STATUS_MSG_MENU_ENTRY
export TRACKMA_ENTRY_REGEX
export TRACKMA_LOGFILE

# fzf colors
export FZF_DEFAULT_OPTS='--color=fg:#d0d0d0,bg:-1,hl:#ba9c41 --color=fg+:#ffbf00,bg+:#262626,hl+:#5fd7ff --color=info:#d0d0d0,prompt:#ffbf00,pointer:#af5fff --color=marker:#87ff00,spinner:#af5fff,header:#d7005f --color=label:#ffbf00'

# common fzf args
FZF="fzf -0 --ansi --cycle --ellipsis (...) --height 50% --border rounded --pointer ðŸ‘‰ --margin 5% --padding=1,0,0,0 --border-label-pos -1"
# regex for extracting trackma results
# gets the whole series list
TRACKMA_LIST_REGEX="^\|[[:space:]]+([0-9]+[[:space:]]+.*[0-9]+[[:space:]]+\/[[:space:]]+[0-9?]+[[:space:]]+[0-9]+).*\|$"
# gets the multiple parts of an entry, by matching groups
#	1- list index
#	2- series title
#	3- unused
#	4- last watched ep
#	5- end episode
#	6- series score
# Caveat: removing possesive quantifier makes the \2 match to end
# with a residual dot, we will have to remove it with sed.
# We also have no way of making a distinction between series that
# actually end with a dot from a residual dot.
TRACKMA_ENTRY_REGEX="^([[:digit:]]+)[[:space:]]+(([^.]*|.*))\.*[[:space:]]+([[:digit:]]+)[[:space:]]\/[[:space:]]([[:digit:]]+|\?)[[:space:]]+([[:digit:]]+)$"

# print the logos
tput clear
[ "$monochrome_logo" -eq 1 ] && LOGO_B64=$LOGO_MONOCHROME || LOGO_B64=$LOGO_DEFAULT_B64
# special dates
[ "$DATE_MONTH" -eq 10 ] && [ "$DATE_DAY" -eq 31 ] && LOGO_B64=$LOGO_HALLOWEEN_B64
[ "$DATE_MONTH" -eq 12 ] && [ "$DATE_DAY" -eq 24 ] || [ "$DATE_DAY" -eq 25 ] && LOGO_B64=$LOGO_XMAS_B64
# [ $DATE_MONTH -eq 12 ] && [ $DATE_DAY -eq 31 ] && LOGO_B64=$LOGO_NEWYEAR_B64

if [ $debug -eq 0 ]; then
	if [ $small_logo = 0 ]; then
		printf "%b\n" "$(
			base64 -d <<EOF | gunzip
$LOGO_B64
EOF
		)"
	else
		printf "%s\n" "      â™£ï¸  â”€â”€ ANIME MANGER â”€â”€ â™£ï¸"
	fi
fi

pastel paint $TITLE_COLOR "      ðŸ¿ Play and Track Anime Series from Your Terminal"
pastel paint $MSG_HELP_COLOR "         Use arrow keys/mouse scroll to navigate. Type to filter results" && echo
pastel paint $SUBTITLE_COLOR "      ðŸ‘¤ Account â”€ ${USERNAME} â”‚"
# mainmenu entries
watch_history="ðŸ‘ï¸  Watch History"
watch="ðŸ“º Watch"
watch_random="ðŸ”€ Watch Random"
add_show="ðŸ§© Add Series"
list="ðŸ“™ Lists"
update_status="ðŸ”„ Update Series Status"
score_show="ðŸ‘ Score Series"
to_submenu="ðŸ‡ SUBMENU â–¸"
# submenu entries
delete_show="Delete Series ðŸ—‘ï¸"
watch_rand_airing="Watch Random Series (Currently Airing ðŸ“£)"
list_airing="List Series (Currently Airing ðŸ“£)"
update_episodes="Update Series Episodes ðŸ”„"
set_altname="Set Alternative Name ðŸ“"
pull="Pull Lists from Remote â†“"
push="Push Local Lists to Remote â†‘"
list_by_score="List Series (Sort by Rating ðŸŒŸ)"
to_mainmenu="â—‚ MAINMENU"

MAIN_MENU_HELPTEXT="
ðŸ‡  Follow the white rabbit for more menu options
ðŸ‘  Rate a series or change a series score. It syncs immediately with the tracking service
ðŸ”„  Update the status of a series. It syncs immediately with the tracking service
ðŸ“™  Browse all your lists. It can also play series
ðŸ§©  Add a new series to your watching list
ðŸ”€  Select one random series from your currently watching lists (watching, rewatching) and open it for streaming
ðŸ“º  Opens a list with all your currently watching series (watching, rewatching) and lets you pick one for streaming
ðŸ‘ï¸  Your watching history with series titles and episode count
"

SUB_MENU_HELPTEXT="
ðŸŒŸ  Display your lists in descending order by score
â†‘  Upload your local progress to your tracking service.
â†“  Download your remote progress and update your local lists.
ðŸ“  Set the alternative name for a series
ðŸ”„  Update your progress on a series
ðŸ“£  Display your lists by showing only those shows currently airing
ðŸ“£  Start watching a random series episodes that is also currently airing
ðŸ—‘ï¸  Delete a series from your lists. You will lose all your progress on that series
"
MENU_HELPTEXT=$MAIN_MENU_HELPTEXT
WATCH_HISTORY_FILE="${CONFIG_PATH}/$(printf "%s" "$USERNAME" | sed -E 's/[^a-zA-Z0-9]//g')-watch-history"
[ ! -f "$WATCH_HISTORY_FILE" ] && touch "$WATCH_HISTORY_FILE"

# prepare the menus
PROMPT=""
MAINMENU_ENTRIES="$watch_history\n$watch\n$watch_random\n$add_show\n$list\n$update_status\n$score_show\n$to_submenu"
SUBMENU_ENTRIES="$delete_show\n$watch_rand_airing\n$list_airing\n$update_episodes\n$set_altname\n$pull\n$push\n$list_by_score\n$to_mainmenu"
MAINMENU_TITLE="MAIN MENU"
SUBMENU_TITLE="SUB ðŸ° MENU"
MENU_ENTRIES=$MAINMENU_ENTRIES
MENU_TITLE=$MAINMENU_TITLE
if [ "$TRACKER_SERVICE" = "anilist" ]; then
	# exception for anilist
	TRACKMA_STATUS_MENU_ENTRIES="$(printf "%b" "Watching\nCompleted\nRewatching\nPaused\nDropped\nPlan to Watch" | sort -r)"
else
	TRACKMA_STATUS_MENU_ENTRIES="$(printf "%b" "Watching\nCompleted\nOn Hold\nDropped\nPlan to Watch" | sort -r)"
fi

# main loop
while true; do
	[ -z "$PROMPT" ] &&
		clear_modifiers &&
		PROMPT=$(printf "%b" "$MENU_ENTRIES" | $FZF -i --prompt="Choose an action: " --border-label "â•¢ â™£  $MENU_TITLE â™£  â•Ÿ" --header "â‡… Navigation â”€ [ESC] Exit â”€ [Ctrl-L] Help â”€ [Enter] Select" --header-first --preview "printf \"%s\n\" \"$MENU_HELPTEXT\"" --bind "ctrl-l:toggle-preview" --preview-window "50,hidden,wrap" --preview-label "Help")
	case $PROMPT in
	"$to_mainmenu")
		MENU_ENTRIES=$MAINMENU_ENTRIES
		MENU_TITLE=$MAINMENU_TITLE
		MENU_HELPTEXT=$MAIN_MENU_HELPTEXT
		clear_modifiers
		;;
	"$to_submenu")
		MENU_ENTRIES=$SUBMENU_ENTRIES
		MENU_TITLE=$SUBMENU_TITLE
		MENU_HELPTEXT=$SUB_MENU_HELPTEXT
		clear_modifiers
		;;
	"$watch_history")
		clear_modifiers
		if [ ! -s "$WATCH_HISTORY_FILE" ]; then
			SEL=$(printf "Your watch history is empty\n%s" "$to_mainmenu" | $FZF -i --border-label "â•¢ â™£  YOUR WATCH HISTORY â™£  â•Ÿ" --header "â‡… Navigation â”€ [ESC] Exit" --header-first)
		else
			HIST=$(column -t -s "////" "$WATCH_HISTORY_FILE")
			HIST="$to_mainmenu\n$HIST"
			SEL=$(printf "%b" "$HIST" | $FZF -i --prompt="Select an anime: " --border-label "â•¢ â™£  WATCH HISTORY â™£  â•Ÿ" --header "[Enter] Play â–¸ new episode" --header "â‡… Navigation â”€ [ESC] Exit â”€ [Enter] Play â–¸" --header-first --tac --no-sort)
			[ "$SEL" = "$to_mainmenu" ] && PROMPT=$to_mainmenu && continue
			ANIME_TITLE_TRACKMA=$(printf "%s" "$SEL" | sed -En "s/^(.*)[[:space:]]+([[:digit:]]+)$/\1/p" | sed "s/[[:space:]]*$//")
			LAST_SHOW_EP="$(get_last_show_ep "$ANIME_TITLE_TRACKMA")"
			[ -z "$LAST_SHOW_EP" ] && printf "couldnt get last series episode" && exit 1
			LAST_WATCHED_EP=$(printf "%s" "$SEL" | sed -En "s/^(.*)[[:space:]]+([[:digit:]]+)$/\2/p" | sed "s/[[:space:]]*$//")
			# only increment if it's not the last episode of the show
			# if we don't know the last aired apisode just attempt playing the next episode
			[ "$LAST_SHOW_EP" = "?" ] || [ "$LAST_WATCHED_EP" -lt "$LAST_SHOW_EP" ] && ANIME_EP=$((LAST_WATCHED_EP + 1)) || ANIME_EP="1"
			STATUS="$(get_show_status "$(printf "%s" "$ANIME_TITLE_TRACKMA" | sed "s/\[.*\]//g" | sed "s/ $//g")")"
			PROMPT="$watch"
		fi
		;;
	"$watch_random")
		RANDOM_ANIME=1
		PROMPT=$watch
		;;
	"$watch_rand_airing")
		RANDOM_AIRING=1
		PROMPT=$watch
		;;
	"$watch")
		# This section plays shows currently being watched by default or one specified show
		if [ -z "$ANIME_TITLE_TRACKMA" ] && [ -z "$ANIME_EP" ]; then
			FULL_INFO=$(get_watching_shows)

			if [ ! "$FULL_INFO" ]; then
				FULL_INFO="Your watching list is empty"
				CHOICE=$(printf "%s\n%s" "$FULL_INFO" "$to_mainmenu" |
					$FZF -i --prompt "Choose an anime to watch: " --border-label "â•¢ â™£  YOUR $(
						if [ "$TRACKER_SERVICE" = "anilist" ]; then
							printf "%s" "(RE)WATCHING LISTS"
						else
							printf "%s" "WATCHING LIST"
						fi
					) â™£  â•Ÿ" --header "â‡… Navigation â”€ [ESC] Exit â”€ [Enter] Play â–¸" --header-first)
				clear_modifiers
				continue
			fi

			# remove character sequences and add an emoji next to shows currently airing
			FULL_INFO=$(printf '%s\n' "$FULL_INFO" | sed "s,$(printf '\033')\\[[0-9;]*[a-zA-Z],ðŸ“£ ," | sed "s,$(printf '\033')\\[[0-9;]*[a-zA-Z],,g" | sed -E "/ðŸ“£/ s/(.*)\.{3}(.*)/\1\2/")

			if [ "$RANDOM_ANIME" -eq 1 ]; then
				CHOICE=$(printf "%s" "$FULL_INFO" | shuf -n 1)
			elif [ "$RANDOM_AIRING" -eq 1 ]; then
				# format and filter airing shows, select one randomly
				CHOICE=$(printf "%s" "$FULL_INFO" | sed "s,$(printf '\033')\\[[0-9;]*[a-zA-Z],ðŸ“£ ," | sed -n "/ðŸ“£/p" | shuf -n 1)
			else
				FULL_INFO="$(printf "%s" "$FULL_INFO" | sort -r --version-sort)"
				CHOICE=$(printf "%s\n%s" "$to_mainmenu" "$FULL_INFO" |
					$FZF -i --prompt "Choose an anime to watch: " --border-label "â•¢ â™£  YOUR $(
						if [ "$TRACKER_SERVICE" = "anilist" ]; then
							printf "%s" "(RE)WATCHING LISTS"
						else
							printf "%s" "WATCHING LIST"
						fi
					) â™£  â•Ÿ" --header "â‡… Navigation â”€ [ESC] Exit â”€ [Enter] Play â–¸" --header-first)
			fi

			[ "$CHOICE" = "$to_mainmenu" ] && PROMPT=$to_mainmenu && continue

			if [ ! "$CHOICE" ]; then
				echo && line_to_remove
				pastel paint $MSG_WARN_COLOR "      We couldn't find any series of this type!" && line_to_remove
				sleep 2
				clear_lines
				clear_modifiers
				continue
			fi
			TRACKMA_INDEX="$(printf "%s" "$CHOICE" | sed -En "s/$TRACKMA_ENTRY_REGEX/\1/p")"
			ANIME_TITLE_TRACKMA=$(get_show_title "$CHOICE")
			STATUS="$(get_show_status "$(printf "%s" "$ANIME_TITLE_TRACKMA" | sed "s/\[.*\]//g" | sed "s/ $//g")")"
			TRACKMA_SHOW_INDEX=$(printf "%s" "$CHOICE" | cut -d " " -f1)
			LAST_WATCHED_EP="$(printf "%s" "$CHOICE" | sed -En "s/.*[[:space:]]+([0-9]*) \/.*/\1/p")"
			LAST_SHOW_EP="$(get_last_show_ep "$ANIME_TITLE_TRACKMA")"

			[ -z "$LAST_SHOW_EP" ] && printf "Couldn't get last series episode" && exit 1
			# if we just don't know what the last episode is we increment anyways and give it a try
			[ "$LAST_SHOW_EP" = "?" ] || [ "$LAST_WATCHED_EP" -lt "$LAST_SHOW_EP" ] && ANIME_EP=$((LAST_WATCHED_EP + 1)) || ANIME_EP="1"
		fi

		[ -z "$STATUS" ] && printf "Couldn't get series status" && exit 1

		if [ "$(get_trackma_status_code "$STATUS")" != "$(get_trackma_status_code "Watching")" ] && [ "$(get_trackma_status_code "$STATUS")" != "$(get_trackma_status_code "Rewatching")" ]; then
			NEW_STATUS="Watching"
			PLAY_OPTIONS_MENU="â–¶ï¸  Play\nðŸ”„ Set series status as watching + Play"
			if [ "$STATUS" = "$(get_trackma_status_code "Completed")" ]; then
				PLAY_OPTIONS_MENU="â–¶ï¸ Play\nðŸ”„ Set series status as watching + Reset watched episodes + Continue Playing"
				RESET_EPISODES=1
				if [ "$TRACKER_SERVICE" = "anilist" ]; then
					NEW_STATUS="Rewatching"
					PLAY_OPTIONS_MENU="â–¶ï¸ Play\nðŸ”„ Set series status as rewatching + Continue Playing"
				fi
			else
				RESET_EPISODES=0
			fi

			SEL_PLAY_OPTION=$(printf "%b\n%s" "$PLAY_OPTIONS_MENU" "$to_mainmenu" |
				$FZF -i --prompt "Choose an option: " --border-label "â•¢ â™£  PLAY OPTIONS â™£  â•Ÿ" --header "â‡… Navigation â”€ [ESC] Exit â”€ [Enter] Select" --header-first | cut -d " " -f1)
			[ "$SEL_PLAY_OPTION" = "â—‚" ] && clear_modifiers && continue
			if [ "$SEL_PLAY_OPTION" = "ðŸ”„" ]; then
				printf "filter %s\nstatus '%s' %s" "$(get_trackma_status_code "$STATUS")" "$TRACKMA_INDEX" "$(get_trackma_status_code "$NEW_STATUS")" | trackma >"$TRACKMA_LOGFILE" 2>&1
				if [ $RESET_EPISODES -eq 1 ]; then
					printf "filter %s\nupdate '%s' %s" "$(get_trackma_status_code "$STATUS")" "$ANIME_TITLE_TRACKMA" "0" | trackma >>"$TRACKMA_LOGFILE"
					ANIME_EP="1"
					LAST_WATCHED_EP="0"
				fi
				STATUS=$NEW_STATUS
				# update series index after changing lists
				TRACKMA_INDEX="$(printf "%s" "filter %s\nsearch '%s'\n" "$(get_trackma_status_code "$STATUS")" "$(sanitize_ext_regex "$ANIME_TITLE_TRACKMA")" | trackma | sed -En "s/$TRACKMA_ENTRY_REGEX/\1/p")"
			fi
		fi

		# We query trackma again because we want official english and romaji titles
		ANI_INFO=$(printf "filter %s\ninfo %s\n" "$STATUS" "$TRACKMA_INDEX" | trackma)
		ANIME_TITLE_RO="$(printf "%s" "$ANI_INFO" | sed -n "/Romaji/p" | cut -d ":" -f2 | sed "s/ //")"
		ANIME_TITLE_EN="$(printf "%s" "$ANI_INFO" | sed -n "/English/p" | cut -d ":" -f2 | sed "s/ //")"
		# give preference to Romaji, then Japanese, then English titles, as this gives better matching
		if [ -n "$ANIME_TITLE_RO" ] && [ "$ANIME_TITLE_RO" != "None" ]; then
			ANIME_TITLE=$ANIME_TITLE_RO
		else
			ANIME_TITLE=$ANIME_TITLE_TRACKMA
		fi
		SHOW_TYPE=""
		SHOW_SYNONYMS=""
		# player loop
		PLAY_METHOD_MENU_OPT=""
		PLAYER_SOURCE=""
		while true; do
			if [ -z "$PLAYER_SOURCE" ]; then
				PLAY_METHOD_MENU="ðŸ˜º Search nyaa.si (torrenting)\nðŸ§² Paste a magnet link (torrenting)\nðŸ’¡ Stream with animdl (streaming)\n$to_mainmenu"
				if [ "$RANDOM_ANIME" -eq 1 ]; then
					MENU_LABEL="SELECT SOURCE: ðŸ”€ $(trim "$ANIME_TITLE_TRACKMA") â–¶ $ANIME_EP"
				elif [ "$RANDOM_AIRING" -eq 1 ]; then
					MENU_LABEL="SELECT SOURCE: ðŸ“£ $(trim "$ANIME_TITLE_TRACKMA") â–¶ $ANIME_EP"
				else
					MENU_LABEL="SELECT SOURCE: $(trim "$ANIME_TITLE_TRACKMA") â–¶ $ANIME_EP"
				fi
				PLAY_METHOD_MENU_OPT="$(printf "%b" "$PLAY_METHOD_MENU" | $FZF -i --prompt="Select a source: " --border-label "â•¢ â™£  $MENU_LABEL â™£  â•Ÿ" --header "â‡… Navigation â”€ [ESC] Exit â”€ [Enter] Select" --header-first | cut -d " " -f1)"
				if [ "$PLAY_METHOD_MENU_OPT" = "â—‚" ]; then
					PROMPT="$to_mainmenu"
					clear_modifiers
					break
				elif [ "$PLAY_METHOD_MENU_OPT" = "ðŸ’¡" ]; then
					PLAYER_SOURCE="streaming"
				elif [ "$PLAY_METHOD_MENU_OPT" = "ðŸ˜º" ]; then
					PLAYER_SOURCE="torrenting"
				elif [ "$PLAY_METHOD_MENU_OPT" = "ðŸ§²" ]; then
					PLAYER_SOURCE="self_magnet"
				fi
			fi

			if [ -z "$SHOW_TYPE" ]; then
				SHOW_INFO="$(get_show_info "$ANIME_TITLE_TRACKMA" "$STATUS")"
				if printf "%s" "$SHOW_INFO" | grep "Type: " >/dev/null 2>&1; then
					SHOW_TYPE="$(printf "%b" "$SHOW_INFO" | grep "Type: " | awk -F": " '{print $2}')"
				fi
			fi
			if [ -z "$SHOW_SYNONYMS" ]; then
				SHOW_INFO="$(get_show_info "$ANIME_TITLE_TRACKMA" "$STATUS")"
				if printf "%s" "$SHOW_INFO" | grep "Synonyms: " >/dev/null 2>&1; then
					SHOW_SYNONYMS="$(printf "%b" "$SHOW_INFO" | grep "Synonyms: " | awk -F": " '{print $2}')"
					SHOW_SYNONYMS="$ANIME_TITLE_TRACKMA, $ANIME_TITLE_EN, $(printf "%s" "$SHOW_SYNONYMS" | sed "s/[]'[]//g")"
				fi
			fi

			# finally, play the show and hope for the best
			play_episode "$ANIME_TITLE" "$ANIME_EP" "$PLAYER_SOURCE" "$STATUS" "$SHOW_TYPE" "$SHOW_SYNONYMS"

			# block until the play status is set up
			while [ "$PLAY_STATUS" -eq "$PLAY_STATUS_WAITING" ]; do
				sleep 1
			done
			if [ "$PLAY_STATUS" -eq "$PLAY_STATUS_ERRORED" ]; then
				# fatal error, go back to mainmenu
				echo && line_to_remove
				if [ "$PLAYER_SOURCE" = "streaming" ]; then
					pastel paint $MSG_ERR_COLOR "      ðŸ’¥ Unable to play the episode via streaming." && line_to_remove
				else
					pastel paint $MSG_ERR_COLOR "      ðŸ’¥ Unable to stream the episode via torrenting." && line_to_remove
				fi
				printf "%s\n" "      [Enter]  Source selection â–¶" && line_to_remove
				# recovery menu loop
				while true; do
					read -r KEY # TODO: -n1
					if [ "$KEY" = "" ]; then
						PLAYER_SOURCE=""
						NYAA_SEARCH_RES=""
						# dont clear modifiers let the user select another source
						clear_lines
						break # to player loop
					fi
				done
				continue
			elif [ "$PLAY_STATUS" = "$PLAY_STATUS_EXITED" ]; then
				clear_lines
				clear_modifiers
				break
			fi
			clear_lines
			ANIME_MENU_TITLE=$(trim "$ANIME_TITLE_TRACKMA")
			# configure the menu entries
			if [ "$LAST_SHOW_EP" != "?" ] && [ "$ANIME_EP" -eq "$LAST_SHOW_EP" ]; then
				PLAYING_MENU="ðŸ Set as Watched + Move to Completed list"
				[ "$SHOW_TYPE" != "movie" ] && ANIME_MENU_TITLE="ðŸ END! â”€ $ANIME_MENU_TITLE"
			else
				PLAYING_MENU="â­ï¸  Set as Watched + Play next\nâœ… Set as Watched"
			fi
			# player reset options
			if [ "$PLAYER_SOURCE" = "torrenting" ]; then
				PLAYING_MENU="$PLAYING_MENU\nðŸ”Ž Select another search result\nðŸ’¡ Switch to streaming\nðŸ™ˆ Unexpected? Select another file â–¸"
			elif [ "$PLAYER_SOURCE" = "streaming" ]; then
				PLAYING_MENU="$PLAYING_MENU\nðŸ”Ž Select another search result\nðŸ˜º Switch to torrenting"
			fi
			OPT=$(printf "%b" "$PLAYING_MENU\n$to_mainmenu" |
				$FZF -i --prompt="Choose an action: " --border-label "â•¢ ðŸ“º  NOW PLAYING$([ -n "$SHOW_TYPE" ] && printf "%s" " ($SHOW_TYPE)" | tr '[:lower:]' '[:upper:]') â”€ ${ANIME_MENU_TITLE}$([ -n "$SHOW_TYPE" ] && [ "$SHOW_TYPE" != "movie" ] && printf " â–¶ Episode %s" "$ANIME_EP") â•Ÿ" --header "â‡… Navigation â”€ [ESC] Exit â”€ [Enter] Select" --header-first --preview "printf \"%s\" '$DEBUG_MATCH_INFO' | jq | bat -p --language=json" --bind "ctrl-l:toggle-preview" --preview-label "STREAM DEBUG" --preview-window "50,hidden,wrap")
			OPT=$(printf "%s" "$OPT" | cut -d " " -f1)
			[ "$OPT" = "â—‚" ] && PROMPT="$to_mainmenu" && clear_modifiers && break
			if [ "$OPT" = "âœ…" ]; then
				set_ep_as_watched "$ANIME_TITLE_TRACKMA" "$ANIME_EP"
				clear_modifiers
				break
			elif [ "$OPT" = "â­ï¸" ]; then
				set_ep_as_watched "$ANIME_TITLE_TRACKMA" "$ANIME_EP"
				if [ "$PLAYER_SOURCE" = "torrenting" ]; then
					NYAA_SEARCH_RES="" # will query nyaa again
					MAGNET_LINK=""
					FILE_LIST=""
				elif [ "$PLAYER_SOURCE" = "streaming" ]; then
					ANIMDL_PLAYTHROUGH=1
				fi
				PLAY_METHOD_MENU_OPT=""
				ANIME_EP=$((ANIME_EP + 1))
			elif [ "$OPT" = "ðŸ" ]; then
				set_ep_as_watched "$ANIME_TITLE_TRACKMA" "$ANIME_EP"
				set_show_status "$TRACKMA_SHOW_INDEX" "Completed"
				break
			elif [ "$OPT" = "ðŸ’¡" ]; then
				PLAYER_SOURCE="streaming"
				MAGNET_LINK=""
				NYAA_SEARCH_RES=""
			elif [ "$OPT" = "ðŸ˜º" ]; then
				PLAYER_SOURCE="torrenting"
			elif [ "$OPT" = "ðŸ”Ž" ]; then
				[ "$PLAYER_SOURCE" = "streaming" ] && ANIMDL_PLAYTHROUGH=0
				[ "$PLAYER_SOURCE" = "torrenting" ] && NYAA_SEARCH_RES="" && MAGNET_LINK=""
			elif [ "$OPT" = "ðŸ™ˆ" ]; then
				FILE_INDEX="$NYAAPY_FILE_SEL_CODE"
			fi
		done
		set +u nounset
		if ps "$animdl_pid" >/dev/null 2>&1; then
			kill -9 "$animdl_pid"
		fi
		set -u nounset
		;;
	"$add_show")
		STATUS="Plan to Watch"
		echo && line_to_remove
		printf "      ðŸ§© What anime do you plan to watchâ” \n         ðŸ‘‰ " && line_to_remove
		read -r ANIME
		ANIME="$(printf "%s" "$ANIME" | sed -E 's/[^a-zA-Z0-9 ]//g')"
		clear_lines
		[ -z "$ANIME" ] && clear_modifiers && continue
		tmpfile="$(posix_mktemp_file)"
		fifo_write="$(posix_mktemp_file)"
		mkfifo -m 600 "$fifo_write"
		trackma <"$fifo_write" >"$tmpfile" 2>"$TRACKMA_LOGFILE" &
		exec 3>"$fifo_write"
		printf "%b" "filter $(get_trackma_status_code "$STATUS")\nadd '$ANIME'\n" >&3
		pastel paint $MSG_INFO_COLOR "      ðŸ”Ž Searching the anime tracker ($TRACKER_SERVICE), please wait..." && line_to_remove
		while ! grep "Choose" "$tmpfile" >/dev/null 2>&1; do :; done
		clear_lines
		results=$(sed -En '/^[0-9]+\:/p' "$tmpfile")
		choice="$(printf "%b" "$results" | $FZF --prompt="Choose the anime to add: " --border-label "â•¢ â™£  ADD NEW ANIME ($STATUS list) â™£  â•Ÿ" --header "â‡… Navigation â”€ [ESC] Exit â”€ [Enter] Add" --header-first | cut -d ':' -f1)"
		[ -z "$choice" ] && exit
		printf "%b" "$choice\n" >"$fifo_write"
		rm "$fifo_write" "$tmpfile"
		unset tmpfile
		unset fifo_write
		3>&-:
		clear_modifiers
		;;
	"$delete_show")
		STATUS=$(printf "%b\n%s" "$TRACKMA_STATUS_MENU_ENTRIES" "$to_submenu" | $FZF -i --prompt="Choose a status: " --border-label "â•¢ â™£  DELETE SERIES (Status select) â™£  â•Ÿ" --header "â‡… Navigation â”€ [ESC] Exit â”€ [Enter] Select" --header-first)
		[ "$STATUS" = "$to_submenu" ] && PROMPT="$to_submenu" && continue
		STATUS=$(get_trackma_status_code "$STATUS")
		FULL_LIST=$(printf "filter %s\nls" "$STATUS" | trackma | sed -En "s/$TRACKMA_LIST_REGEX/\1/p" | sed "s,$(printf '\033')\\[[0-9;]*[a-zA-Z],ðŸ“£ ," | sed "s,$(printf '\033')\\[[0-9;]*[a-zA-Z],,g" | sed -E "/ðŸ“£/ s/(.*)\.{3}(.*)/\1\2/" | sort -r --version-sort)
		[ -z "$FULL_LIST" ] && FULL_LIST="No entries found in this list..."
		FULL_LIST="$FULL_LIST\n$to_submenu\n$SWITCH_STATUS_MSG_MENU_ENTRY"
		TRACKMA_SHOW_INDEX=$(printf "%b" "$FULL_LIST" |
			$FZF -i --prompt="Choose a series to DELETE: " --border-label "â•¢ â™£  DELETE SERIES â™£  â•Ÿ" --header "â‡… Navigation â”€ [ESC] Exit â”€ [Enter] Delete" --header-first | cut -d" " -f1)
		[ "$TRACKMA_SHOW_INDEX" = "ðŸ‡" ] && PROMPT="$to_submenu" && continue
		[ "$TRACKMA_SHOW_INDEX" = "ðŸ”„" ] && continue
		printf "filter %s\ndelete %s\ny" "$STATUS" "$TRACKMA_SHOW_INDEX" | trackma >"$TRACKMA_LOGFILE" 2>&1
		;;
	"$update_episodes" | "$update_status")
		if [ "$PROMPT" = "$update_episodes" ]; then
			menuitem="$to_submenu"
		else
			menuitem="$to_mainmenu"
		fi
		if [ -z "$NEW_STATUS" ] && [ -z "$TRACKMA_SHOW_INDEX" ]; then
			# let the user select a show
			STATUS=$(printf "$TRACKMA_STATUS_MENU_ENTRIES\n%s" "$menuitem" | $FZF -i --prompt="Choose a status: " --border-label "â•¢ â™£  UPDATE EPISODE (Select series to update) â™£  â•Ÿ" --header "â‡… Navigation â”€ [ESC] Exit â”€ [Enter] Select" --header-first)
			[ "$STATUS" = "$menuitem" ] && PROMPT=$menuitem && continue

			STATUS=$(get_trackma_status_code "$STATUS")

			RES="$(printf "filter %s\nls" "$STATUS" | trackma | sed -En "s/$TRACKMA_LIST_REGEX/\1/p" | sort -r)"
			if [ -z "$RES" ]; then
				RES="This list has no items..."
				TRACKMA_SHOW_INDEX="$(printf "%b" "$RES\n$menuitem" | $FZF -i --prompt="Choose an anime: " --border-label "â•¢ â™£  UPDATE EPISODE ($STATUS list) â™£  â•Ÿ" --header "â‡… Navigation â”€ [ESC] Exit â”€ [Enter] Select" --header-first | cut -d" " -f1)"
				PROMPT=$menuitem && continue
			fi

			TRACKMA_SHOW_INDEX="$(printf "%b" "$RES\n$menuitem" | $FZF -i --prompt="Choose an anime: " --border-label "â•¢ â™£  UPDATE EPISODE ($STATUS list) â™£  â•Ÿ" --header "â‡… Navigation â”€ [ESC] Exit â”€ [Enter] Select" --header-first | cut -d" " -f1)"
			[ "$TRACKMA_SHOW_INDEX" = "ðŸ‡" ] && PROMPT=$menuitem && continue

		fi
		if [ "$PROMPT" = "$update_episodes" ]; then
			printf "      How many episodes of this anime have you watched so farâ”\n" && line_to_remove
			read -r NEW_EPISODE_COUNT # TODO: -n4
			NEW_EPISODE_COUNT="$(printf "%s" "$NEW_EPISODE_COUNT" | sed -E 's/[^0-9]//g')"
			clear_lines
			[ -z "$NEW_EPISODE_COUNT" ] && clear_modifiers && continue
			printf "filter %s\nupdate '%s' %s" "$STATUS" "$TRACKMA_SHOW_INDEX" "$NEW_EPISODE_COUNT" | trackma >"$TRACKMA_LOGFILE" 2>&1
		else
			if [ -z "$NEW_STATUS" ]; then
				NEW_STATUS=$(printf "%b" "$menuitem\n$TRACKMA_STATUS_MENU_ENTRIES" | $FZF -i --prompt="Choose the new status: " --border-label "â•¢ â™£  UPDATE EPISODE STATUS (Select the NEW status) â™£  â•Ÿ" --header "â‡… Navigation â”€ [ESC] Exit â”€ [Enter] Select" --header-first)
				[ "$NEW_STATUS" = "$menuitem" ] && PROMPT=$menuitem && clear_modifiers && continue
				NEW_STATUS="$(get_trackma_status_code "$NEW_STATUS")"
			fi
			[ -n "$TRACKMA_SHOW_INDEX" ] && TRACKMA_ID="$TRACKMA_SHOW_INDEX" || TRACKMA_ID="$ANIME_TITLE_TRACKMA"
			printf "filter %s\nstatus '%s' %s" "$STATUS" "$TRACKMA_ID" "$NEW_STATUS" | trackma >"$TRACKMA_LOGFILE" 2>&1
		fi
		clear_modifiers
		;;
	"$score_show")
		STATUS=$(printf "%b" "$to_mainmenu\n$TRACKMA_STATUS_MENU_ENTRIES" | $FZF -i --prompt="Choose a status: " --border-label "â•¢ â™£  RATE SERIES (Status select) â™£  â•Ÿ" --header "â‡… Navigation â”€ [ESC] Exit â”€ [Enter] Select" --header-first)

		STATUS=$(get_trackma_status_code "$STATUS")

		[ "$STATUS" = "$to_mainmenu" ] && PROMPT=$to_mainmenu && clear_modifiers && continue

		while true; do
			FULL_INFO="$(printf "filter %s\nls" "$STATUS" | trackma | sort -r | sed -En "s/$TRACKMA_LIST_REGEX/\1/p")"
			# remove character sequences and add an emoji next to airing shows
			FULL_INFO=$(printf '%s\n' "$FULL_INFO" | sed "s,$(printf '\033')\\[[0-9;]*[a-zA-Z],ðŸ“£ ," | sed "s,$(printf '\033')\\[[0-9;]*[a-zA-Z],,g" | sed -E "/ðŸ“£/ s/(.*)\.{3}(.*)/\1\2/")
			FULL_INFO="$FULL_INFO\n$to_mainmenu"
			TRACKMA_SHOW_INDEX="$(printf "%b" "$FULL_INFO" | $FZF -i --prompt="Choose an anime: " --border-label "â•¢ â™£  RATE SERIES ($STATUS) â™£  â•Ÿ" --header "â‡… Navigation â”€ [ESC] Exit â”€ [Enter] Select" --header-first | cut -d" " -f1)"
			[ "$TRACKMA_SHOW_INDEX" = "<" ] && unset PROMPT && break
			[ "$TRACKMA_SHOW_INDEX" = "*" ] && break
			echo && line_to_remove
			printf "      ðŸŒŸ What do you score this anime (0-10)â” " && line_to_remove
			read -r SCORE
			clear_lines
			[ "$SCORE" -lt 0 ] && SCORE=0
			[ "$SCORE" -gt 10 ] && SCORE=10
			printf "filter %s\nscore %s %s" "$STATUS" "$TRACKMA_SHOW_INDEX" "$SCORE" | trackma >"$TRACKMA_LOGFILE" 2>&1
			clear_modifiers
			break
		done
		;;
	"$set_altname")
		STATUS=$(printf "$TRACKMA_STATUS_MENU_ENTRIES\n%s" "$to_submenu" | $FZF -i --prompt="Choose a status: " --border-label "â•¢ â™£  SET ALTERNATIVE NAME (Status select) â™£  â•Ÿ" --header "â‡… Navigation â”€ [ESC] Exit â”€ [Enter] Select" --header-first)

		[ "$STATUS" = "$to_submenu" ] && PROMPT=$to_submenu && continue

		while true; do
			FULL_INFO="$(printf "filter %s\nls" "$STATUS" | trackma | sort -r | sed -En "s/$TRACKMA_LIST_REGEX/\1/p")"
			FULL_INFO=$(printf '%s\n' "$FULL_INFO" | sed "s,$(printf '\033')\\[[0-9;]*[a-zA-Z],ðŸ“£ ," | sed "s,$(printf '\033')\\[[0-9;]*[a-zA-Z],,g" | sed -E "/ðŸ“£/ s/(.*)\.{3}(.*)/\1\2/")
			FULL_INFO="$FULL_INFO\n$to_submenu\n$SWITCH_STATUS_MSG_MENU_ENTRY"
			TRACKMA_SHOW_INDEX="$(printf "%b" "$FULL_INFO" | $FZF -i --prompt="Choose an anime: " --border-label "â•¢ â™£  SET ALTERNATIVE NAME ($STATUS list) â™£  â•Ÿ" --header "â‡… Navigation â”€ [ESC] Exit â”€ [Enter] Select" --header-first)"
			[ "$TRACKMA_SHOW_INDEX" = "$to_submenu" ] && PROMPT=$to_submenu && break
			[ "$TRACKMA_SHOW_INDEX" = "$SWITCH_STATUS_MSG_MENU_ENTRY" ] && break
			TRACKMA_SHOW_INDEX=$(printf "%s" "$TRACKMA_SHOW_INDEX" | cut -d" " -f1)
			printf "%b" "
			     â„¹  What is the altnameâ” "
			read -r NEWNAME
			printf "altname %s '%s'" "$TRACKMA_SHOW_INDEX" "$NEWNAME" | trackma >"$TRACKMA_LOGFILE" 2>&1
		done
		clear_modifiers
		;;
	"$pull")
		SEL=$(printf "ðŸ”„ Overwrite local lists\n%s" "$to_mainmenu" | $FZF -i --prompt="Choose an option: " --border-label "â•¢ â™£  $pull â™£  â•Ÿ" --header "â‡… Navigation â”€ [ESC] Exit â”€ [Enter] Select" --header-first | cut -d" " -f1)
		[ "$SEL" = "$to_mainmenu" ] && PROMPT=$to_mainmenu && continue
		[ "$SEL" = "ðŸ”„" ] &&
			trackma retrieve >"$TRACKMA_LOGFILE" 2>&1
		clear_modifiers
		;;
	"$push")
		SEL=$(printf "ðŸ”„ Overwrite remote lists\n%s" "$to_mainmenu" | $FZF -i --prompt="Choose an option: " --border-label "â•¢ â™£  $push â™£  â•Ÿ" --header "â‡… Navigation â”€ [ESC] Exit â”€ [Enter] Select" --header-first | cut -d" " -f1)
		[ "$SEL" = "$to_mainmenu" ] && clear_modifiers && continue
		[ "$SEL" = "ðŸ”„" ] &&
			trackma send >"$TRACKMA_LOGFILE" 2>&1
		clear_modifiers
		;;
	"$list_airing")
		LIST_AIRING=1
		PROMPT=$list
		;;
	"$list_by_score")
		SORT_SCORE=1
		PROMPT=$list
		;;
	"$list")
		STATUS=$(printf "%s\n%s" "$TRACKMA_STATUS_MENU_ENTRIES" "$to_mainmenu" | $FZF -i --prompt="Choose a status: " --border-label " â™£  LIST$([ "$SORT_SCORE" -eq 1 ] && printf ' BY SCORE' || [ "$LIST_AIRING" -eq 1 ] && printf ' AIRING SHOWS' || printf " SHOWS") (Status select) â™£  " --header "â‡… Navigation â”€ [ESC] Exit â”€ [Enter] Select" --header-first)
		[ "$STATUS" = "$to_mainmenu" ] && PROMPT=$to_mainmenu && continue

		STATUS=$(get_trackma_status_code "$STATUS")

		if [ "$SORT_SCORE" -eq 1 ]; then
			# sort by score
			MSG=$(printf 'filter %s\nsort my_score\nls' "$STATUS" | trackma | sed -En "s/$TRACKMA_LIST_REGEX/\1/p" | sort -r)
		else
			MSG=$(printf 'filter %s\nls' "$STATUS" | trackma | sed -En "s/$TRACKMA_LIST_REGEX/\1/p" | sort -r --version-sort)
		fi
		# remove character sequences and add an emoji next to airing shows
		MSG=$(printf '%s\n' "$MSG" | sed "s,$(printf '\033')\\[[0-9;]*[a-zA-Z],ðŸ“£ ," | sed "s,$(printf '\033')\\[[0-9;]*[a-zA-Z],,g" | sed -E "/ðŸ“£/ s/(.*)\.{3}(.*)/\1\2/")

		if [ "$LIST_AIRING" -eq 1 ]; then
			# filter airing show per user request
			MSG=$(printf "%s" "$MSG" | sed -n "/ðŸ“£/p")
		fi

		if [ ! "$MSG" ]; then
			MSG="This list has no items... "
			SEL=$(printf "%s\n%s\n%s" "$MSG" "$to_mainmenu" "$SWITCH_STATUS_MSG_MENU_ENTRY" | $FZF -i --bind "ctrl-l:toggle-preview" --preview-window "50,hidden,wrap" --preview "$sanitize_ext_regex_function_code; $get_show_title_function_code; $get_trackma_status_code_function_code; $get_show_info_function_code; get_show_info {} $STATUS | bat --style=plain --color=always --language=yaml" --preview-label ' Info ' --border-label " â™£  LIST$([ "$SORT_SCORE" -eq 1 ] && printf ' BY SCORE ðŸŒŸ' || [ "$LIST_AIRING" -eq 1 ] && printf ' AIRING SHOWS ðŸ“£' || printf " SHOWS") ($STATUS list) â™£  " --header "â‡… Navigation - [Enter] Go back" --prompt "")
			[ "$SEL" = "$to_mainmenu" ] && PROMPT="$to_mainmenu" && continue
			continue
		fi

		export STATUS
		while true; do
			SEL=$(printf "%s\n%s\n%s" "$MSG" "$to_mainmenu" "$SWITCH_STATUS_MSG_MENU_ENTRY" | $FZF -i --bind "ctrl-l:toggle-preview" --preview-window "50,hidden,wrap" --preview "$sanitize_ext_regex_function_code; $get_show_title_function_code; $get_trackma_status_code_function_code; $get_show_info_function_code; get_show_info {} $STATUS | bat --style=plain --color=always --language=yaml" --preview-label ' Info ' --border-label " â™£  LIST$([ "$SORT_SCORE" -eq 1 ] && printf ' BY SCORE ðŸŒŸ' || [ "$LIST_AIRING" -eq 1 ] && printf ' AIRING SHOWS ðŸ“£' || printf " SHOWS") ($STATUS list) â™£  " --header "â‡… Navigation - [Ctrl-L] toggle info - [ESC] Exit - [Enter] Play â–¸" --prompt "Choose an anime: ")
			[ "$SEL" = "$to_mainmenu" ] && clear_modifiers && break
			[ "$SEL" = "$SWITCH_STATUS_MSG_MENU_ENTRY" ] && break
			ANIME_TITLE_TRACKMA=$(get_show_title "$SEL")
			LAST_SHOW_EP="$(get_last_show_ep "$ANIME_TITLE_TRACKMA")"
			[ -z "$LAST_SHOW_EP" ] && printf "Couldn't get last show episode" && exit 1
			LAST_WATCHED_EP="$(printf "%s" "$SEL" | sed -En "s/$TRACKMA_ENTRY_REGEX/\4/p")"
			# only increment if it's not the last episode of the show
			# if we don't know the last aired apisode just attempt playing the next episode
			# LAST_SHOW_EP can be a string or integer
			if [ "$LAST_SHOW_EP" = "?" ]; then
				ANIME_EP=$((LAST_WATCHED_EP + 1))
			elif [ "$LAST_WATCHED_EP" -lt "$LAST_SHOW_EP" ]; then
				ANIME_EP=$((LAST_WATCHED_EP + 1))
			else
				ANIME_EP="1"
			fi
			TRACKMA_INDEX="$(printf "%s" "$SEL" | sed -En "s/$TRACKMA_ENTRY_REGEX/\1/p")"
			PROMPT="$watch"
			break
		done
		;;
	esac
done
trap - 1 2 3 15

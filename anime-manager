#!/bin/sh
# shellcheck disable=SC2016,SC2034
set -o errexit
set -o nounset

# override locale categories
eval export "$(locale)"
unset LC_ALL
LANG="C"
LC_ALL="C"
LC_COLLATE="C"
LC_CTYPE="C"
LC_MESSAGES="C"
LC_MONETARY="C"
LC_NUMERIC="C"
LC_TIME="C"
LC_ADDRESS="C"
LC_IDENTIFICATION="C"
LC_MEASUREMENT="C"
LC_NAME="C"
LC_PAPER="C"
LC_TELEPHONE="C"
LANGUAGE="en_US.UTF-8"
export LANG LC_ALL \
    LC_COLLATE \
    LC_CTYPE \
    LC_MESSAGES \
    LC_MONETARY \
    LC_NUMERIC \
    LC_TIME \
    LANGUAGE \
    LC_ADDRESS \
    LC_IDENTIFICATION \
    LC_MEASUREMENT \
    LC_NAME \
    LC_PAPER \
    LC_TELEPHONE

. ./lib/array

VERSION="0.0.1"
OSTYPE="$(uname -s 2>/dev/null)"

parser_definition() {
    setup REST help:usage -- "Usage: anime-manager [options]..." ''
    msg -- 'Options:'
    flag MINIMAL --minimal init:="0" -- "Minimalistic interface. It does not print the logo, the menu  
                              fills the screen and is reversed. Dimmer colors."
    flag INCOGNITO_MODE -i --incognito init:="0" -- "Switch Incognito Mode on. Your activity will not be synced 
                              with the remote anime list tracking service."
    flag MONOCHROME_LOGO --monochrome-logo init:="0" -- "Print the monochromatic logo instead of the big orange one. 
                              Suitable for terminals that do not support 24-bit colors."
    flag DEBUG -d --debug init:="0" -- "Start debug mode"
    disp :usage -h --help
    disp VERSION -v --version init:="0"
}

eval "$(utils/getoptions parser_definition) exit 1"

if [ "$DEBUG" -eq 1 ]; then
    set -x
    export NYAA_DEBUG="$DEBUG"
else
    unset NYAA_DEBUG
fi

if [ "$MONOCHROME_LOGO" -eq 1 ] && [ "$MINIMAL" -eq 1 ]; then
    printf "Error: Incompatible options --monochrome-logo, --minimal\nPlease use one or the other."
    exit
fi

# cleanly go to the main loop
# a 'modifier' for us is a flow control variable
clear_modifiers() {
    random_anime=0
    random_airing=0
    prompt=""
    sort_airing=0
    sort_score=0
    anime_title=""
    anime_title_trackma=""
    trackma_show_index=""
    anime_ep=""
    status=""
    new_status=""
    last_watched_ep=""
    nyaa_search_res=""
    play_status=$PLAY_STATUS_WAITING
    player_source="torrenting"
    magnet_link=""
    play_method_menu_opt=""
    debug_match_info=""
    file_list=""
    file_index=""
    animdl_playthrough=0
    animdl_search_index=1
}

reset_logs() {
    echo >"$WEBTORRENT_LOGFILE"
    echo >"$TRACKMA_LOGFILE"
    echo >"$ANIMDL_LOGFILE"
    # echo > "$CURRENTLY_PLAYING_LOGFILE"
    echo >"$NYAA_SEARCH_LOGFILE"
    echo >"$NYAA_FE_LOGFILE"
}

on_exit() {
    onexit_last_exit_status="$?"
    onexit_parent_lineno="$1"
    onexit_message="${2:-(no message ($onexit_last_exit_status))}"
    onexit_exit_code="${3:-$onexit_last_exit_status}"
    if [ "$onexit_exit_code" -eq 130 ] || [ "$onexit_exit_code" -eq 0 ]; then
        tput clear && tput clear
    else
        tput clear
        printf "%s\n" "ERROR on line $onexit_parent_lineno - $onexit_message - exit code $onexit_exit_code"
    fi
    [ "$INCOGNITO_MODE" -eq 0 ] && close_trackma
    # cleanup, save disk space
    [ "$DEBUG" -eq 0 ] &&
        reset_logs &&
        rm -rf "$TORRENT_DOWNLOAD_DIR"
    clear_modifiers
    exit "$onexit_exit_code"
}

trap 'on_exit ${LINENO}' 1 2 3 15

# formats and prints a string
log() {
    printf "%b\n" "$1"
}

select_account() {
    # account selection
    TRACKMA_ACCOUNTS="$(sed -nE "/[0-9]+:/p" "$GLOBAL_TRACKMA_TMPFILE")"
    if [ -n "$TRACKMA_ACCOUNTS" ]; then
        TRACKMA_ACCOUNTS_MENU_ENTRIES="$(printf "%s" "$TRACKMA_ACCOUNTS" | sed "s/^[0-9]: /üë§ /g")"
    else
        TRACKMA_ACCOUNTS_MENU_ENTRIES="No account was found"
    fi
    TRACKMA_ACCOUNTS_MENU_ENTRIES="üïµÔ∏è  Incognito Mode\n$TRACKMA_ACCOUNTS_MENU_ENTRIES"
    while [ -n "$(sed -En "s/no account|Available accounts/&/p" "$GLOBAL_TRACKMA_TMPFILE")" ] && [ "$INCOGNITO_MODE" -eq 0 ]; do
        account_choice=$(
            printf "%b" "$TRACKMA_ACCOUNTS_MENU_ENTRIES" |
                $FZF -i --prompt="Select an option: " \
                    --border-label "‚ï¢ ‚ô£  ACCOUNT SELECTION ‚ô£  ‚ïü" \
                    --header "‚áÖ Navigation ‚îÄ [ESC] Exit ‚îÄ [Enter] Select" \
                    --header-first --tac --no-sort
        )
        if [ "$(printf "%s" "$account_choice" | cut -d " " -f1)" = "üïµÔ∏è" ]; then
            INCOGNITO_MODE=1
            close_trackma
            break
        elif [ "$account_choice" = "No account was found" ]; then
            exit
        else
            acc_id="$(printf "%s" "$TRACKMA_ACCOUNTS" | grep "$(printf "%s" "$account_choice" | sed "s/^üë§ //g")" | cut -d ":" -f1)"
            [ -z "$acc_id" ] && exit
            printf "r%s\n" "$acc_id" | trackma_query >/dev/null 2>&1
        fi
    done
    if [ "$INCOGNITO_MODE" -eq 0 ]; then
        USERNAME="$(get_account_name)"
        TRACKER_SERVICE="$(get_remote_tracker)"
    fi
}

check_trackma_config() {
    check_trackma_config_config_file=""
    if [ -s "$HOME"/.trackma/config.json ]; then
        check_trackma_config_config_file="$HOME/.trackma/config.json"
    elif [ -s "$HOME"/.config/trackma/config.json ]; then
        check_trackma_config_config_file="$HOME/.config/trackma/config.json"
    fi
    AUTORET_VALUE="$(jq --raw-output '.autoretrieve' "$check_trackma_config_config_file")"
    AUTOSEN_VALUE="$(jq --raw-output '.autosend' "$check_trackma_config_config_file")"
    if [ "$AUTORET_VALUE" = "always" ] || [ "$AUTOSEN_VALUE" = "always" ]; then
        printf "%b" "
üí• Anime Manager was unable to start!
   Please change the 'autoretrieve' and 'autosave' options
   in '$check_trackma_config_config_file'
   to a value other than 'always'.
"
        exit
    fi
    select_account
}

# trim long show titles
trim() {
    MAX_MENU_TITLE_SERIES_LEN=20
    title="$1"
    c_count=$(printf "%s" "$title" | wc -c | sed "s/ //g")
    if [ "$c_count" -gt $MAX_MENU_TITLE_SERIES_LEN ]; then
        printf "%s" "$title" | cut -c 1-"$MAX_MENU_TITLE_SERIES_LEN" | sed "s/$/(...)/"
    else
        printf "%s" "$title"
    fi
}

line_to_remove() {
    lines_to_remove="$((lines_to_remove + 1))"
}

# clear n number of lines from output
# caveat: wrapped lines
clear_lines() {
    while [ $lines_to_remove -gt 0 ]; do
        printf "%b" "${OVERWRITE}"
        lines_to_remove=$((lines_to_remove - 1))
    done
}

# check if we can run automatic install for missing dependencies
auto_compat() {
    if [ "$OSTYPE" = "Linux" ]; then
        distro_id="$(awk -F= '$1 == "ID" {print $2}' /etc/*-release)"
        case $distro_id in
        "ubuntu" | "debian")
            true
            ;;
        *)
            false
            ;;
        esac
    elif [ "$OSTYPE" = "Darwin" ]; then
        true
    else
        log "Automatic installation does not support your platform yet\nbut we may add support for it in the future.\n\nPlease install the dependencies manually.\n\nMORE INFO: https://github.com/anma-dev/Anime-Manager#dependencies"
        exit 0
    fi
}

# get the shell configuration file path
get_shell_config_file() {
    get_shell_config_file_cfg_file=""
    if [ "$SHELL" = "/bin/bash" ]; then
        [ "$OSTYPE" = "Linux" ] && touch "$HOME/.bashrc" && get_shell_config_file_cfg_file="$HOME/.bashrc"
        [ "$OSTYPE" = "Darwin" ] && touch "$HOME/.bash_profile" && get_shell_config_file_cfg_file="$HOME/.bash_profile"
    fi
    # nvm on macos needs the shell config file
    [ "$SHELL" = "/bin/zsh" ] && touch "$HOME/.zshrc" && get_shell_config_file_cfg_file="$HOME/.zshrc"
    printf "%s" "$get_shell_config_file_cfg_file"
}

# install dependencies automatically if we can
install_dependencies() {
    AM_SHELL_CFG_MSG="### Anime Manager autoinstall ###"
    shell_cfg="$(get_shell_config_file)"
    install_dep_msg="üéâ Finished the autoinstall!\nRestart your shell to start using Anime Manager."
    # Ubuntu (not WSL) and macOS support
    if ! which fzf bat animdl trackma jq node >/dev/null 2>&1 || [ ! -s lib/webtorrent-cli/bin/cmd.js ]; then
        log "Anime Manager can automatically install its dependencies.\nSome dependencies were not found!" && line_to_remove

        if auto_compat; then
            printf "%s" "Install missing dependencies now? [y/N] " && line_to_remove
            read -r yn </dev/tty
            if [ -z "$yn" ]; then
                yn="n"
            fi
            case "$yn" in
            [Yy]*) ;;
            [Nn]*) exit ;;
            *) printf "%s\n" "      Please answer 'yes' or 'no'." && line_to_remove ;;
            esac
        fi
        # begin installation
        if [ "$OSTYPE" = "Linux" ]; then
            log "üêß Installing Linux dependencies."
            if ! sudo -v; then
                log "üí• Your current user account has no administrative privileges.\nRequired dependencies unable to install\nPlease contact your system administrator." && exit 1
            fi
            sudo apt update
            sudo apt -y install build-essential procps curl wget file git python3-setuptools python3-pip bat jq
            mkdir -p "$HOME/.local/bin"
            if ! grep '$HOME/.local/bin:$PATH' "$shell_cfg"; then
                printf "\n%s\n%s\n" "$AM_SHELL_CFG_MSG" 'export PATH="$HOME/.local/bin:$PATH"' >>"$shell_cfg"
            fi
            # make alias for batcat and put it in path
            if ! command -v bat; then
                [ ! -s "$HOME/.local/bin/bat" ] && ln -s /usr/bin/batcat "$HOME/.local/bin/bat"
            fi
            if ! command -v fzf; then
                if [ -d "$HOME/.fzf" ]; then
                    printf "\n\n%s\n\n" "INSTALLATION CONFLICT! Existing $HOME/.fzf folder found!\nfzf was not installed. Please install it manually."
                else
                    # require an fzf version with label and label coloring support
                    git clone --depth 1 https://github.com/junegunn/fzf.git "$HOME/.fzf"
                    "$HOME/.fzf/install" --all --update-rc
                fi
            else
                fzf_version="$(fzf --version)"
                if [ -z "$(printf "%s" "$fzf_version" | awk -F. '$1 >= 0 && $2 >= 35 {print $0}')" ]; then
                    printf "\n\n%s\n\n" "Please manually update your fzf installation to version >= 0.35.x."
                fi
            fi
            ./utils/install-webtorrent.sh
            if ! command -v animdl; then
                # https://github.com/justfoolingaround/animdl
                pip3 install animdl
            fi
            if ! command -v trackma; then
                sudo apt install lsof
                sudo apt -y install python3-pyqt5
                # https://github.com/z411/trackma
                pip3 install pillow \
                    pydbus \
                    setuptools \
                    wheel \
                    pyinotify \
                    nyaapy \
                    anitopy \
                    'requests>=2.20.0' \
                    beautifulsoup4==4.6.0 \
                    lxml \
                    dbus-python
                pip3 install Trackma==0.8.5
            fi
        elif [ "$OSTYPE" = "Darwin" ]; then
            log "üçè Installing macOS dependencies."
            if ! pkgutil --pkg-info=com.apple.pkg.CLTools_Executables | grep version >/dev/null 2>&1; then
                # xcode command line tools is a dependency of nvm and homebrew
                xcode-select --install
            fi
            if ! command -v brew; then
                # Install homebrew unattended
                NONINTERACTIVE=1 /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
            fi
            if ! grep 'export PATH="/opt/homebrew/bin/:$PATH"' "$shell_cfg" >/dev/null 2>&1; then
                printf "\n%s\n%s\n" "$AM_SHELL_CFG_MSG" 'export PATH="/opt/homebrew/bin/:$PATH"' >>"$shell_cfg"
            fi
            brew install curl jq grep axel openssl@1.1 ffmpeg git bat
            brew install patchelf cmake automake fzf
            if ! command -v animdl; then
                # https://github.com/justfoolingaround/animdl
                pip3 install animdl
            fi
            ./utils/install-webtorrent.sh
            if ! command -v trackma; then
                # https://github.com/z411/trackma
                # dbus-python module is broken on macOS and cannot be built. This means no trackma mpris support.
                # pip3 install dbus-python
                # inotify is not available on macosx-XX-arm64
                # pip3 install pyinotify
                # Installs qt5 for trackma gui
                pip3 install pillow \
                    PyQt5 \
                    pydbus \
                    setuptools \
                    setuptools_scm \
                    scikit-build \
                    nyaapy \
                    anitopy \
                    'requests>=2.20.0' \
                    beautifulsoup4==4.6.0 \
                    lxml \
                    wheel \
                    Trackma==0.8.5
            fi
        fi
        echo
        log "$install_dep_msg"
        exit
    fi
}

# sanitizes a string to be used in an extended regular expression
sanitize_ext_regex_function_code='sanitize_ext_regex() {
    printf "%s" "$1" |
        sed "s,$(printf "\033")\\[[0-9;]*[a-zA-Z],," |
        sed "s,$(printf "\033")\\[[0-9;]*[a-zA-Z],,g" |
        sed "s,\x1B\[[0-9;]*[a-zA-Z],,g" |
        sed "s/[]\/\$*.^+()\"['"'"'-]/\\\&/g" |
        sed "s/ $//"
}'
eval "$sanitize_ext_regex_function_code"

sanitize_bash() {
    printf "%s" "$1" | LC_ALL=C sed -e 's/[^a-zA-Z0-9,._+@%/-]/\\&/g; 1{$s/^$/""/}; 1!s/^/"/; $!s/$/"/'
}

getcwd() {
    printf "%s" "$(lsof -p "$$" | grep cwd | awk '{print $9}')"
}

lines_to_remove=0
# Message color palette
RESET="\033[0m\n"
MSG_INFO_COLOR="\033[38;2;255;255;224m" # lightyellow
MSG_WARN_COLOR="\033[38;2;255;165;0m"   # orange
MSG_ERR_COLOR="\033[31m"                # red
MSG_HELP_COLOR="\033[1;34m"             # lightblue, bold
TITLE_COLOR="\033[33m"                  # yellow
SUBTITLE_COLOR="\033[1;34m"             # lightblue, bold
INCOGNITO_MODE_COLORS="\033[37;45m"     # magenta bg, white fg
OVERWRITE='\r\033[1A\033[0K'

DATE_MONTH=$(date "+%m")
DATE_DAY=$(date "+%d")
CONFIG_PATH="$HOME/.config/anime-manager"
TMP_PATH="/tmp/anime-manager"
CHECKPOINTFILE="$HOME/.config/anime-manager/checkpoint"
player_source="torrenting"

animdl_playthrough=0
animdl_search_index=1
NYAA_SEARCH_BIN="$(getcwd)/lib/nyaa_search.py"
NYAA_SEARCH_LOGFILE="$CONFIG_PATH/nyaa_search.log"
NYAA_FE_LOGFILE="$CONFIG_PATH/file_extractor.log"
NYAA_FE_BIN="$(getcwd)/lib/file_extractor.py"
WEBTORRENT_CLI="lib/webtorrent-cli/bin/cmd.js"
TORRENT_DOWNLOAD_DIR="${TMP_PATH}/webtorrent"

# logfiles
WEBTORRENT_LOGFILE="$CONFIG_PATH/webtorrent.log"
TRACKMA_LOGFILE="$CONFIG_PATH/trackma.log"
# CURRENTLY_PLAYING_LOGFILE="$CONFIG_PATH/now_playing.log"
ANIMDL_LOGFILE="$CONFIG_PATH/animdl.log"
# webtorrent globals
# torrent status codes
TORRENT_TMOUT=60
TORRENT_STATUS_OKPLAYING=0
TORRENT_STATUS_STALLED=1
TORRENT_STATUS_ERRORED=2
file_list=""
webtorrentpid=""
# player status codes
PLAY_STATUS_WAITING=0
PLAY_STATUS_OKPLAYING=1
PLAY_STATUS_ERRORED=2
PLAY_STATUS_EXITED=3
# PLAY_STATUS_OFFLINE=4
PLAY_STATUS_FILE_SEL=5
play_status=$PLAY_STATUS_WAITING
# nyaa search return codes, corresponds with lib/return_codes.py
NYAA_SEARCH_CODE_NO_RESULTS="-1"
NYAA_SEARCH_CODE_FATAL_ERROR="-3"
NYAA_FID_CODE_CONTENT_MISMATCH="-6"

mkdir -p "$TMP_PATH"
mkdir -p "$TORRENT_DOWNLOAD_DIR"
mkdir -p "$CONFIG_PATH"
[ ! -f "$TRACKMA_LOGFILE" ] && touch "$TRACKMA_LOGFILE"

check_setup() {
    # initial checks
    if [ ! -f "$CHECKPOINTFILE" ]; then
        printf "%s" "
READ FIRST --

    This program comes with ABSOLUTELY NO WARRANTY.
Anime Manager is a file sharing program. When you run a torrent (Anime Manager can play content by the means of running a torrent), its data will be made available to others by means of upload. Any content you share is your sole responsibility. No further notices will be issued.

-------------

Do you agree with this? [yes/no]: "
        while true; do
            read -r answer
            case "$answer" in
            "yes") break ;;
            "no") exit ;;
            *) printf "%s" "Please answer 'yes' or 'no': " && line_to_remove ;;
            esac
        done
        printf "%s\n" "$answer" >"$CHECKPOINTFILE"
    fi
    # use node if nvm is already installed
    if ! which node >/dev/null 2>&1; then
        PLATFORM_NVM_DIR=""
        if [ -d "$HOME/.config/nvm" ]; then
            PLATFORM_NVM_DIR="$HOME/.config/nvm"
        elif [ -d "$HOME/.nvm" ]; then
            PLATFORM_NVM_DIR="$HOME/.nvm"
        fi
        if [ -d "$PLATFORM_NVM_DIR" ]; then
            export NVM_DIR="$PLATFORM_NVM_DIR"
            # shellcheck disable=SC1091
            [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh" >/dev/null 2>&1 # This loads nvm
            # shellcheck disable=SC1091
            [ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion" >/dev/null 2>&1 # This loads nvm bash_completion
            if comand -v nvm >/dev/null 2>&1; then
                nvm use node >/dev/null 2>&1
            fi
        fi
    fi
    install_dependencies
}

# Create a safe temporary filename in a posix-compliant way
get_temp_filename() {
    {
        posix_mktemp_file_file=$(
            (mktemp -u "$TMP_PATH/anmaXXXXXXXX") 2>/dev/null
        )
    } || {
        posix_mktemp_file_file=$TMP_PATH/anma$$-$(awk 'BEGIN { srand(); print int(rand()*32768) }' /dev/null)
    } || exit $?
    printf "%s" "$posix_mktemp_file_file"
}

# get the account in use in Trackma
get_account_name() {
    while ! grep "using account" "$GLOBAL_TRACKMA_TMPFILE" >/dev/null 2>&1; do :; done
    sed -En "s/.*using account (.*)\(.*/\1/p" "$GLOBAL_TRACKMA_TMPFILE" # | sed "s/ $//g"
}

# gets the remote tracking service (mal, anilist, etc) used in trackma
# this is necessary because the lists differ between services
get_remote_tracker() {
    while ! grep "using account" "$GLOBAL_TRACKMA_TMPFILE" >/dev/null 2>&1; do :; done
    sed -En "s/.*using account (.*)\((.*)\).*/\2/p" "$GLOBAL_TRACKMA_TMPFILE"
}

get_trackma_tracker_name() {
    get_trackma_tracker_name_name="$1"
    case $get_trackma_tracker_name_name in
    "mal")
        printf "MAL"
        ;;
    "anilist")
        printf "Anilist"
        ;;
    esac
}

# returns a status code that trackma understands
get_trackma_status_code_function_code='get_trackma_status_code() {
    get_trackma_status_code_status_status="$1"
    case $get_trackma_status_code_status_status in
    "Watching" | "watching")
        printf "watching"
        ;;
    "Plan to Watch" | "plantowatch")
        printf "plantowatch"
        ;;
    "Rewatching" | "rewatching")
        printf "rewatching"
        ;;
    "Dropped" | "dropped")
        printf "dropped"
        ;;
    "Paused" | "paused")
        printf "paused"
        ;;
    "Completed" | "completed")
        printf "completed"
        ;;
    "On Hold" | "onhold")
        printf "onhold"
        ;;
    "$TO_MAIN_MENU")
        printf "%s" "$TO_MAIN_MENU"
        ;;
    "$SWITCH_STATUS_MSG_MENU_ENTRY")
        printf "%s" "$SWITCH_STATUS_MSG_MENU_ENTRY"
        ;;
    esac
}'
eval "$get_trackma_status_code_function_code"

# Update watched episodes
set_ep_as_watched() {
    printf "update %s\n" "$trackma_index" | trackma_query >/dev/null 2>&1
    # we check if theres actually something to save
    # save other shows and replace the new updated registry for this show
    preserved_history=$(awk "!/^$(sanitize_ext_regex "$anime_title_trackma").*$/" "$WATCH_HISTORY_FILE")
    # if there is content that is not replaced add a newline for the show to insert, and only in that case.
    [ -n "$preserved_history" ] && printf "%b" "$preserved_history\n" >"$WATCH_HISTORY_FILE" || printf "%b" "$preserved_history" >"$WATCH_HISTORY_FILE"
    printf "%s\n" "$anime_title_trackma////$anime_ep" >>"$WATCH_HISTORY_FILE"
}

# set episode status on the anime tracker service
# ARGS in order
# trackma_show_index the index of the show obtained from user input
set_show_status() {
    set_show_status_STATUS="$2"
    new_status="$(get_trackma_status_code "$set_show_status_STATUS")"
    prompt="$UPDATE_STATUS"
}

filter_trackma_list_function_code='filter_trackma_list() {
    printf "%b" "$1" | sed -En "s/$TRACKMA_LIST_REGEX/\1/p"
}'
eval "$filter_trackma_list_function_code"

# get all the shows the user has set as watching in their lists
# for presenting in unified way
get_watching_shows() {
    get_watching_shows_rewatching=""
    get_watching_shows_watching="$(printf "filter %s\nls\n" "watching" | trackma_query)"
    get_watching_shows_watching="$(filter_trackma_list "$get_watching_shows_watching")"
    if [ "$TRACKER_SERVICE" = "anilist" ]; then
        # exception for anilist
        get_watching_shows_rewatching="$(printf "filter %s\nls\n" "rewatching" | trackma_query)"
        get_watching_shows_rewatching="$(filter_trackma_list "$get_watching_shows_rewatching")"
    fi
    printf "%b\n%b" "$get_watching_shows_watching" "$get_watching_shows_rewatching"
}

# accepts a trackma entry and returns the cleaned show title
# to use with raw trackma entries only
get_show_title_function_code='get_show_title() {
    if [ -n "$(printf "%s" "$1" | sed -En "s/$TRACKMA_ENTRY_REGEX/\2/p")" ]; then
        # raw entry
        printf "%s" "$1" | sed -En "s/$TRACKMA_ENTRY_REGEX/\2/p" | sed -E "s/ *$//g" | sed -E "s/\.*$//g" | sed -E "s,$(printf "'"\033"'")\\[0-9;]*[a-zA-Z],," | sed -E "s,$(printf "'"\033"'")\\[0-9;]*[a-zA-Z],,g" | sed "s,\x1B\[[0-9;]*[a-zA-Z],,g" | sed "s/üì£ //g" | sed -E "s/\[.*\]//g" | sed -E "s/ $//g"
    else
        printf "%s" "$1"
    fi
}'
eval "$get_show_title_function_code"

# gets the index of an entry
# "$("$play_episode_anime_title" | sed "s/'/'\"'\"'/g")"
get_entry_index_function_code='get_entry_index() {
    echo >"$GLOBAL_TRACKMA_TMPFILE"
    res_title=""
    anime_title="$1"
    status="$2"
    res="$(printf "filter %s\nsearch '"'"'%s'"'"'\n" "$(get_trackma_status_code "$status")" "$(printf "%s" "$anime_title" | sed "s/'"'"'/'"'"'\"'"'"'\"'"'"'/g")" | trackma_query)"
    res="$(filter_trackma_list "$res" | head -n1)"
    entry_index="$(printf "%s" "$res" | sed -En "s/$TRACKMA_ENTRY_REGEX/\1/p")"
    if [ -z "$entry_index" ]; then
        printf "%b\n" "üí• ERROR getting entry index.\nPlease report this error message to the developer."
        exit 1
    fi
    printf "%s" "$entry_index"
}'
eval "$get_entry_index_function_code"

# gets the status of a show
get_show_status() {
    if [ -n "$status" ]; then
        status="$(get_trackma_status_code "$status")"
        printf "%s" "$status"
    else
        res_title=""
        anime_title="$1"
        while read -r trackma_code; do
            # trackma search uses regex so we need to sanitize it
            res="$(printf "filter %s\nsearch '%s'\n" "$(get_trackma_status_code "$trackma_code")" "$(printf "%s" "$anime_title" | sed "s/'/'\"'\"'/g")" | trackma_query)"
            res="$(filter_trackma_list "$res" | head -n1)"
            [ -n "$res" ] && res_title="$(get_show_title "$res")"
            if [ -n "$res_title" ] && [ "$res_title" = "$anime_title" ]; then
                status="$trackma_code"
                break
            fi
        done <<EOF
$TRACKMA_STATUS_MENU_ENTRIES
EOF
        if [ -z "$status" ]; then
            printf "%b\n" "üí• ERROR getting show status.\nPlease report this error message to the developer."
            exit 1
        fi
        printf "%s" "$status"
    fi
}

# internet connectivity check with random selection of hosts
connectivity_check() {
    urls=$(array "ubuntu.com" "google.com" "duckduckgo.com" "bing.com")
    urls_len=$(printf '%s\n' "$urls" | array_len)
    rand_id=$(shuf -i 0-"$((urls_len - 1))" -n 1)
    rand_url=$(printf '%s\n' "$urls" | array_nth "$rand_id")
    if printf "%b" "GET https://$rand_url HTTP/1.0\n\n" | nc "$rand_url" 443 >/dev/null 2>&1; then
        true
    else
        false
    fi
}

# get shows info from Trackma
get_show_info_function_code='get_show_info() {
    get_show_info_show_title="$(get_show_title "$1")"
    get_show_info_status="$(get_trackma_status_code "$2")"
    if [ "$1" = "$TO_MAIN_MENU" ]; then
        printf "%s\n" "Go back to the main menu"
    elif [ "$1" = "$SWITCH_STATUS_MSG_MENU_ENTRY" ]; then
        printf "%s\n" "Switch to another list"
    else
        trackma_index="$(get_entry_index "$get_show_info_show_title" "$get_show_info_status")"
        get_show_info_info="$(printf "filter %s\ninfo \"%s\"\n" "$get_show_info_status" "$trackma_index" | trackma_query | sed -n "/https/,/Status/p" | sed -e "s/<[^>]*>//g")"
        printf "\n%b" "$get_show_info_info"
    fi
}'
eval "$get_show_info_function_code"

# get the last episode from a show in the re/watching list
# used when the user plays a show from the watch or watch history
# ARGS in order
# anime_title the title of the show as trackma sees it
get_last_show_ep() {
    # removes altname and trailing spaces, trackma cant find shows if the altname is in the query
    get_last_show_ep_anime_title="$(printf "%s" "$1" | sed "s/\[.*\]//g" | sed "s/ $//g")"
    get_last_show_ep_full_entry=$(get_show_entry "$get_last_show_ep_anime_title")
    [ -z "$get_last_show_ep_full_entry" ] && printf "üí• Error getting last episode!" && exit 1
    last_episode="$(printf "%b" "$get_last_show_ep_full_entry" | sed -En "s/$TRACKMA_ENTRY_REGEX/\5/p")"
    printf "%s" "$last_episode"
}

# get anime series across lists or from a particular list
# this is used to play any episode from the watch history
# the status code argument should be parseable by trackma
get_show_entry() {
    echo >"$GLOBAL_TRACKMA_TMPFILE"
    play_episode_anime_title="$1"
    status="$(get_show_status "$play_episode_anime_title")"
    # trackma search uses regex so we need to sanitize it
    res="$(printf "filter %s\nsearch '%s'\n" "$(get_trackma_status_code "$status")" "$(printf "%s" "$play_episode_anime_title" | sed "s/'/'\"'\"'/g")" | trackma_query)"
    get_show_entry_list="$(filter_trackma_list "$res" | head -n1)"
    # we assume we should find a result
    [ -z "$get_show_entry_list" ] &&
        printf "%b\n" "üí• ERROR getting show entry.\nPlease report this error message to the developer." && exit 1
    printf "%b" "$get_show_entry_list"
}

torrent_is_playing() {
    process_name="$(ps -p "$webtorrentpid" -o comm=)"
    if [ "$process_name" = "WebTorrent" ]; then
        true
    else
        false
    fi
}

# the menu that shows up when the media player opens
media_player_menu() {
    # block until the play status is set up
    while [ "$play_status" -eq "$PLAY_STATUS_WAITING" ]; do
        sleep 1
    done
    if [ "$play_status" -eq "$PLAY_STATUS_ERRORED" ]; then
        # fatal error, go back to mainmenu
        echo && line_to_remove
        if [ "$player_source" = "streaming" ]; then
            printf "$MSG_ERR_COLOR%s$RESET" "      üí• Unable to play the episode via streaming." && line_to_remove
        else
            printf "$MSG_ERR_COLOR%s$RESET" "      üí• Unable to stream the episode via torrenting." && line_to_remove
        fi
        printf "%s\n" "      [Enter]  Source selection ‚ñ∂" && line_to_remove
        # recovery menu loop
        while true; do
            read -r key # TODO: -n1
            if [ "$key" = "" ]; then
                line_to_remove
                clear_lines
                break
            fi
        done
        player_source="torrenting"
        nyaa_search_res=""
        file_list=""
        magnet_link=""
        media_player_exit_code="$PLAYER_MENU_END_CODE"
        return
    elif [ "$play_status" = "$PLAY_STATUS_EXITED" ]; then
        # the user decided to go to main menu
        clear_lines
        clear_modifiers
        media_player_exit_code="$PLAYER_MENU_END_CODE"
        return
    fi
    clear_lines
    series_menu_title=$(trim "$anime_title")
    playing_menu=""
    if [ "$INCOGNITO_MODE" -eq 0 ]; then
        # trackma account entries
        if [ "$last_show_episode" != "?" ] && [ "$anime_ep" -eq "$last_show_episode" ]; then
            playing_menu="üèÅ Set as Watched + Move to Completed list\n"
            [ "$show_type" != "movie" ] && series_menu_title="üèÅ END! ‚îÄ $series_menu_title"
        else
            playing_menu="‚è≠Ô∏è  Set as Watched + Play next\n‚úÖ Set as Watched\n"
        fi
    fi
    # player reset entries
    if [ "$player_source" = "torrenting" ]; then
        playing_menu="${playing_menu}üîé Select another search result\nüí° Switch to streaming\nüôà Unexpected? Select another file ‚ñ∏"
    elif [ "$player_source" = "streaming" ]; then
        playing_menu="${playing_menu}üîé Select another search result\nüò∫ Switch to torrenting"
    fi
    FZF_PREVIEW_WINDOW_CMD="printf \"%s\" '$debug_match_info' | jq | bat -p --language=json"
    opt=$(printf "%b" "${playing_menu}\n${TO_MAIN_MENU}" |
        $FZF -i --prompt="Choose an action: " \
            --border-label "‚ï¢ üì∫  NOW PLAYING$([ -n "$show_type" ] && printf "%s" " ($show_type)" |
                tr '[:lower:]' '[:upper:]') ‚îÄ ${series_menu_title}$([ -n "$show_type" ] && [ "$show_type" != "movie" ] && printf " ‚ñ∂ Episode %s" "$anime_ep") ‚ïü" \
            --header "‚áÖ Navigation ‚îÄ [ESC] Exit ‚îÄ [Enter] Select" \
            --header-first \
            --preview "$FZF_PREVIEW_WINDOW_CMD" \
            --bind "ctrl-l:toggle-preview" \
            --preview-window "$PREVIEW_WINDOW_OPTS" \
            --bind "shift-right:change-preview-window($MENU_PREVIEW_POS_MODES)+preview:$FZF_PREVIEW_WINDOW_CMD" \
            --preview-label "STREAM DEBUG")
    opt=$(printf "%s" "$opt" | cut -d " " -f1)
    if [ "$opt" = "‚óÇ" ]; then
        prompt="$TO_MAIN_MENU"
        clear_modifiers
        media_player_exit_code="$PLAYER_MENU_END_CODE"
    elif [ "$opt" = "‚úÖ" ]; then
        set_ep_as_watched
        clear_modifiers
        media_player_exit_code="$PLAYER_MENU_END_CODE"
    elif [ "$opt" = "‚è≠Ô∏è" ]; then
        set_ep_as_watched
        if [ "$player_source" = "torrenting" ]; then
            nyaa_search_res="" # will query nyaa again
            magnet_link=""
            file_list=""
        elif [ "$player_source" = "streaming" ]; then
            animdl_playthrough=1
        fi
        play_method_menu_opt=""
        anime_ep=$((anime_ep + 1))
    elif [ "$opt" = "üèÅ" ]; then
        set_ep_as_watched
        set_show_status "$trackma_show_index" "Completed"
        media_player_exit_code="$PLAYER_MENU_END_CODE"
    elif [ "$opt" = "üí°" ]; then
        player_source="streaming"
        magnet_link=""
        nyaa_search_res="" # will query nyaa again
    elif [ "$opt" = "üò∫" ]; then
        player_source="torrenting"
        file_list=""
        magnet_link=""
        nyaa_search_res="" # will query nyaa again
        media_player_exit_code="$PLAYER_MENU_SELECT_SEARCH_RES_CODE"
    elif [ "$opt" = "üîé" ]; then
        [ "$player_source" = "streaming" ] && animdl_playthrough=0
        [ "$player_source" = "torrenting" ] && nyaa_search_res="" && magnet_link=""
        file_list=""
        media_player_exit_code="$PLAYER_MENU_SELECT_SEARCH_RES_CODE"
    elif [ "$opt" = "üôà" ]; then
        play_status="$PLAY_STATUS_FILE_SEL"
        media_player_exit_code="$PLAYER_MENU_SOURCE_SELECT_CODE"
    fi
}

# global long-running trackma subprocess
spawn_trackma() {
    if [ "$DEBUG" -eq 1 ]; then
        GLOBAL_TRACKMA_TMPFILE="$CONFIG_PATH/debug_trackma_fifo"
    else
        GLOBAL_TRACKMA_TMPFILE="$(get_temp_filename)"
    fi
    GLOBAL_TRACKMA_FIFO="$(get_temp_filename)"
    mkfifo -m 600 "$GLOBAL_TRACKMA_FIFO"
    trackma <"$GLOBAL_TRACKMA_FIFO" >"$GLOBAL_TRACKMA_TMPFILE" 2>"$TRACKMA_LOGFILE" &
    exec 3>"$GLOBAL_TRACKMA_FIFO"
    # printf "%s" " ‚öôÔ∏è  Starting background process, please wait..." && line_to_remove
    while [ ! -s "$GLOBAL_TRACKMA_TMPFILE" ]; do :; done
    # clear_lines
}

close_trackma() {
    # printf "%s" "      ‚öôÔ∏è  Closing background processes, please wait..." && line_to_remove
    printf "exit\n" >"$GLOBAL_TRACKMA_FIFO"
    rm "$GLOBAL_TRACKMA_FIFO"
    echo >"$GLOBAL_TRACKMA_TMPFILE"
    # shellcheck disable=2188
    3>&-
}

trackma_query_function_code='trackma_query() {
    echo >"$GLOBAL_TRACKMA_TMPFILE"
    while read -r query </dev/stdin; do
        printf "%s\n" "$query" >"$GLOBAL_TRACKMA_FIFO"
    done
    # wait for various prompts as signal for operation finished
    while ! sed -En "/>>|\):/p" "$GLOBAL_TRACKMA_TMPFILE"; do :; done
    cat "$GLOBAL_TRACKMA_TMPFILE"
}'
eval "$trackma_query_function_code"

# attempts to play a series episode
play_episode() {
    reset_logs
    while ! connectivity_check; do
        echo && line_to_remove
        printf "$MSG_WARN_COLOR%s$RESET" "      üå¥ü¶ï NO INTERNET CONNECTION „Éª„Éª„Éª" && line_to_remove
        printf "$MSG_WARN_COLOR%s$RESET" "      Please check your connection and press [Enter]" && line_to_remove
        read -r key # TODO: -n1
        [ "$key" = "" ] && clear_lines && continue
    done

    play_episode_anime_title="$1"
    play_episode_anime_episode="$2"
    player_source="$3"
    status="$4"
    show_type="$5"
    show_synonyms="$6"

    if [ "$player_source" = "torrenting" ]; then
        if [ -z "$magnet_link" ]; then
            # get magnet link and play it with webtorrent-cli
            if [ -z "$nyaa_search_res" ]; then
                echo && line_to_remove
                printf "$MSG_INFO_COLOR%s$RESET" "      üò∫ Searching Nyaa Torrents. Please wait..." && line_to_remove
                nyaa_search_res="$($NYAA_SEARCH_BIN --title "$play_episode_anime_title" --episode "$play_episode_anime_episode" --quality 1080 --show-type "$show_type")"
                nyaa_search_ret_msg=$(printf "%s" "$nyaa_search_res" | awk -F "////" '{print $1}')
                nyaa_search_ret_code=$(printf "%s" "$nyaa_search_res" | awk -F "////" '{print $2}')
                if [ "$nyaa_search_ret_code" = "$NYAA_SEARCH_CODE_NO_RESULTS" ]; then
                    echo && line_to_remove
                    printf "$MSG_WARN_COLOR%s$RESET" "      üö´ $nyaa_search_ret_msg" && line_to_remove
                    play_status=$PLAY_STATUS_ERRORED
                    return
                elif [ "$nyaa_search_ret_code" = "$NYAA_SEARCH_CODE_FATAL_ERROR" ]; then
                    echo && line_to_remove
                    printf "$MSG_WARN_COLOR%s$RESET" "      üö´ $nyaa_search_ret_msg" && line_to_remove
                    printf "$MSG_WARN_COLOR%s$RESET" "      Please contact development to work this out:" && line_to_remove
                    printf "$MSG_WARN_COLOR%s$RESET" "      https://github.com/anma-dev/Anime-Manager/issues" && line_to_remove
                    play_status=$PLAY_STATUS_ERRORED
                    return
                fi
            fi
            clear_lines
            FZF_PREVIEW_WINDOW_CMD="printf \"\n%s\n\n%b\" {} '‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nColor code: \nüü¢ Trusted\nüî¥ Remake\n‚ö™Ô∏è No category\n\nMore info: https://nyaa.si/help'"
            PROMPT_TEXT="Choose a search result: "
            nyaa_search_res=$(printf "%b" "$nyaa_search_res" | sed 's/'"'"'//g')
            choice=$(
                printf "%b" "{\"name\": \"$TO_MAIN_MENU\"}\n$nyaa_search_res" | jq '.name' | sed "s/^\"//g" | sed "s/\"$//g" |
                    $FZF -i --prompt "$PROMPT_TEXT" \
                        --border-label "‚ï¢ ‚ô£  SEARCH RESULTS (Nyaa Torrents): $(trim "$play_episode_anime_title") ‚ñ∂ $play_episode_anime_episode ‚ô£  ‚ïü" \
                        --header "‚áÖ Navigation ‚îÄ [ESC] Exit ‚îÄ [Ctrl-L] Expand ‚îÄ [Enter] Play (torrenting) ‚ñ∏" \
                        --header-first \
                        --preview "$FZF_PREVIEW_WINDOW_CMD" \
                        --preview-window "$PREVIEW_WINDOW_OPTS" \
                        --preview-label ' Expanded view ' \
                        --bind "ctrl-l:toggle-preview" \
                        --bind "shift-right:change-preview-window($MENU_PREVIEW_POS_MODES)+preview:$FZF_PREVIEW_WINDOW_CMD" \
                        --bind "ctrl-l:toggle-preview" \
                        --bind "ctrl-b:change-prompt($(printf "\033[44;37m BLU-RAY: \033[0m"))+reload:printf \"%s\" '$nyaa_search_res' | jq '.name' | sed 's/^\"//g' | sed 's/\"$//g' | sed -En '/[bB][dD]|[bB][lL][uU][\-]*[rR][aA][yY]/p'" \
                        --bind "tab:change-prompt($PROMPT_TEXT)+reload:printf \"%s\" '$nyaa_search_res' | jq '.name' | sed 's/^\"//g' | sed 's/\"$//g'" \
                        --bind "ctrl-a:change-prompt($(printf "\033[43;37m DUAL-AUDIO: \033[0m"))+reload:printf \"%s\" '$nyaa_search_res' | jq '.name' | sed 's/^\"//g' | sed 's/\"$//g' | sed -n '/[dD][uU][aA][lL]/p'" \
                        --bind "ctrl-d:change-prompt($(printf "\033[46;37m DUBBED: \033[0m"))+reload:printf \"%s\" '$nyaa_search_res' | jq '.name' | sed 's/^\"//g' | sed 's/\"$//g' | sed -n '/[dD][uU][bB]/p'" \
                        --bind "ctrl-r:change-prompt($(printf "\033[101;37m RAW: \033[0m"))+reload:printf \"%s\" '$nyaa_search_res' | jq '.name' | sed 's/^\"//g' | sed 's/\"$//g' | sed -n '/[rR][aA][wW]/p'" \
                        --bind "ctrl-s:change-prompt($(printf "\033[103;90m SUBBED: \033[0m"))+reload:printf \"%s\" '$nyaa_search_res' | jq '.name' | sed 's/^\"//g' | sed 's/\"$//g' | sed -n '/[sS][uU][bB]/p'" \
                        --bind "ctrl-f:change-prompt($(printf "\033[104;37m MULTI: \033[0m"))+reload:printf \"%s\" '$nyaa_search_res' | jq '.name' | sed 's/^\"//g' | sed 's/\"$//g' | sed -n '/[mM][uU][lL][tT][iI]/p'" \
                        --bind "ctrl-v:change-prompt($(printf "\033[100;90m VHS: \033[0m"))+reload:printf \"%s\" '$nyaa_search_res' | jq '.name' | sed 's/^\"//g' | sed 's/\"$//g' | sed -n '/[vV][hH][sS]/p'" \
                        --bind "ctrl-t:change-prompt($(printf "\033[42;37m TRUSTED: \033[0m"))+reload:printf \"%s\" '$nyaa_search_res' | jq '.name' | sed 's/^\"//g' | sed 's/\"$//g' | sed -n '/üü¢/p'" \
                        --bind "ctrl-o:change-prompt($(printf "\033[45;37m OVA: \033[0m"))+reload:printf \"%s\" '$nyaa_search_res' | jq '.name' | sed 's/^\"//g' | sed 's/\"$//g' | sed -n '/[oO][vV][aA]/p'"
            )
            [ "$choice" = "$TO_MAIN_MENU" ] && play_status="$PLAY_STATUS_EXITED" && return
            magnet_link="$(printf "%s" "$nyaa_search_res" | jq -c "select( .name == \"$choice\" )" | jq --raw-output ".magnet")"
        fi
        if [ -z "$file_list" ]; then
            echo && line_to_remove
            printf "$MSG_INFO_COLOR%s$RESET" "      üóÉÔ∏è  Searching for matching file..." && line_to_remove
            play_episode_TORRENT_INFO="$(python3 "$NYAA_FE_BIN" --title "$play_episode_anime_title" --synonyms "$(printf "%s" "$show_synonyms")" --magnet-link "$magnet_link" --episode "$play_episode_anime_episode" --type "$show_type")"
            EP_DATA="$(printf "%s" "$play_episode_TORRENT_INFO" | awk -F"////" '{print $1}')"
            file_list="$(printf "%s" "$play_episode_TORRENT_INFO" | awk -F"////" '{print $2}')"
            file_index="$(printf "%s" "$play_episode_TORRENT_INFO" | awk -F"////" '{print $3}')"
            debug_match_info=$EP_DATA
        fi

        [ "$file_index" = "$NYAA_FID_CODE_CONTENT_MISMATCH" ] && play_status="$PLAY_STATUS_FILE_SEL"

        if [ "$play_status" = "$PLAY_STATUS_FILE_SEL" ]; then
            if [ "$file_list" = "None" ]; then
                printf "$MSG_WARN_COLOR%s$RESET" "      üö´ No matching files, please select another source" && line_to_remove
                magnet_link=""
                file_list=""
                play_status=$PLAY_STATUS_ERRORED
                return
            fi
            FZF_PREVIEW_WINDOW_CMD="printf \"\n%s\n\n%b\" {}"
            file_index=$(
                printf "%b" "$file_list\n‚óÄ Now Playing" | sed "s/\"//g" |
                    $FZF -i --prompt "Choose a file: " \
                        --border-label "‚ï¢ ‚ô£  üóÉÔ∏è  FILE SELECTION: $(trim "$play_episode_anime_title") ‚ñ∂ $play_episode_anime_episode ‚ô£  ‚ïü" \
                        --header "‚áÖ Navigation ‚îÄ [ESC] Exit ‚îÄ [Ctrl-L] Expand ‚îÄ [Enter] Stream (torrenting) ‚ñ∏" \
                        --header-first \
                        --preview "$FZF_PREVIEW_WINDOW_CMD" \
                        --preview-window "$PREVIEW_WINDOW_OPTS" \
                        --bind "shift-right:change-preview-window($MENU_PREVIEW_POS_MODES)+preview:$FZF_PREVIEW_WINDOW_CMD" \
                        --preview-label ' Expanded view ' \
                        --bind "ctrl-l:toggle-preview" | cut -d " " -f1
            )
        fi

        [ "$file_index" = "‚óÄ" ] && play_status="$PLAY_STATUS_OKPLAYING" && return

        if [ "$file_index" != "$NYAA_SEARCH_CODE_FATAL_ERROR" ]; then
            # run completely detached from terminal for availability
            torrent_pid_file="$(get_temp_filename)"
            set +m
            (
                nohup node "$WEBTORRENT_CLI" download "$magnet_link" --select "$file_index" --out "$TORRENT_DOWNLOAD_DIR" --"$MEDIA_PLAYER" >"$WEBTORRENT_LOGFILE" 2>&1 &
                echo $! >"$torrent_pid_file"
            )
            set -m
            # printf "%s" "$EP_DATA" | jq '.name' >"$CURRENTLY_PLAYING_LOGFILE"
            # remove from job queue to avoid info messages if we have to end the process with kill
            echo && line_to_remove
            printf "$MSG_INFO_COLOR%s$RESET" "      üöÄ Torrent is playing soon (please wait...)" && line_to_remove
            play_episode_torrent_status=$(check_torrent_health "$(cat "$torrent_pid_file")")
            if [ "$play_episode_torrent_status" -eq $TORRENT_STATUS_ERRORED ]; then
                printf "$MSG_WARN_COLOR%s$RESET" "      üö´ Unable to play torrent" && line_to_remove
                magnet_link=""
                play_status=$PLAY_STATUS_ERRORED
            else
                rm "$torrent_pid_file"
                play_status=$PLAY_STATUS_OKPLAYING
            fi
        else
            printf "$MSG_WARN_COLOR%s$RESET" "      üö´ Unable to get file index" && line_to_remove
            magnet_link=""
            file_list=""
            play_status=$PLAY_STATUS_ERRORED
        fi
    elif [ "$player_source" = "streaming" ]; then
        stream_providers=$(array "animepahe" "allanime" "zoro" "animeout" "gogoanime" "tenshi")
        echo && line_to_remove
        printf "$MSG_INFO_COLOR%s$RESET" "      üí° Streaming (animdl)" && line_to_remove
        while IFS= read -r provider; do
            d_provider=$(printf '%s\n' "$provider" | array_element_decode)
            if [ "$animdl_playthrough" -eq 0 ]; then
                play_episode_stream_fifo_write="$(get_temp_filename)"
                mkfifo -m 600 "$play_episode_stream_fifo_write"
                # TODO: can't stream with iina
                set +m
                nohup animdl stream "$d_provider:$play_episode_anime_title" --range "$anime_ep" --player "mpv" <"$play_episode_stream_fifo_write" >"$ANIMDL_LOGFILE" 2>&1 &
                animdl_pid=$!
                set -m
                exec 4>"$play_episode_stream_fifo_write"
                printf "$MSG_INFO_COLOR%s$RESET" "      üîé Please wait, searching the stream provider ($d_provider)..." && line_to_remove
                stream_health=10
                while [ $stream_health -gt 0 ]; do
                    # check for search result prompt
                    if ! grep "Select the search result" "$ANIMDL_LOGFILE" >/dev/null 2>&1; then
                        if [ -z "$(sed -En "s/AV:|libmpv|A-V/&/p" "$ANIMDL_LOGFILE")" ]; then
                            stream_health=$((stream_health - 1))
                        else
                            # stream started automatically
                            play_status=$PLAY_STATUS_OKPLAYING
                            printf "$MSG_INFO_COLOR%s$RESET" "      üöÄ The stream is starting (please wait...)" && line_to_remove
                            return
                        fi
                    else
                        break
                    fi
                    sleep 1
                done
                if [ $stream_health -eq 0 ]; then
                    printf "$MSG_WARN_COLOR%s$RESET" "      üö´ No results found ($d_provider), next..." && line_to_remove
                    play_status=$PLAY_STATUS_ERRORED
                    # next provider
                    echo >"$ANIMDL_LOGFILE"
                    continue
                fi
                clear_lines
                results=$(sed -En '/^[[:space:]]+[0-9]+\./p' "$ANIMDL_LOGFILE")
                animdl_search_index="$(
                    printf "%b" "$TO_MAIN_MENU\n$results" | sed "s/^[[:space:]]*//" |
                        $FZF --prompt="Select a search result: " \
                            --border-label "‚ï¢ ‚ô£  SEARCH RESULTS ($d_provider): $(trim "$play_episode_anime_title") ‚ñ∂ Episode $anime_ep ‚ô£  ‚ïü" \
                            --header "‚áÖ Navigation ‚îÄ [ESC] Exit ‚îÄ [Enter] Play" \
                            --header-first | cut -d '.' -f1
                )"
                [ -z "$animdl_search_index" ] && exit 1
                [ "$animdl_search_index" = "$TO_MAIN_MENU" ] && play_status=$PLAY_STATUS_EXITED && animdl_search_index="" && return
                printf "%b" "$animdl_search_index\n" >&4
                # shellcheck disable=2188
                4>&-
                sleep 2 # wait for the stream to start
                stream_health=15
                printf "$MSG_INFO_COLOR%s$RESET" "      Trying to stream with $d_provider" && line_to_remove
                while [ $stream_health -gt 0 ]; do
                    if [ -z "$(sed -En "s/AV:|libmpv|A-V/&/p" "$ANIMDL_LOGFILE")" ]; then
                        stream_health=$((stream_health - 1))
                    else
                        break
                    fi
                    sleep 1
                done
                if [ $stream_health -eq 0 ]; then
                    echo && line_to_remove
                    printf "$MSG_WARN_COLOR%s$RESET" "      üö´ Unable to stream with $d_provider, next..." && line_to_remove
                    play_status=$PLAY_STATUS_ERRORED
                    # next provider
                    echo "" >"$ANIMDL_LOGFILE"
                    continue
                else
                    rm "$play_episode_stream_fifo_write"
                    unset stream_tmpfile
                    unset stream_fifo_write
                    printf "$MSG_INFO_COLOR%s$RESET" "      üöÄ The stream is starting (please wait...)" && line_to_remove
                    play_status=$PLAY_STATUS_OKPLAYING
                    return
                fi
            else
                [ -z "$animdl_search_index" ] && exit 1
                # TODO: can't stream with iina
                set +m
                nohup animdl stream "$d_provider:$play_episode_anime_title" --index "$animdl_search_index" --range "$anime_ep" --player "mpv" >"$ANIMDL_LOGFILE" 2>&1 &
                set -m
                sleep 2 # wait for the stream to start before presenting the streaming options
                stream_health=10
                while [ $stream_health -gt 0 ]; do
                    if [ -z "$(sed -En "s/AV:|libmpv|A-V/&/p" "$ANIMDL_LOGFILE")" ]; then
                        stream_health=$((stream_health - 1))
                    else
                        break
                    fi
                    sleep 1
                done
                if [ $stream_health -eq 0 ]; then
                    echo && line_to_remove
                    printf "$MSG_WARN_COLOR%s$RESET" "      üö´ Unable to stream with $d_provider" && line_to_remove
                    play_status=$PLAY_STATUS_ERRORED
                    # next provider
                    continue
                else
                    play_status=$PLAY_STATUS_OKPLAYING
                    return
                fi
            fi
        done <<EOF
$stream_providers
EOF
    elif [ "$player_source" = "self_magnet" ]; then
        echo && line_to_remove
        printf "$MSG_INFO_COLOR%s$RESET" "      üß≤ Paste your magnet link and press Enter (silent input): " && line_to_remove
        stty_orig=$(stty -g)
        stty -echo
        read -r magnet_link
        stty "$stty_orig"
        magnet_link="$(printf "%s" "$magnet_link" | sed "s/;//g" | tr -d '\012')" # newline esc seq in octal
        clear_lines
        player_source="torrenting"
        play_episode "$anime_title_trackma" "$anime_ep" "$player_source" "$status" "$show_type" "$show_synonyms"
    fi
}

paint_logo() {
    LOGO_MONOCHROME="H4sIAEdnvWMAA+Pi4lIAg/DUnOT83FSFknwF0sGjOSugxjya1vFoWgMYdSBzWoCciWDWRLhwC7oyhccNDbhlsZiIXaYByURkNchObAEjqLaJYATiNEDUw4Ub4DIYTkSXxWEiFhk0TyOpaYA7sQFmRgMWTgOaMJoMxIlYZInkoNiAYheYU2agZ6BnyAUAdHKfkjoCAAA="
    LOGO_DEFAULT_B64="H4sIAEFjvWMAA73WO24bMRAG4F5XcMMTBHzvLuYgKVIG7mKkCVKrcKFWTaocIOdyLpJ/tPIuZ4aSFoHkQpbxYTgkxeHj6UsaKVIs5fTxL7un/xEnJDxK8gD5bOTZyDcjX418FxIhL0aejTgjP4yIzPhPtfpQyQ8T/yiJpqLuJqaiHidh+EBJjxJvKupuYirqgWJq7CRvv/8Y221o10qY6h3l7ddBWDjZfqPZtu5W1DjYbFfs1ZjrRB03ZpNxuvZm0eNNnWypM7ZO3DDZfCdzm6L62aTpypvl735LlO4zd/J7O9Oz9eIOxtymKJWt1ot2MOY2Rels8aK9GnOdqMOtbKVThWc7GHObonS2TsVdNNeJOtwnW+7Ub+7U6hWzbXdC9L16PzE1mjs1mju7oGuBgm6bBoqyB0gyUSNlfT7hBVSMFaqmbaFB9RBp1L80bDItEwWzJIxB5fMUomkMTHp8seJX0BnjgLIxkUAzlRlF3zHjjDBxfOCabvjGMRgYZUZ8myOSUc06jEyq5zDh6WXm4vGqND2fUUSGihe7yXlC2Teqppi4TLHqmruI5kcLgdFpGntxoxk4vieNeGNFU1R+oqT21Ew6rlIKeuAX0ZSfT4xOk9lZ77gOHAWFB1uSZcroZzxYdIICJbk2acV9g9NIqXZtzYddibHItVrt9aoFmgoluQ9ggW3XSqTU7gG/ScaJcrOOOJU3SaUc2hHlcbFjawPleMHWtgPhWZWbZWbJlJOOCrOt2SqNvmOIE+u+2NoDTtNRR80m1jfnvhU21wpmL6ogp8WOtwyzH4TFxfateba110ADZiUq44LVQZs/m2sFM53aIzNNVAubM9LkYktUxMsbf7fZQNVTEbW0mLsaVRc7NlZGKqLicG++2761wrb2kM/SRsEwXlFdKfUt6rawQKWpONzM2G5F1DQMm6mIWzPx8nFLZQMVUV+4mFHWpalCljK3XKIitm5WLdnS3OtqWHoMcNAWuO3SAy5ulInKhncO5iCqC++DpMfLxsvTZIMU3SeOuoyFbWfPhvGKmsN7AT+KagvzHLf2kHBzcZ8/Wxk5v18En8qtPrXCRdPE4K5MMgYSOSYsgoeA58z/APGbmLr7FAAA"
    LOGO_XMAS_B64="H4sIALYVt2MAA8XXPW4UQRAF4NynWC6A+r9nVGcgBgkngMiwkAAhk22wAQFCckLqu8EFOAKvZtbWdvWb8RpYO7DX+lRb1d1T3dM+v/SvX8ZBgoScpx93cXZ+LG6OQn8ifG4wVeBbhu8YvmH4nuGFxcAKBTLOCT8x7Aqxr+Ovx8T0UOgeCAPrz5Mga9rHRV9PhL+vv++sRxas+Iyh3UoTfjgGnfbtF4a2+oQvGNrdPeEri9q3Hxk+YdhVT9NCfbtmbo9WnoH18wnQjwX488dXztt7MU3SFfQ81vPMq7xjbAsOdYq94mwzr0UvZLZTWcoc6Zj3vBDd5SZbbSm2jjTzGtvME/7aHheb+CgSL5foaqxHd7lZR0+4EEsyr/JRBQvv/sL3yjrb9ShsC5XACwaeeZVpElsw80bPvNH/gruCvKMz3ytr/G+ZE98re7ZJJj5jaEfBkVwt/guSkTrabetMk3QFeWws4smxGqsEzpElGSR1BWOWQh4RuLIUQQYWHWTsM0fxdC5wOhknPrDk8LgQn0j+UNGP3WhUy0I0W4CQcFwx1xdGn13fnuSkx93S9ysT8MlWRp2tjB9mt9n9iNsriQ8ON3qWf3I7Gl/w/xSJxnU1ZNLOi54ksBWevasKZR3m/ezdGsCHFe/y4LNfedxWoX20GyWyrbvoRaJneSbvqkIDi46z2zmpR/K8b7zJgz7FFTiana3qVEm0l5ht9rjo4yDRPL4bNLlxCNSZd4YxvrrMTUEvY5Y4tO8BoFfcHINBonnwjuMwSnJ3I142M7YjVS6S7H5Nw128NVwlhbZgFVxJkz0LlZMkexQqe8JFBjfz1jCi2265RROLd8CwyLZVUtrzxmDmsViNYscc78tYJttBKex5Y9CRWC8VE7evtGUuVbnJ7KRg2vbwV87Kh7Fx3GOb94AP54ffJUq2/07dzU3uKsVJbs+kWzSx5ZavWsYls+cseZBsu1Q5K28YmtgkOEuybd0lhgWSBOwltx2NCwn2crbdD8a2zdlm1oetKXrGxO3tAPcObJjcNrpinlPY2NSnCDhP4jwOy6FPEtBfXpNsDDqSAicwZmhbVxkztP0f8GKqXWZgJrE4lhMaxCySMqZiexrXJ30G3TjATqObghEvZY39bHDQcu4Q8VP0608Nai+2kbgWxC4SOA3KHyIuRU4L/QEhaktX3RcAAA=="
    LOGO_HALLOWEEN_B64="H4sIADEPt2MAA8XXO24UQRAG4NynWC6A+j09qgtwAwJIAJHxChCPbCUcECE5IeUg3AYuwBH4a2ZtbVf/PV4DNoG91qfaqu6e6p724w/+6aNYJUjIeflxL88en4q7k9DfEj40mCbgc4YvGD5j+JrhS4uBFQpknAu+ZdgVYl/HX/8T012huyMMrD9vBVnT3i3++vblk3E/keAFHzB8wvDNSRiBHxl21SOrHln1SDayqyO0+2vB9wztRuaoffuK4T2GdpoL/vp28Z25PVp5BtbPt4B+LsAfXz9z3t+IaZKuoOexnmfe5HPGtmCdltgLzjbzVvQgs53KKHOkYz7wILrLTXbVKHaaaeYttpkX/Lk/LTbxUSReLtHV2I7ucrOOXnAQSzJv8kkFC+/+wvfKNtv1KGwLlcALBp55k2kSWzDzRs+80f+Au4K8ozPfK1v8d5kT3ysHtkkWPmNoR8GRXC3+CZKROtpt20yTdAV5bCziybEaJwmcI0tSJXUFY5ZCHhF4YimCVBYdZO4zR/F0LnA6GSc+sOTwOIhPJH+Y0I/daFTLIJotQEg4rpjrC6PPrm9PctLjbun7lQn4ZCujzlbG19Vtdj/j9krig8ONnuVf3I7GF/w/RaJxVw2ZtPPQkwS2wqt3VaGsw7xfvVsDeN3wLg8++5XHbRXaR7tZItu6Qy8SPcuzeFcVGlh0XN3OST2S533pTR70Ka7A0exsVadKor3EbLPHoc9Vonl8l2hy4xCYVj43jPFNY24KepmzxNq+B4BecXcKBonmwTuOdZbkrke8bFZsR6pcJNn9mup1vDc8SQptwUlwJU32LFROkuxRqOwJF6lu5b1hRLfdcoUmFu+AOmTbKikdeGcw81isRrFjjjdlLJPtoBQOvDPoSKyXCRO3r7Qxl0m5yeykYNr28FfOysexcT5gm/eIj+eH3yVKtv9OXc9N7kmKk9yeSVdoYssVX7SMS2bPWXKVbLtUOSvvGJrYJDhLsm3dEcMCSQL2ktuOxoUEeznb7gdj2+ZsM+vD1hQ9Y+L2doB7BzZMbhtdMa8pbGzqUwScJ3Edh+XQJwnoL69JdgYdSYETGDO0rauMGdr+D3gxTV1mYCaxOJYTGsQskjKmYnsa1yd9Bt04wE6jm4IRL2WNfWewajl3jPgp+vX7BrUX20hcC2IXCVwG5Y8RlyKnhc5+AyB6tXLeFwAA"

    # print the logos
    [ "$MONOCHROME_LOGO" -eq 1 ] && LOGO_B64=$LOGO_MONOCHROME || LOGO_B64=$LOGO_DEFAULT_B64
    # special dates
    [ "$DATE_MONTH" -eq 10 ] && [ "$DATE_DAY" -eq 31 ] && LOGO_B64=$LOGO_HALLOWEEN_B64
    [ "$DATE_MONTH" -eq 12 ] && [ "$DATE_DAY" -eq 24 ] || [ "$DATE_DAY" -eq 25 ] && LOGO_B64=$LOGO_XMAS_B64
    # [ $DATE_MONTH -eq 12 ] && [ $DATE_DAY -eq 31 ] && LOGO_B64=$LOGO_NEWYEAR_B64

    if [ "$DEBUG" -eq 0 ]; then
        printf "%b\n" "$(
            base64 -d <<EOF | gunzip
$LOGO_B64
EOF
        )"
    fi
    printf "$TITLE_COLOR%s$RESET" "      üçø Watch and Track Anime from Your Terminal"
    printf "$MSG_HELP_COLOR%s$RESET" "         Use arrow keys/mouse scroll to navigate. Type to filter results" && echo

}

print_account() {
    clear_lines
    printf "$SUBTITLE_COLOR%s$RESET" "      üë§ Account ‚îÄ ${USERNAME} ‚îÇ"
}

print_incognito_msg() {
    clear_lines
    printf "      "
    printf "$INCOGNITO_MODE_COLORS%s$RESET" "üïµ  INCOGNITO MODE "
}

check_torrent_health() {
    # allow it to start first
    sleep 2
    check_torrent_health_waitingtime=0
    check_torrent_health_checkinterval=5
    check_torrent_health_torrent_status=$TORRENT_STATUS_STALLED
    check_torrent_health_webtorrentpid="$1"
    while [ $check_torrent_health_torrent_status = "$TORRENT_STATUS_STALLED" ] && [ $check_torrent_health_waitingtime -lt $TORRENT_TMOUT ]; do
        # if the torrent is not finding peers
        # before or after download start
        lastlog="$(tail -n20 "$WEBTORRENT_LOGFILE")"
        if [ -z "$(printf "%s" "$lastlog" | sed -n "/Streaming/p")" ] || [ -n "$(printf "%s" "$lastlog" | sed -n "/Peers: 0\/0/p")" ]; then
            check_torrent_health_waitingtime=$((check_torrent_health_waitingtime + check_torrent_health_checkinterval))
            sleep $check_torrent_health_checkinterval
        else
            break
        fi
    done
    if [ $check_torrent_health_waitingtime -eq $TORRENT_TMOUT ]; then
        # kill the process
        kill -9 "$check_torrent_health_webtorrentpid" >/dev/null 2>&1
        printf "%s" "$TORRENT_STATUS_ERRORED"
    else
        printf "%s" "$TORRENT_STATUS_OKPLAYING"
    fi
}

account_menu() {
    MAIN_MENU_HELPTEXT="
üêá  Follow the white rabbit for more menu options.
‚îÄ‚îÄ‚îÄ
üïµÔ∏è  Switch Incognito Mode on. Browse and watch without syncing your activity with any account.
‚îÄ‚îÄ‚îÄ
üëç  Score an anime or change an anime score.
‚îÄ‚îÄ‚îÄ
üîÑ  Update the status of your anime.
‚îÄ‚îÄ‚îÄ
üìô  Browse all your lists. It can also play anime.
‚îÄ‚îÄ‚îÄ
üß©  Add a new anime to your Plan to Watch list.
‚îÄ‚îÄ‚îÄ
üîÄ  Select one random anime from your watching lists (watching, rewatching) and play it.
‚îÄ‚îÄ‚îÄ
üì∫  Open your watching lists (watching, rewatching) for playing an anime.
‚îÄ‚îÄ‚îÄ
üëÅÔ∏è  Your watching history with anime and episode count.
"

    SUB_MENU_HELPTEXT="
üåü  Display your lists in descending order by score.
‚îÄ‚îÄ‚îÄ
‚Üë  Upload your local progress to your tracking service.
‚îÄ‚îÄ‚îÄ
‚Üì  Download your remote progress and update your local lists.
‚îÄ‚îÄ‚îÄ
üìù  Set the alternative name for an anime.
‚îÄ‚îÄ‚îÄ
üîÑ  Update your watching progress on an anime.
‚îÄ‚îÄ‚îÄ
üì£  Display your lists by showing currently airing anime only.
‚îÄ‚îÄ‚îÄ
üì£  Play one random, currently airing anime from your watching lists (watching, rewatching).
‚îÄ‚îÄ‚îÄ
üóëÔ∏è  Delete an anime from your lists. You will lose all your progress on that anime.
‚îÄ‚îÄ‚îÄ
üë§  Switch between the various accounts connected to Trackma.
"
    prompt=""
    MAINMENU_ENTRIES="$WATCH_HISTORY\n$WATCH\n$WATCH_RANDOM\n$ADD_SHOW\n$LIST\n$UPDATE_STATUS\n$SCORE_SHOW\n$ENTER_INCOGNITO_MODE\n$TO_SUBMENU"
    SUBMENU_ENTRIES="$SWITCH_ACCOUNTS\n$DELETE_SERIES\n$WATCH_RAND_AIRING\n$LIST_AIRING\n$UPDATE_EPISODES\n$SET_ALTNAME\n$PULL\n$PUSH\n$LIST_BY_SCORE\n$TO_MAIN_MENU"
    MAINMENU_TITLE="MAIN MENU"
    SUBMENU_TITLE="SUB üê∞ MENU"
    menu_entries=$MAINMENU_ENTRIES
    menu_title=$MAINMENU_TITLE
    menu_help_text=$MAIN_MENU_HELPTEXT
    WATCH_HISTORY_FILE="${CONFIG_PATH}/$(printf "%s" "$USERNAME" | sed -E 's/[^a-zA-Z0-9]//g')-watch-history"
    [ ! -f "$WATCH_HISTORY_FILE" ] && touch "$WATCH_HISTORY_FILE"
    if [ "$TRACKER_SERVICE" = "anilist" ]; then
        # exception for anilist
        TRACKMA_STATUS_MENU_ENTRIES="$(printf "%b" "Watching\nCompleted\nRewatching\nPaused\nDropped\nPlan to Watch" | sort -r)"
    else
        TRACKMA_STATUS_MENU_ENTRIES="$(printf "%b" "Watching\nCompleted\nOn Hold\nDropped\nPlan to Watch" | sort -r)"
    fi
    while true; do
        if [ -z "$prompt" ]; then
            clear_modifiers
            FZF_PREVIEW_WINDOW_CMD="printf \"%s\" \"$menu_help_text\""
            prompt=$(
                printf "%b" "$menu_entries" |
                    $FZF -i --prompt="Choose an action: " \
                        --border-label "‚ï¢ ‚ô£  $menu_title ‚ô£  ‚ïü" \
                        --header "‚áÖ Navigation ‚îÄ [ESC] Exit ‚îÄ [Ctrl-L] Help ‚îÄ [Enter] Select" \
                        --header-first \
                        --preview "$FZF_PREVIEW_WINDOW_CMD" \
                        --preview-window "$PREVIEW_WINDOW_OPTS" \
                        --bind "shift-right:change-preview-window($MENU_PREVIEW_POS_MODES)+preview:$FZF_PREVIEW_WINDOW_CMD" \
                        --bind "ctrl-l:toggle-preview" \
                        --preview-label " Help "
            )
        fi
        case $prompt in
        "$SWITCH_ACCOUNTS")
            line_to_remove # remove account label
            clear_lines    # remove account label
            printf "account\n" | trackma_query >/dev/null 2>&1
            # select_account
            break
            ;;
        "$ENTER_INCOGNITO_MODE")
            INCOGNITO_MODE=1
            line_to_remove # remove account label
            clear_lines    # remove account label
            close_trackma
            break
            ;;
        "$TO_MAIN_MENU")
            menu_entries=$MAINMENU_ENTRIES
            menu_title=$MAINMENU_TITLE
            menu_help_text=$MAIN_MENU_HELPTEXT
            clear_modifiers
            ;;
        "$TO_SUBMENU")
            menu_entries=$SUBMENU_ENTRIES
            menu_title=$SUBMENU_TITLE
            menu_help_text=$SUB_MENU_HELPTEXT
            clear_modifiers
            ;;
        "$WATCH_HISTORY")
            clear_modifiers
            if [ ! -s "$WATCH_HISTORY_FILE" ]; then
                sel=$(printf "Your watch history is empty\n%s" "$TO_MAIN_MENU" | $FZF -i --border-label "‚ï¢ ‚ô£  YOUR WATCH HISTORY ‚ô£  ‚ïü" --header "‚áÖ Navigation ‚îÄ [ESC] Exit" --header-first)
            else
                HIST=$(column -t -s "////" "$WATCH_HISTORY_FILE")
                HIST="$TO_MAIN_MENU\n$HIST"
                sel=$(printf "%b" "$HIST" | $FZF -i --prompt="Select an anime: " --border-label "‚ï¢ ‚ô£  WATCH HISTORY ‚ô£  ‚ïü" --header "[Enter] Play ‚ñ∏ new episode" --header "‚áÖ Navigation ‚îÄ [ESC] Exit ‚îÄ [Enter] Play ‚ñ∏" --header-first --tac --no-sort)
                [ "$sel" = "$TO_MAIN_MENU" ] && prompt=$TO_MAIN_MENU && continue
                anime_title_trackma=$(printf "%s" "$sel" | sed -En "s/^(.*)[[:space:]]+([[:digit:]]+)$/\1/p" | sed "s/[[:space:]]*$//")
                last_show_episode="$(get_last_show_ep "$anime_title_trackma")"
                [ -z "$last_show_episode" ] && printf "Could not get last episode" && exit 1
                last_watched_ep=$(printf "%s" "$sel" | sed -En "s/^(.*)[[:space:]]+([[:digit:]]+)$/\2/p" | sed "s/[[:space:]]*$//")
                # only increment if it's not the last episode of the show
                # if we don't know the last aired apisode just attempt playing the next episode
                [ "$last_show_episode" = "?" ] || [ "$last_watched_ep" -lt "$last_show_episode" ] && anime_ep=$((last_watched_ep + 1)) || anime_ep="1"
                status="$(get_show_status "$(printf "%s" "$anime_title_trackma" | sed "s/\[.*\]//g" | sed "s/ $//g")")"
                trackma_index="$(get_entry_index "$(printf "%s" "$anime_title_trackma" | sed "s/\[.*\]//g" | sed "s/ $//g")" "$status")"
                prompt="$WATCH"
            fi
            ;;
        "$WATCH_RANDOM")
            random_anime=1
            prompt=$WATCH
            ;;
        "$WATCH_RAND_AIRING")
            random_airing=1
            prompt=$WATCH
            ;;
        "$WATCH")
            # This section plays shows currently being watched by default or one specified show
            if [ -z "$anime_title_trackma" ] && [ -z "$anime_ep" ]; then
                full_info=$(get_watching_shows)

                if [ ! "$full_info" ]; then
                    full_info="Your watching list is empty"
                    choice=$(
                        printf "%s\n%s" "$full_info" "$TO_MAIN_MENU" |
                            $FZF -i --prompt "Choose an anime to watch: " \
                                --border-label "‚ï¢ ‚ô£  YOUR $(
                                    if [ "$TRACKER_SERVICE" = "anilist" ]; then
                                        printf "%s" "(RE)WATCHING LISTS"
                                    else
                                        printf "%s" "WATCHING LIST"
                                    fi
                                ) ‚ô£  ‚ïü" \
                                --header "‚áÖ Navigation ‚îÄ [ESC] Exit ‚îÄ [Enter] Play ‚ñ∏" \
                                --header-first
                    )
                    clear_modifiers
                    continue
                fi

                # remove character sequences and add an emoji next to shows currently airing
                full_info=$(printf '%s\n' "$full_info" | sed "s,$(printf '\033')\\[[0-9;]*[a-zA-Z],üì£ ," | sed "s,$(printf '\033')\\[[0-9;]*[a-zA-Z],,g" | sed "s,\x1B\[[0-9;]*[a-zA-Z],,g" | sed -E "/üì£/ s/(.*)\.{3}(.*)/\1\2/")

                if [ "$random_anime" -eq 1 ]; then
                    choice=$(printf "%s" "$full_info" | shuf -n 1)
                elif [ "$random_airing" -eq 1 ]; then
                    # format and filter airing shows, select one randomly
                    choice=$(printf "%s" "$full_info" | sed "s,$(printf '\033')\\[[0-9;]*[a-zA-Z],üì£ ," | sed "s,\x1B\[[0-9;]*[a-zA-Z],,g" | sed -n "/üì£/p" | shuf -n 1)
                else
                    full_info="$(printf "%s" "$full_info" | sort -r --version-sort)"
                    choice=$(
                        printf "%s\n%s" "$TO_MAIN_MENU" "$full_info" |
                            $FZF -i --prompt "Choose an anime to watch: " \
                                --border-label "‚ï¢ ‚ô£  YOUR $(
                                    if [ "$TRACKER_SERVICE" = "anilist" ]; then
                                        printf "%s" "(RE)WATCHING LISTS"
                                    else
                                        printf "%s" "WATCHING LIST"
                                    fi
                                ) ‚ô£  ‚ïü" \
                                --header "‚áÖ Navigation ‚îÄ [ESC] Exit ‚îÄ [Enter] Play ‚ñ∏" \
                                --header-first
                    )
                fi

                [ "$choice" = "$TO_MAIN_MENU" ] && prompt=$TO_MAIN_MENU && continue

                if [ ! "$choice" ]; then
                    echo && line_to_remove
                    printf "$MSG_WARN_COLOR%s$RESET" "      We couldn't find any anime of this type!" && line_to_remove
                    sleep 2
                    clear_lines
                    clear_modifiers
                    continue
                fi
                trackma_index="$(printf "%s" "$choice" | sed -En "s/$TRACKMA_ENTRY_REGEX/\1/p")"
                anime_title_trackma=$(get_show_title "$choice")
                status="$(get_show_status "$(printf "%s" "$anime_title_trackma" | sed "s/\[.*\]//g" | sed "s/ $//g")")"
                trackma_show_index=$(printf "%s" "$choice" | cut -d " " -f1)
                last_watched_ep="$(printf "%s" "$choice" | sed -En "s/.*[[:space:]]+([0-9]*) \/.*/\1/p")"
                last_show_episode="$(get_last_show_ep "$anime_title_trackma")"

                [ -z "$last_show_episode" ] && printf "Couldn't get last episode" && exit 1
                # if we just don't know what the last episode is we increment anyways and give it a try
                [ "$last_show_episode" = "?" ] || [ "$last_watched_ep" -lt "$last_show_episode" ] && anime_ep=$((last_watched_ep + 1)) || anime_ep="1"
            fi

            [ -z "$status" ] && printf "Couldn't get status" && exit 1

            if [ "$(get_trackma_status_code "$status")" != "$(get_trackma_status_code "Watching")" ] && [ "$(get_trackma_status_code "$status")" != "$(get_trackma_status_code "Rewatching")" ]; then
                new_status="Watching"
                menu_play_options="‚ñ∂Ô∏è  Play\nüîÑ Set status as Watching + Play"
                if [ "$status" = "$(get_trackma_status_code "Completed")" ]; then
                    menu_play_options="‚ñ∂Ô∏è Play\nüîÑ Set status as Watching + Reset watched + Continue Playing"
                    reset_episodes=1
                    if [ "$TRACKER_SERVICE" = "anilist" ]; then
                        new_status="Rewatching"
                        menu_play_options="‚ñ∂Ô∏è Play\nüîÑ Set status as Rewatching + Continue Playing"
                    fi
                else
                    reset_episodes=0
                fi

                selected_play_option=$(printf "%b\n%s" "$menu_play_options" "$TO_MAIN_MENU" |
                    $FZF -i --prompt "Choose an option: " --border-label "‚ï¢ ‚ô£  PLAY OPTIONS ‚ô£  ‚ïü" --header "‚áÖ Navigation ‚îÄ [ESC] Exit ‚îÄ [Enter] Select" --header-first | cut -d " " -f1)
                [ "$selected_play_option" = "‚óÇ" ] && clear_modifiers && continue
                if [ "$selected_play_option" = "üîÑ" ]; then
                    printf "filter %s\nstatus '%s' %s\n" "$(get_trackma_status_code "$status")" "$trackma_index" "$(get_trackma_status_code "$new_status")" | trackma_query >"$TRACKMA_LOGFILE" 2>&1
                    if [ $reset_episodes -eq 1 ]; then
                        printf "filter %s\nupdate '%s' %s\n" "$(get_trackma_status_code "$status")" "$trackma_index" "0" | trackma_query >>"$TRACKMA_LOGFILE"
                        anime_ep="1"
                        last_watched_ep="0"
                    fi
                    status=$new_status
                    # update series index after changing lists
                    trackma_index="$(printf "filter %s\nsearch '%s'\n" "$(get_trackma_status_code "$status")" "$(printf "%s" "$anime_title_trackma" | sed "s/'/'\"'\"'/g")" | trackma_query | sed -En "s/$TRACKMA_ENTRY_REGEX/\1/p")"
                fi
            fi

            # We query trackma again because we want official english and romaji titles
            series_info=$(printf "filter %s\ninfo %s\n" "$(get_trackma_status_code "$status")" "$trackma_index" | trackma_query)
            anime_title_ro="$(printf "%s" "$series_info" | sed -n "/Romaji/p" | cut -d ":" -f2 | sed "s/ //")"
            anime_title_en="$(printf "%s" "$series_info" | sed -n "/English/p" | cut -d ":" -f2 | sed "s/ //")"
            # give preference to Romaji, then Japanese, then English titles, as this gives better matching
            if [ -n "$anime_title_ro" ] && [ "$anime_title_ro" != "None" ]; then
                anime_title=$anime_title_ro
            else
                anime_title=$anime_title_trackma
            fi
            show_type=""
            show_synonyms=""
            # player loop
            play_method_menu_opt=""
            player_source=""
            while true; do
                if [ -z "$player_source" ]; then
                    if [ "$random_anime" -eq 1 ]; then
                        menu_label="SELECT SOURCE: üîÄ $(trim "$anime_title_trackma") ‚ñ∂ $anime_ep"
                    elif [ "$random_airing" -eq 1 ]; then
                        menu_label="SELECT SOURCE: üì£ $(trim "$anime_title_trackma") ‚ñ∂ $anime_ep"
                    else
                        menu_label="SELECT SOURCE: $(trim "$anime_title_trackma") ‚ñ∂ $anime_ep"
                    fi
                    play_method_menu_opt="$(
                        printf "%b" "$PLAY_METHOD_MENU" |
                            $FZF -i --prompt="Select a source: " \
                                --border-label "‚ï¢ ‚ô£  $menu_label ‚ô£  ‚ïü" \
                                --header "‚áÖ Navigation ‚îÄ [ESC] Exit ‚îÄ [Enter] Select" \
                                --header-first | cut -d " " -f1
                    )"
                    if [ "$play_method_menu_opt" = "‚óÇ" ]; then
                        prompt="$TO_MAIN_MENU"
                        clear_modifiers
                        break
                    elif [ "$play_method_menu_opt" = "üí°" ]; then
                        player_source="streaming"
                    elif [ "$play_method_menu_opt" = "üò∫" ]; then
                        player_source="torrenting"
                    elif [ "$play_method_menu_opt" = "üß≤" ]; then
                        player_source="self_magnet"
                    fi
                fi
                show_info="$(get_show_info "$anime_title_trackma" "$status")"
                if [ -z "$show_type" ]; then
                    if printf "%s" "$show_info" | grep "Type: " >/dev/null 2>&1; then
                        show_type="$(printf "%b" "$show_info" | grep "Type: " | awk -F": " '{print $2}')"
                    fi
                fi
                if [ -z "$show_synonyms" ]; then
                    if printf "%s" "$show_info" | grep "Synonyms: " >/dev/null 2>&1; then
                        show_synonyms="$(printf "%b" "$show_info" | grep "Synonyms: " | awk -F": " '{print $2}')"
                        show_synonyms="$anime_title_trackma, $anime_title_en, $(printf "%s" "$show_synonyms" | sed "s/[]'[]//g")"
                    fi
                fi
                # finally, play the content and hope for the best
                while true; do
                    play_episode "$anime_title" "$anime_ep" "$player_source" "$status" "$show_type" "$show_synonyms"
                    clear_lines
                    media_player_exit_code=""
                    media_player_menu
                    if [ "$media_player_exit_code" = "$PLAYER_MENU_SOURCE_SELECT_CODE" ] || [ "$media_player_exit_code" = "$PLAYER_MENU_SELECT_SEARCH_RES_CODE" ]; then
                        continue
                    elif [ "$media_player_exit_code" = "$PLAYER_MENU_END_CODE" ]; then
                        # exit player go to main menu
                        break 2
                    fi
                done
            done
            set +u nounset
            if ps "$animdl_pid" >/dev/null 2>&1; then
                kill -9 "$animdl_pid"
            fi
            set -u nounset
            ;;
        "$ADD_SHOW")
            status="Plan to Watch"
            echo && line_to_remove
            printf "      üß© What anime do you plan to watch‚ùî \n         üëâ " && line_to_remove
            read -r series_title
            series_title="$(printf "%s" "$series_title" | sed -E 's/[^a-zA-Z0-9 ]//g')"
            clear_lines
            if [ -z "$series_title" ]; then
                line_to_remove && clear_lines
                clear_modifiers
                continue
            fi
            results="$(printf "filter %s\nadd '%s'\n" "$(get_trackma_status_code "$status")" "$series_title" | trackma_query)"
            printf "$MSG_INFO_COLOR%s$RESET" "      üîé Searching the anime tracker ($TRACKER_SERVICE), please wait..." && line_to_remove
            while [ -z "$(sed -En "/Choose|DataError/p" "$GLOBAL_TRACKMA_TMPFILE")" ]; do :; done
            clear_lines
            results="$(sed -En "/^[0-9]+:/p" "$GLOBAL_TRACKMA_TMPFILE")"
            [ -z "$results" ] && results="No results found.\n$TO_MAIN_MENU"
            choice="$(
                printf "%b" "$results\n$TO_MAIN_MENU" |
                    $FZF --prompt="Choose the anime to add: " \
                        --border-label "‚ï¢ ‚ô£  ADD NEW ANIME ($status list) ‚ô£  ‚ïü" \
                        --header "‚áÖ Navigation ‚îÄ [ESC] Exit ‚îÄ [Enter] Add" \
                        --header-first
            )"
            [ -z "$results" ] && clear_modifiers && continue
            if [ "$choice" = "$TO_MAIN_MENU" ]; then
                printf "\n" >"$GLOBAL_TRACKMA_FIFO"
                clear_modifiers && continue
            fi
            choice_id=$(printf "%s" "$choice" | cut -d ':' -f1)
            printf "%b\n" "$choice_id" >"$GLOBAL_TRACKMA_FIFO"
            clear_modifiers
            ;;
        "$DELETE_SERIES")
            status=$(
                printf "%b\n%s" "$TRACKMA_STATUS_MENU_ENTRIES" "$TO_SUBMENU" |
                    $FZF -i --prompt="Choose a status: " \
                        --border-label "‚ï¢ ‚ô£  DELETE ANIME (Status select) ‚ô£  ‚ïü" \
                        --header "‚áÖ Navigation ‚îÄ [ESC] Exit ‚îÄ [Enter] Select" \
                        --header-first
            )
            [ "$status" = "$TO_SUBMENU" ] && prompt="$TO_SUBMENU" && continue
            status=$(get_trackma_status_code "$status")
            FULL_LIST=$(printf "filter %s\nls\n" "$status" | trackma_query | sed -En "s/$TRACKMA_LIST_REGEX/\1/p" | sed "s,$(printf '\033')\\[[0-9;]*[a-zA-Z],üì£ ," | sed "s,$(printf '\033')\\[[0-9;]*[a-zA-Z],,g" | sed "s,\x1B\[[0-9;]*[a-zA-Z],,g" | sed -E "/üì£/ s/(.*)\.{3}(.*)/\1\2/" | sort -r --version-sort)
            [ -z "$FULL_LIST" ] && FULL_LIST="No entries found in this list..."
            FULL_LIST="$FULL_LIST\n$TO_SUBMENU\n$SWITCH_STATUS_MSG_MENU_ENTRY"
            trackma_show_index=$(
                printf "%b" "$FULL_LIST" |
                    $FZF -i --prompt="Choose an anime to DELETE: " \
                        --border-label "‚ï¢ ‚ô£  DELETE ANIME ‚ô£  ‚ïü" \
                        --header "‚áÖ Navigation ‚îÄ [ESC] Exit ‚îÄ [Enter] Delete" \
                        --header-first | cut -d" " -f1
            )
            [ "$trackma_show_index" = "üêá" ] && prompt="$TO_SUBMENU" && continue
            [ "$trackma_show_index" = "üîÑ" ] && continue
            printf "filter %s\ndelete %s\ny\n" "$status" "$trackma_show_index" | trackma_query >"$TRACKMA_LOGFILE" 2>&1
            ;;
        "$UPDATE_EPISODES" | "$UPDATE_STATUS")
            if [ "$prompt" = "$UPDATE_EPISODES" ]; then
                menuitem="$TO_SUBMENU"
            else
                menuitem="$TO_MAIN_MENU"
            fi
            if [ -z "$new_status" ] && [ -z "$trackma_show_index" ]; then
                # let the user select a show
                status=$(
                    printf "%s\n%s" "$TRACKMA_STATUS_MENU_ENTRIES" "$menuitem" |
                        $FZF -i --prompt="Choose a status: " \
                            --border-label "‚ï¢ ‚ô£  UPDATE EPISODE (Select an anime to update) ‚ô£  ‚ïü" \
                            --header "‚áÖ Navigation ‚îÄ [ESC] Exit ‚îÄ [Enter] Select" \
                            --header-first
                )
                [ "$status" = "$menuitem" ] && prompt=$menuitem && continue

                status=$(get_trackma_status_code "$status")

                res="$(printf "filter %s\nls\n" "$status" | trackma_query | sed -En "s/$TRACKMA_LIST_REGEX/\1/p" | sort -r)"
                if [ -z "$res" ]; then
                    res="This list has no items..."
                    choice="$(
                        printf "%b" "$res\n$menuitem" | $FZF -i --prompt="Choose an anime: " \
                            --border-label "‚ï¢ ‚ô£  UPDATE EPISODE ($status list) ‚ô£  ‚ïü" \
                            --header "‚áÖ Navigation ‚îÄ [ESC] Exit ‚îÄ [Enter] Select" \
                            --header-first
                    )"
                    prompt=$menuitem && continue
                fi

                choice="$(
                    printf "%b" "$res\n$menuitem" |
                        $FZF -i --prompt="Choose an anime: " \
                            --border-label "‚ï¢ ‚ô£  UPDATE EPISODE ($status list) ‚ô£  ‚ïü" \
                            --header "‚áÖ Navigation ‚îÄ [ESC] Exit ‚îÄ [Enter] Select" \
                            --header-first
                )"
                [ "$choice" = "$menuitem" ] && prompt=$menuitem && continue
                trackma_show_index="$(printf "%s" "$choice" | cut -d" " -f1)"
                anime_title_trackma="$(get_show_title "$choice")"

            fi
            if [ "$prompt" = "$UPDATE_EPISODES" ]; then
                echo && line_to_remove
                printf "$MSG_INFO_COLOR%s$RESET" "      How many episodes of this anime have you watched so far‚ùî" && line_to_remove
                printf "%s" "         üëâ " && line_to_remove
                read -r NEW_EPISODE_COUNT # TODO: -n4
                NEW_EPISODE_COUNT="$(printf "%s" "$NEW_EPISODE_COUNT" | sed -E 's/[^0-9]//g')"
                clear_lines
                [ -z "$NEW_EPISODE_COUNT" ] && clear_modifiers && continue
                printf "filter %s\nupdate '%s' %s\n" "$status" "$trackma_show_index" "$NEW_EPISODE_COUNT" | trackma_query >"$TRACKMA_LOGFILE" 2>&1
                # update watch history
                new_hist_content="$(sed -E "s,($(sanitize_ext_regex "$anime_title_trackma"))////.*,\1////$NEW_EPISODE_COUNT,g" "$WATCH_HISTORY_FILE" | sed -E '/^\s*$/d')"
                printf "%s\n" "$new_hist_content" >"$WATCH_HISTORY_FILE"
            else
                if [ -z "$new_status" ]; then
                    new_status=$(
                        printf "%b" "$menuitem\n$TRACKMA_STATUS_MENU_ENTRIES" |
                            $FZF -i --prompt="Choose the new status: " \
                                --border-label "‚ï¢ ‚ô£  UPDATE EPISODE status (Select the NEW status) ‚ô£  ‚ïü" \
                                --header "‚áÖ Navigation ‚îÄ [ESC] Exit ‚îÄ [Enter] Select" \
                                --header-first
                    )
                    [ "$new_status" = "$menuitem" ] && prompt=$menuitem && clear_modifiers && continue
                    new_status="$(get_trackma_status_code "$new_status")"
                fi
                [ -n "$trackma_show_index" ] && TRACKMA_ID="$trackma_show_index" || TRACKMA_ID="$anime_title_trackma"
                printf "filter %s\nstatus '%s' %s\n" "$status" "$TRACKMA_ID" "$new_status" | trackma_query >"$TRACKMA_LOGFILE" 2>&1
            fi
            clear_modifiers
            ;;
        "$SCORE_SHOW")
            # status selection loop
            while true; do
                status=$(
                    printf "%b" "$TO_MAIN_MENU\n$TRACKMA_STATUS_MENU_ENTRIES" |
                        $FZF -i --prompt="Choose a status: " \
                            --border-label "‚ï¢ ‚ô£  SCORE ANIME (Status select) ‚ô£  ‚ïü" \
                            --header "‚áÖ Navigation ‚îÄ [ESC] Exit ‚îÄ [Enter] Select" \
                            --header-first
                )
                status=$(get_trackma_status_code "$status")
                [ "$status" = "$TO_MAIN_MENU" ] && prompt=$TO_MAIN_MENU && clear_modifiers && break
                while true; do
                    full_info="$(printf "filter %s\nls\n" "$status" | trackma_query | sort -r | sed -En "s/$TRACKMA_LIST_REGEX/\1/p")"
                    # remove character sequences and add an emoji next to airing shows
                    full_info=$(printf '%s\n' "$full_info" | sed "s,\x1B\[[0-9;]*[a-zA-Z],,g" | sed "s,$(printf '\033')\\[[0-9;]*[a-zA-Z],üì£ ," | sed "s,$(printf '\033')\\[[0-9;]*[a-zA-Z],,g" | sed -E "/üì£/ s/(.*)\.{3}(.*)/\1\2/")
                    full_info="$full_info\n$TO_MAIN_MENU\n$SWITCH_STATUS_MSG_MENU_ENTRY"
                    # anime selection loop
                    anime_choice="$(
                        printf "%b" "$full_info" |
                            $FZF -i --prompt="Choose an anime: " \
                                --border-label "‚ï¢ ‚ô£  SCORE ANIME ($status) ‚ô£  ‚ïü" \
                                --header "‚áÖ Navigation ‚îÄ [ESC] Exit ‚îÄ [Enter] Select" \
                                --header-first
                    )"
                    [ "$anime_choice" = "$TO_MAIN_MENU" ] && clear_modifiers && break 2
                    [ "$anime_choice" = "$SWITCH_STATUS_MSG_MENU_ENTRY" ] && break
                    anime_choice_id="$(printf "%s" "$anime_choice" | cut -d" " -f1)"
                    anime_choice_name=$(get_show_title "$anime_choice")
                    SCORE_MENU="(10) Masterpiece\n(9) Great\n(8) Very Good\n(7) Good\n(6) Fine\n(5) Average\n(4) Bad\n(3) Very Bad\n(2) Horrible\n(1) Appalling"
                    score=$(
                        printf "%b" "$SCORE_MENU" | $FZF -i --prompt="Select a score: " \
                            --border-label "‚ï¢ ‚ô£  SCORING ANIME: $(trim "$anime_choice_name") ‚ô£  ‚ïü" \
                            --header "‚áÖ Navigation ‚îÄ [ESC] Exit ‚îÄ [Enter] Select" \
                            --pointer üåü \
                            --header-first | sed -En "s/\(([[:digit:]]+)\).*/\1/p"
                    )
                    clear_lines
                    printf "filter %s\nscore %s %s\n" "$status" "$anime_choice_id" "$score" | trackma_query >/dev/null 2>&1
                done
            done
            ;;
        "$SET_ALTNAME")
            status=$(
                printf "$TRACKMA_STATUS_MENU_ENTRIES\n%s" "$TO_SUBMENU" |
                    $FZF -i --prompt="Choose a status: " \
                        --border-label "‚ï¢ ‚ô£  SET ALTERNATIVE NAME (Status select) ‚ô£  ‚ïü" \
                        --header "‚áÖ Navigation ‚îÄ [ESC] Exit ‚îÄ [Enter] Select" \
                        --header-first
            )

            [ "$status" = "$TO_SUBMENU" ] && prompt=$TO_SUBMENU && continue

            while true; do
                full_info="$(printf "filter %s\nls\n" "$status" | trackma_query | sort -r | sed -En "s/$TRACKMA_LIST_REGEX/\1/p")"
                full_info=$(printf '%s\n' "$full_info" | sed "s,\x1B\[[0-9;]*[a-zA-Z],,g" | sed "s,$(printf '\033')\\[[0-9;]*[a-zA-Z],üì£ ," | sed "s,$(printf '\033')\\[[0-9;]*[a-zA-Z],,g" | sed -E "/üì£/ s/(.*)\.{3}(.*)/\1\2/")
                full_info="$full_info\n$TO_SUBMENU\n$SWITCH_STATUS_MSG_MENU_ENTRY"
                trackma_show_index="$(
                    printf "%b" "$full_info" |
                        $FZF -i --prompt="Choose an anime: " \
                            --border-label "‚ï¢ ‚ô£  SET ALTERNATIVE NAME ($status list) ‚ô£  ‚ïü" \
                            --header "‚áÖ Navigation ‚îÄ [ESC] Exit ‚îÄ [Enter] Select" \
                            --header-first
                )"
                [ "$trackma_show_index" = "$TO_SUBMENU" ] && prompt=$TO_SUBMENU && break
                [ "$trackma_show_index" = "$SWITCH_STATUS_MSG_MENU_ENTRY" ] && break
                trackma_show_index=$(printf "%s" "$trackma_show_index" | cut -d" " -f1)
                printf "%b" "
                 ‚Ñπ  What is the altname‚ùî "
                read -r NEWNAME
                printf "altname %s '%s'\n" "$trackma_show_index" "$NEWNAME" | trackma_query >"$TRACKMA_LOGFILE" 2>&1
            done
            clear_modifiers
            ;;
        "$PULL")
            sel=$(
                printf "üîÑ Overwrite local lists\n%s" "$TO_MAIN_MENU" |
                    $FZF -i --prompt="Choose an option: " \
                        --border-label "‚ï¢ ‚ô£  $PULL ‚ô£  ‚ïü" \
                        --header "‚áÖ Navigation ‚îÄ [ESC] Exit ‚îÄ [Enter] Select" \
                        --header-first | cut -d" " -f1
            )
            [ "$sel" = "$TO_MAIN_MENU" ] && prompt=$TO_MAIN_MENU && continue
            [ "$sel" = "üîÑ" ] &&
                printf "retrieve\n" | trackma_query >/dev/null 2>&1
            clear_modifiers
            ;;
        "$PUSH")
            sel=$(
                printf "üîÑ Overwrite remote lists\n%s" "$TO_MAIN_MENU" |
                    $FZF -i --prompt="Choose an option: " \
                        --border-label "‚ï¢ ‚ô£  $PUSH ‚ô£  ‚ïü" \
                        --header "‚áÖ Navigation ‚îÄ [ESC] Exit ‚îÄ [Enter] Select" \
                        --header-first | cut -d" " -f1
            )
            [ "$sel" = "$TO_MAIN_MENU" ] && clear_modifiers && continue
            [ "$sel" = "üîÑ" ] &&
                printf "send\n" | trackma_query >/dev/null 2>&1
            clear_modifiers
            ;;
        "$LIST_AIRING")
            sort_airing=1
            prompt=$LIST
            ;;
        "$LIST_BY_SCORE")
            sort_score=1
            prompt=$LIST
            ;;
        "$LIST")
            status=$(
                printf "%s\n%s" "$TRACKMA_STATUS_MENU_ENTRIES" "$TO_MAIN_MENU" |
                    $FZF -i --prompt="Choose a status: " \
                        --border-label " ‚ô£  LIST$(
                            if [ "$sort_score" -eq 1 ]; then
                                printf ' BY SCORE üåü'
                            elif [ "$sort_airing" -eq 1 ]; then
                                printf ' AIRING SHOWS üì£'
                            else
                                printf " SHOWS"
                            fi
                        ) (Status select) ‚ô£  " \
                        --header "‚áÖ Navigation ‚îÄ [ESC] Exit ‚îÄ [Enter] Select" \
                        --header-first
            )
            [ "$status" = "$TO_MAIN_MENU" ] && prompt=$TO_MAIN_MENU && continue

            status=$(get_trackma_status_code "$status")

            if [ "$sort_score" -eq 1 ]; then
                # sort by score
                msg="$(printf "filter %s\nsort my_score\nls\n" "$status" | trackma_query)"
                msg="$(filter_trackma_list "$msg" | sort -r)"
            else
                msg="$(printf "filter %s\nls\n" "$status" | trackma_query)"
                msg="$(filter_trackma_list "$msg" | sort -r --version-sort)"
            fi
            # remove character sequences and add an emoji next to airing shows
            msg=$(printf "%s\n" "$msg" | sed "s,$(printf '\033')\\[[0-9;]*[a-zA-Z],üì£ ," | sed "s,$(printf '\033')\\[[0-9;]*[a-zA-Z],,g" | sed -E "/üì£/ s/(.*)\.{3}(.*)/\1\2/" | sed "s,\x1B\[[0-9;]*[a-zA-Z],,g")

            if [ "$sort_airing" -eq 1 ]; then
                # filter airing show per user request
                msg=$(printf "%s" "$msg" | sed -n "/üì£/p")
            fi

            if [ ! "$msg" ]; then
                msg="This list has no items... "
                sel=$(
                    printf "%s\n%s\n%s" "$msg" "$TO_MAIN_MENU" "$SWITCH_STATUS_MSG_MENU_ENTRY" |
                        $FZF -i --border-label " ‚ô£  LIST$(
                            if [ "$sort_score" -eq 1 ]; then
                                printf ' BY SCORE üåü'
                            elif [ "$sort_airing" -eq 1 ]; then
                                printf ' AIRING SHOWS üì£'
                            else
                                printf " SHOWS"
                            fi
                        ) ($status list) ‚ô£  " \
                            --header "‚áÖ Navigation - [Enter] Go back" \
                            --prompt ""
                )
                [ "$sel" = "$TO_MAIN_MENU" ] && prompt="$TO_MAIN_MENU" && continue
                continue
            fi

            export status
            while true; do
                FZF_PREVIEW_WINDOW_CMD="TRACKMA_LIST_REGEX=\"$TRACKMA_LIST_REGEX\"; TRACKMA_ENTRY_REGEX=\"$TRACKMA_ENTRY_REGEX\"; GLOBAL_TRACKMA_FIFO=$GLOBAL_TRACKMA_FIFO; GLOBAL_TRACKMA_TMPFILE=$GLOBAL_TRACKMA_TMPFILE; $trackma_query_function_code; $sanitize_ext_regex_function_code; $get_show_title_function_code; $get_trackma_status_code_function_code; $get_show_info_function_code; $filter_trackma_list_function_code; $get_entry_index_function_code; get_show_info {} $status | bat --style=plain --color=always --language=yaml"

                sel=$(
                    printf "%s\n%s\n%s" "$msg" "$TO_MAIN_MENU" "$SWITCH_STATUS_MSG_MENU_ENTRY" |
                        $FZF -i --bind "ctrl-l:toggle-preview" --preview "$FZF_PREVIEW_WINDOW_CMD" \
                            --preview-window "$PREVIEW_WINDOW_OPTS" \
                            --bind "shift-right:change-preview-window($MENU_PREVIEW_POS_MODES)+preview:$FZF_PREVIEW_WINDOW_CMD" \
                            --preview-label ' Info ' \
                            --border-label " ‚ô£  LIST$(
                                if [ "$sort_score" -eq 1 ]; then
                                    printf ' BY SCORE üåü'
                                elif [ "$sort_airing" -eq 1 ]; then
                                    printf ' AIRING SHOWS üì£'
                                else
                                    printf " SHOWS"
                                fi
                            ) ($status list) ‚ô£  " \
                            --header "‚áÖ Navigation - [Ctrl-L] Toggle info - [ESC] Exit - [Enter] Play ‚ñ∏" \
                            --prompt "Choose an anime: "
                )
                [ "$sel" = "$TO_MAIN_MENU" ] && clear_modifiers && break
                [ "$sel" = "$SWITCH_STATUS_MSG_MENU_ENTRY" ] && break
                anime_title_trackma=$(get_show_title "$sel")
                last_show_episode="$(get_last_show_ep "$anime_title_trackma")"
                [ -z "$last_show_episode" ] && printf "Couldn't get last show episode" && exit 1
                last_watched_ep="$(printf "%s" "$sel" | sed -En "s/$TRACKMA_ENTRY_REGEX/\4/p")"
                # only increment if it's not the last episode of the show
                # if we don't know the last aired apisode just attempt playing the next episode
                # last_show_episode can be a string or integer
                if [ "$last_show_episode" = "?" ]; then
                    anime_ep=$((last_watched_ep + 1))
                elif [ "$last_watched_ep" -lt "$last_show_episode" ]; then
                    anime_ep=$((last_watched_ep + 1))
                else
                    anime_ep="1"
                fi
                trackma_index="$(printf "%s" "$sel" | sed -En "s/$TRACKMA_ENTRY_REGEX/\1/p")"
                prompt="$WATCH"
                break
            done
            ;;
        esac
    done
}

incognito_menu() {
    INCOGNITO_MENU_HELPTEXT="
üë§  Switch Incognito Mode off.
‚îÄ‚îÄ‚îÄ
üí°  Stream with animdl. You will need to type a search query and episode number. This option uses streaming for playing content.
‚îÄ‚îÄ‚îÄ
üò∫  Search Nyaa Torrents. You will need to type a search query, type and episode number and select a search result to play it. This option uses torrenting for playing content.
"
    INCOGNITO_MENU_ENTRIES="$PLAY_METHOD_TORRENTING\n$PLAY_METHOD_STREAMING\n$EXIT_INCOGNITO_MODE"
    MAINMENU_TITLE="MAIN MENU"
    menu_entries=$INCOGNITO_MENU_ENTRIES
    menu_title=$MAINMENU_TITLE
    menu_help_text=$INCOGNITO_MENU_HELPTEXT
    prompt=""
    while true; do
        if [ -z "$prompt" ]; then
            FZF_PREVIEW_WINDOW_CMD="printf \"%s\n\" \"$menu_help_text\""
            clear_modifiers
            prompt=$(
                printf "%b" "$menu_entries" |
                    $FZF -i --prompt="Choose an action: " \
                        --border-label "‚ï¢ ‚ô£  $menu_title ‚ô£  ‚ïü" \
                        --header "‚áÖ Navigation ‚îÄ [ESC] Exit ‚îÄ [Ctrl-L] Help ‚îÄ [Enter] Select" \
                        --header-first \
                        --preview-window "$PREVIEW_WINDOW_OPTS" \
                        --bind "shift-right:change-preview-window($MENU_PREVIEW_POS_MODES)+preview:$FZF_PREVIEW_WINDOW_CMD" \
                        --preview "$FZF_PREVIEW_WINDOW_CMD" \
                        --bind "ctrl-l:toggle-preview" \
                        --preview-label " Help "
            )
        fi
        case $prompt in
        "$PLAY_METHOD_TORRENTING")
            player_source="torrenting"
            incognito_play_msg_emoji="üò∫"
            prompt="PLAY"
            ;;
        "$PLAY_METHOD_STREAMING")
            player_source="streaming"
            incognito_play_msg_emoji="üí°"
            prompt="PLAY"
            ;;
        "PLAY")
            echo && line_to_remove
            printf "$MSG_INFO_COLOR      %s What anime do you want to watch‚ùî$RESET" "$incognito_play_msg_emoji" && line_to_remove
            printf "         üëâ " && line_to_remove
            read -r anime_title
            clear_lines
            [ -z "$anime_title" ] && clear_modifiers && continue
            anime_title="$(printf "%s" "$anime_title" | sed -E 's/[^a-zA-Z0-9 ]//g' | sed "s/[[:space:]]*$//g" | sed "s/^[[:space:]]*//g")"
            echo && line_to_remove
            printf "      %s Enter an episode number if applicable\n" "$incognito_play_msg_emoji" && line_to_remove
            printf "         üëâ " && line_to_remove
            read -r anime_ep
            clear_lines
            anime_ep="$(printf "%s" "$anime_ep" | sed -E 's/[^0-9]//g')"
            if [ -z "$anime_ep" ]; then
                anime_ep=1
                show_type="movie"
            else
                show_type="tv"
            fi
            last_show_episode=0
            while true; do
                play_episode "$anime_title" "$anime_ep" "$player_source" "" "$show_type" ""
                clear_lines
                media_player_exit_code=""
                media_player_menu
                if [ "$media_player_exit_code" = "$PLAYER_MENU_SOURCE_SELECT_CODE" ] || [ "$media_player_exit_code" = "$PLAYER_MENU_SELECT_SEARCH_RES_CODE" ]; then
                    continue
                elif [ "$media_player_exit_code" = "$PLAYER_MENU_END_CODE" ]; then
                    # exit player go to main menu
                    break
                fi
            done
            ;;
        "$EXIT_INCOGNITO_MODE")
            INCOGNITO_MODE=0
            line_to_remove # remove incognito label
            clear_lines    # remove incognito label
            break
            ;;
        esac
    done
}

if [ "$OSTYPE" = "Darwin" ]; then
    MEDIA_PLAYER="iina"
else
    MEDIA_PLAYER="mpv"
fi

export BACK_MSG
export TO_MAIN_MENU
export SWITCH_STATUS_MSG_MENU_ENTRY
export TRACKMA_ENTRY_REGEX
export TRACKMA_LOGFILE

# fzf colors
export FZF_DEFAULT_OPTS='--color=fg:#ffffff,bg:-1,hl:#ba9c41 --color=fg+:#ffbf00,bg+:#262626,hl+:#5fd7ff --color=info:#ffffff,prompt:#ffbf00,pointer:#af5fff --color=marker:#87ff00,spinner:#af5fff,header:#d7005f --color=label:#ffbf00'

# regex for extracting trackma results
# gets the whole series list
TRACKMA_LIST_REGEX="^\|[[:space:]]+([0-9]+[[:space:]]+.*[0-9]+[[:space:]]+\/[[:space:]]+[0-9?]+[[:space:]]+[0-9]+).*\|$"
# gets the multiple parts of an entry, by matching groups
#	1- list index
#	2- series title
#	3- unused
#	4- last watched ep
#	5- end episode
#	6- series score
# Caveat: removing possesive quantifier makes the \2 match to end
# with a residual dot, we will have to remove it with sed.
# We also have no way of making a distinction between series that
# actually end with a dot from a residual dot.
TRACKMA_ENTRY_REGEX="^([[:digit:]]+)[[:space:]]+(([^.]*|.*))\.*[[:space:]]+([[:digit:]]+)[[:space:]]\/[[:space:]]([[:digit:]]+|\?)[[:space:]]+([[:digit:]]+)$"

# mainmenu entries
WATCH_HISTORY="üëÅÔ∏è  Watch History"
WATCH="üì∫ Watch"
WATCH_RANDOM="üîÄ Watch Random"
ADD_SHOW="üß© Add Anime"
LIST="üìô Lists"
UPDATE_STATUS="üîÑ Update Anime Status"
SCORE_SHOW="üëç Score Anime"
EXIT_INCOGNITO_MODE="üë§ Exit Incognito Mode"
ENTER_INCOGNITO_MODE="üïµÔ∏è  Enter Incognito Mode"
TO_SUBMENU="üêá SUBMENU ‚ñ∏"
# submenu entries
SWITCH_ACCOUNTS="Switch Accounts üë§"
DELETE_SERIES="Delete Anime üóëÔ∏è"
WATCH_RAND_AIRING="Watch Random Anime (Currently Airing üì£)"
LIST_AIRING="List Anime (Currently Airing üì£)"
UPDATE_EPISODES="Update Anime Episodes üîÑ"
SET_ALTNAME="Set Alternative Name üìù"
PULL="Pull Lists from Remote ‚Üì"
PUSH="Push Local Lists to Remote ‚Üë"
LIST_BY_SCORE="List Anime (Sort by Rating üåü)"
TO_MAIN_MENU="‚óÇ MAINMENU"
SWITCH_STATUS_MSG_MENU_ENTRY="üîÑ SWITCH STATUS"
# used in account_menu, incognito_menu
PLAY_METHOD_TORRENTING="üò∫ Search Nyaa Torrents (torrenting)"
PLAY_METHOD_STREAMING="üí° Stream with animdl (streaming)"
PLAY_METHOD_MAGNET="üß≤ Paste a magnet link (torrenting)"
PLAY_METHOD_MENU="$PLAY_METHOD_TORRENTING\n$PLAY_METHOD_MAGNET\n$PLAY_METHOD_STREAMING\n$TO_MAIN_MENU"
# used in media_player_menu
PLAYER_MENU_SOURCE_SELECT_CODE=0
PLAYER_MENU_END_CODE=1
PLAYER_MENU_SELECT_SEARCH_RES_CODE=2

main() {
    check_setup
    # common fzf args
    PREVIEW_WINDOW_OPTS="right,70%,hidden,wrap"
    MENU_PREVIEW_POS_MODES="down,70%|left,70%|top,70%|"
    if [ "$MINIMAL" -eq 1 ]; then
        # initial preview options
        FZF="fzf -0 --ansi --cycle --ellipsis (...) --color dark --pointer > --border-label-pos 1 --reverse --border top --layout=reverse --info inline --no-separator --bind change:first"
    else
        FZF="fzf -0 --ansi --cycle --ellipsis (...) --height 70% --border rounded --pointer üëâ --margin 5% --padding=1,0,0,0 --border-label-pos -1 --bind change:first"
    fi
    paint_logo
    while true; do
        if [ "$INCOGNITO_MODE" -eq 0 ]; then
            spawn_trackma
            check_trackma_config
        fi
        if [ "$INCOGNITO_MODE" -eq 0 ]; then
            [ "$MINIMAL" -eq 0 ] && print_account
            account_menu
        else
            [ "$MINIMAL" -eq 0 ] && print_incognito_msg
            incognito_menu
        fi
    done
}
main
trap - 1 2 3 15

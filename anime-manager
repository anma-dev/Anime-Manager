#!/bin/sh
# shellcheck disable=SC2016,SC2034
set -o errexit
set -o nounset

# override locale categories
eval export "$(locale)"
unset LC_ALL
LANG="C"
LC_ALL="C"
LC_COLLATE="C"
LC_CTYPE="C"
LC_MESSAGES="C"
LC_MONETARY="C"
LC_NUMERIC="C"
LC_TIME="C"
LC_ADDRESS="C"
LC_IDENTIFICATION="C"
LC_MEASUREMENT="C"
LC_NAME="C"
LC_PAPER="C"
LC_TELEPHONE="C"
LANGUAGE="en_US.UTF-8"
export LANG LC_ALL \
    LC_COLLATE \
    LC_CTYPE \
    LC_MESSAGES \
    LC_MONETARY \
    LC_NUMERIC \
    LC_TIME \
    LANGUAGE \
    LC_ADDRESS \
    LC_IDENTIFICATION \
    LC_MEASUREMENT \
    LC_NAME \
    LC_PAPER \
    LC_TELEPHONE

. ./lib/array

VERSION="0.0.1"
OSTYPE="$(uname -s 2>/dev/null)"

parser_definition() {
    setup REST help:usage -- "Usage: anime-manager [options]..." ''
    msg -- 'Options:'
    flag MINIMAL --minimal init:="0" -- "Minimalistic interface. It does not print the logo, the menu  
                              fills the screen and is reversed. Dimmer colors."
    flag INCOGNITO_MODE -i --incognito init:="0" -- "Switch Incognito Mode on. Your activity will not be synced 
                              with the remote anime list tracking service."
    flag MONOCHROME_LOGO --monochrome-logo init:="0" -- "Print the monochromatic logo instead of the big orange one. 
                              Suitable for terminals that do not support 24-bit colors."
    flag DEBUG -d --debug init:="0" -- "Start debug mode"
    disp :usage -h --help
    disp VERSION -v --version init:="0"
}

eval "$(utils/getoptions parser_definition) exit 1"

if [ "$DEBUG" -eq 1 ]; then
    set -x
    export NYAA_DEBUG="$DEBUG"
else
    unset NYAA_DEBUG
fi

if [ "$MONOCHROME_LOGO" -eq 1 ] && [ "$MINIMAL" -eq 1 ]; then
    printf "Error: Incompatible options --monochrome-logo, --minimal\nPlease use one or the other."
    exit
fi

# cleanly go to the main loop
# a 'modifier' for us is a flow control variable
clear_modifiers() {
    random_anime=0
    random_airing=0
    prompt=""
    sort_airing=0
    sort_score=0
    anime_title=""
    anime_title_trackma=""
    trackma_show_index=""
    anime_ep=""
    status=""
    new_status=""
    last_watched_ep=""
    nyaa_search_res=""
    play_status=$PLAY_STATUS_WAITING
    player_source="torrenting"
    magnet_link=""
    play_method_menu_opt=""
    debug_match_info=""
    file_list=""
    file_index=""
    animdl_playthrough=0
    animdl_search_index=1
}

reset_logs() {
    echo >"$WEBTORRENT_LOGFILE"
    echo >"$TRACKMA_LOGFILE"
    echo >"$ANIMDL_LOGFILE"
    # echo > "$CURRENTLY_PLAYING_LOGFILE"
    echo >"$NYAA_SEARCH_LOGFILE"
    echo >"$NYAA_FE_LOGFILE"
}

on_exit() {
    onexit_last_exit_status="$?"
    onexit_parent_lineno="$1"
    onexit_message="${2:-(no message ($onexit_last_exit_status))}"
    onexit_exit_code="${3:-$onexit_last_exit_status}"
    if [ "$onexit_exit_code" -eq 130 ] || [ "$onexit_exit_code" -eq 0 ]; then
        tput clear && tput clear
    else
        tput clear
        printf "%s\n" "ERROR on line $onexit_parent_lineno - $onexit_message - exit code $onexit_exit_code"
    fi
    [ "$INCOGNITO_MODE" -eq 0 ] && close_trackma
    # cleanup, save disk space
    [ "$DEBUG" -eq 0 ] &&
        reset_logs &&
        rm -rf "$TORRENT_DOWNLOAD_DIR"
    clear_modifiers
    exit "$onexit_exit_code"
}

trap 'on_exit ${LINENO}' 1 2 3 15

# formats and prints a string
log() {
    printf "%b\n" "$1"
}

select_account() {
    # account selection
    TRACKMA_ACCOUNTS="$(sed -nE "/[0-9]+:/p" "$GLOBAL_TRACKMA_TMPFILE")"
    if [ -n "$TRACKMA_ACCOUNTS" ]; then
        TRACKMA_ACCOUNTS_MENU_ENTRIES="$(printf "%s" "$TRACKMA_ACCOUNTS" | sed "s/^[0-9]: /👤 /g")"
    else
        TRACKMA_ACCOUNTS_MENU_ENTRIES="No account was found"
    fi
    TRACKMA_ACCOUNTS_MENU_ENTRIES="🕵️  Incognito Mode\n$TRACKMA_ACCOUNTS_MENU_ENTRIES"
    while [ -n "$(sed -En "s/no account|Available accounts/&/p" "$GLOBAL_TRACKMA_TMPFILE")" ] && [ "$INCOGNITO_MODE" -eq 0 ]; do
        account_choice=$(
            printf "%b" "$TRACKMA_ACCOUNTS_MENU_ENTRIES" |
                $FZF -i --prompt="Select an option: " \
                    --border-label "╢ ♣  ACCOUNT SELECTION ♣  ╟" \
                    --header "⇅ Navigation ─ [ESC] Exit ─ [Enter] Select" \
                    --header-first --tac --no-sort
        )
        if [ "$(printf "%s" "$account_choice" | cut -d " " -f1)" = "🕵️" ]; then
            INCOGNITO_MODE=1
            close_trackma
            break
        elif [ "$account_choice" = "No account was found" ]; then
            exit
        else
            acc_id="$(printf "%s" "$TRACKMA_ACCOUNTS" | grep "$(printf "%s" "$account_choice" | sed "s/^👤 //g")" | cut -d ":" -f1)"
            [ -z "$acc_id" ] && exit
            printf "r%s\n" "$acc_id" | trackma_query >/dev/null 2>&1
        fi
    done
    if [ "$INCOGNITO_MODE" -eq 0 ]; then
        USERNAME="$(get_account_name)"
        TRACKER_SERVICE="$(get_remote_tracker)"
    fi
}

check_trackma_config() {
    check_trackma_config_config_file=""
    if [ -s "$HOME"/.trackma/config.json ]; then
        check_trackma_config_config_file="$HOME/.trackma/config.json"
    elif [ -s "$HOME"/.config/trackma/config.json ]; then
        check_trackma_config_config_file="$HOME/.config/trackma/config.json"
    fi
    AUTORET_VALUE="$(jq --raw-output '.autoretrieve' "$check_trackma_config_config_file")"
    AUTOSEN_VALUE="$(jq --raw-output '.autosend' "$check_trackma_config_config_file")"
    if [ "$AUTORET_VALUE" = "always" ] || [ "$AUTOSEN_VALUE" = "always" ]; then
        printf "%b" "
💥 Anime Manager was unable to start!
   Please change the 'autoretrieve' and 'autosave' options
   in '$check_trackma_config_config_file'
   to a value other than 'always'.
"
        exit
    fi
    select_account
}

# trim long show titles
trim() {
    MAX_MENU_TITLE_SERIES_LEN=20
    title="$1"
    c_count=$(printf "%s" "$title" | wc -c | sed "s/ //g")
    if [ "$c_count" -gt $MAX_MENU_TITLE_SERIES_LEN ]; then
        printf "%s" "$title" | cut -c 1-"$MAX_MENU_TITLE_SERIES_LEN" | sed "s/$/(...)/"
    else
        printf "%s" "$title"
    fi
}

line_to_remove() {
    lines_to_remove="$((lines_to_remove + 1))"
}

# clear n number of lines from output
# caveat: wrapped lines
clear_lines() {
    while [ $lines_to_remove -gt 0 ]; do
        printf "%b" "${OVERWRITE}"
        lines_to_remove=$((lines_to_remove - 1))
    done
}

# check if we can run automatic install for missing dependencies
auto_compat() {
    if [ "$OSTYPE" = "Linux" ]; then
        distro_id="$(awk -F= '$1 == "ID" {print $2}' /etc/*-release)"
        case $distro_id in
        "ubuntu" | "debian")
            true
            ;;
        *)
            false
            ;;
        esac
    elif [ "$OSTYPE" = "Darwin" ]; then
        true
    else
        log "Automatic installation does not support your platform yet\nbut we may add support for it in the future.\n\nPlease install the dependencies manually.\n\nMORE INFO: https://github.com/anma-dev/Anime-Manager#dependencies"
        exit 0
    fi
}

# get the shell configuration file path
get_shell_config_file() {
    get_shell_config_file_cfg_file=""
    if [ "$SHELL" = "/bin/bash" ]; then
        [ "$OSTYPE" = "Linux" ] && touch "$HOME/.bashrc" && get_shell_config_file_cfg_file="$HOME/.bashrc"
        [ "$OSTYPE" = "Darwin" ] && touch "$HOME/.bash_profile" && get_shell_config_file_cfg_file="$HOME/.bash_profile"
    fi
    # nvm on macos needs the shell config file
    [ "$SHELL" = "/bin/zsh" ] && touch "$HOME/.zshrc" && get_shell_config_file_cfg_file="$HOME/.zshrc"
    printf "%s" "$get_shell_config_file_cfg_file"
}

# install dependencies automatically if we can
install_dependencies() {
    AM_SHELL_CFG_MSG="### Anime Manager autoinstall ###"
    shell_cfg="$(get_shell_config_file)"
    install_dep_msg="🎉 Finished the autoinstall!\nRestart your shell to start using Anime Manager."
    # Ubuntu (not WSL) and macOS support
    if ! which fzf bat animdl trackma jq node >/dev/null 2>&1 || [ ! -s lib/webtorrent-cli/bin/cmd.js ]; then
        log "Anime Manager can automatically install its dependencies.\nSome dependencies were not found!" && line_to_remove

        if auto_compat; then
            printf "%s" "Install missing dependencies now? [y/N] " && line_to_remove
            read -r yn </dev/tty
            if [ -z "$yn" ]; then
                yn="n"
            fi
            case "$yn" in
            [Yy]*) ;;
            [Nn]*) exit ;;
            *) printf "%s\n" "      Please answer 'yes' or 'no'." && line_to_remove ;;
            esac
        fi
        # begin installation
        if [ "$OSTYPE" = "Linux" ]; then
            log "🐧 Installing Linux dependencies."
            if ! sudo -v; then
                log "💥 Your current user account has no administrative privileges.\nRequired dependencies unable to install\nPlease contact your system administrator." && exit 1
            fi
            sudo apt update
            sudo apt -y install build-essential procps curl wget file git python3-setuptools python3-pip bat jq
            mkdir -p "$HOME/.local/bin"
            if ! grep '$HOME/.local/bin:$PATH' "$shell_cfg"; then
                printf "\n%s\n%s\n" "$AM_SHELL_CFG_MSG" 'export PATH="$HOME/.local/bin:$PATH"' >>"$shell_cfg"
            fi
            # make alias for batcat and put it in path
            if ! command -v bat; then
                [ ! -s "$HOME/.local/bin/bat" ] && ln -s /usr/bin/batcat "$HOME/.local/bin/bat"
            fi
            if ! command -v fzf; then
                if [ -d "$HOME/.fzf" ]; then
                    printf "\n\n%s\n\n" "INSTALLATION CONFLICT! Existing $HOME/.fzf folder found!\nfzf was not installed. Please install it manually."
                else
                    # require an fzf version with label and label coloring support
                    git clone --depth 1 https://github.com/junegunn/fzf.git "$HOME/.fzf"
                    "$HOME/.fzf/install" --all --update-rc
                fi
            else
                fzf_version="$(fzf --version)"
                if [ -z "$(printf "%s" "$fzf_version" | awk -F. '$1 >= 0 && $2 >= 35 {print $0}')" ]; then
                    printf "\n\n%s\n\n" "Please manually update your fzf installation to version >= 0.35.x."
                fi
            fi
            ./utils/install-webtorrent.sh
            if ! command -v animdl; then
                # https://github.com/justfoolingaround/animdl
                pip3 install animdl
            fi
            if ! command -v trackma; then
                sudo apt install lsof
                sudo apt -y install python3-pyqt5
                # https://github.com/z411/trackma
                pip3 install pillow \
                    pydbus \
                    setuptools \
                    wheel \
                    pyinotify \
                    nyaapy \
                    anitopy \
                    'requests>=2.20.0' \
                    beautifulsoup4==4.6.0 \
                    lxml \
                    dbus-python
                pip3 install Trackma==0.8.5
            fi
        elif [ "$OSTYPE" = "Darwin" ]; then
            log "🍏 Installing macOS dependencies."
            if ! pkgutil --pkg-info=com.apple.pkg.CLTools_Executables | grep version >/dev/null 2>&1; then
                # xcode command line tools is a dependency of nvm and homebrew
                xcode-select --install
            fi
            if ! command -v brew; then
                # Install homebrew unattended
                NONINTERACTIVE=1 /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
            fi
            if ! grep 'export PATH="/opt/homebrew/bin/:$PATH"' "$shell_cfg" >/dev/null 2>&1; then
                printf "\n%s\n%s\n" "$AM_SHELL_CFG_MSG" 'export PATH="/opt/homebrew/bin/:$PATH"' >>"$shell_cfg"
            fi
            brew install curl jq grep axel openssl@1.1 ffmpeg git bat
            brew install patchelf cmake automake fzf
            if ! command -v animdl; then
                # https://github.com/justfoolingaround/animdl
                pip3 install animdl
            fi
            ./utils/install-webtorrent.sh
            if ! command -v trackma; then
                # https://github.com/z411/trackma
                # dbus-python module is broken on macOS and cannot be built. This means no trackma mpris support.
                # pip3 install dbus-python
                # inotify is not available on macosx-XX-arm64
                # pip3 install pyinotify
                # Installs qt5 for trackma gui
                pip3 install pillow \
                    PyQt5 \
                    pydbus \
                    setuptools \
                    setuptools_scm \
                    scikit-build \
                    nyaapy \
                    anitopy \
                    'requests>=2.20.0' \
                    beautifulsoup4==4.6.0 \
                    lxml \
                    wheel \
                    Trackma==0.8.5
            fi
        fi
        echo
        log "$install_dep_msg"
        exit
    fi
}

# sanitizes a string to be used in an extended regular expression
sanitize_ext_regex_function_code='sanitize_ext_regex() {
    printf "%s" "$1" |
        sed "s,$(printf "\033")\\[[0-9;]*[a-zA-Z],," |
        sed "s,$(printf "\033")\\[[0-9;]*[a-zA-Z],,g" |
        sed "s,\x1B\[[0-9;]*[a-zA-Z],,g" |
        sed "s/[]\/\$*.^+()\"['"'"'-]/\\\&/g" |
        sed "s/ $//"
}'
eval "$sanitize_ext_regex_function_code"

sanitize_bash() {
    printf "%s" "$1" | LC_ALL=C sed -e 's/[^a-zA-Z0-9,._+@%/-]/\\&/g; 1{$s/^$/""/}; 1!s/^/"/; $!s/$/"/'
}

getcwd() {
    printf "%s" "$(lsof -p "$$" | grep cwd | awk '{print $9}')"
}

lines_to_remove=0
# Message color palette
RESET="\033[0m\n"
MSG_INFO_COLOR="\033[38;2;255;255;224m" # lightyellow
MSG_WARN_COLOR="\033[38;2;255;165;0m"   # orange
MSG_ERR_COLOR="\033[31m"                # red
MSG_HELP_COLOR="\033[1;34m"             # lightblue, bold
TITLE_COLOR="\033[33m"                  # yellow
SUBTITLE_COLOR="\033[1;34m"             # lightblue, bold
INCOGNITO_MODE_COLORS="\033[37;45m"     # magenta bg, white fg
OVERWRITE='\r\033[1A\033[0K'

DATE_MONTH=$(date "+%m")
DATE_DAY=$(date "+%d")
CONFIG_PATH="$HOME/.config/anime-manager"
TMP_PATH="/tmp/anime-manager"
CHECKPOINTFILE="$HOME/.config/anime-manager/checkpoint"
player_source="torrenting"

animdl_playthrough=0
animdl_search_index=1
NYAA_SEARCH_BIN="$(getcwd)/lib/nyaa_search.py"
NYAA_SEARCH_LOGFILE="$CONFIG_PATH/nyaa_search.log"
NYAA_FE_LOGFILE="$CONFIG_PATH/file_extractor.log"
NYAA_FE_BIN="$(getcwd)/lib/file_extractor.py"
WEBTORRENT_CLI="lib/webtorrent-cli/bin/cmd.js"
TORRENT_DOWNLOAD_DIR="${TMP_PATH}/webtorrent"

# logfiles
WEBTORRENT_LOGFILE="$CONFIG_PATH/webtorrent.log"
TRACKMA_LOGFILE="$CONFIG_PATH/trackma.log"
# CURRENTLY_PLAYING_LOGFILE="$CONFIG_PATH/now_playing.log"
ANIMDL_LOGFILE="$CONFIG_PATH/animdl.log"
# webtorrent globals
# torrent status codes
TORRENT_TMOUT=60
TORRENT_STATUS_OKPLAYING=0
TORRENT_STATUS_STALLED=1
TORRENT_STATUS_ERRORED=2
file_list=""
webtorrentpid=""
# player status codes
PLAY_STATUS_WAITING=0
PLAY_STATUS_OKPLAYING=1
PLAY_STATUS_ERRORED=2
PLAY_STATUS_EXITED=3
# PLAY_STATUS_OFFLINE=4
PLAY_STATUS_FILE_SEL=5
play_status=$PLAY_STATUS_WAITING
# nyaa search return codes, corresponds with lib/return_codes.py
NYAA_SEARCH_CODE_NO_RESULTS="-1"
NYAA_SEARCH_CODE_FATAL_ERROR="-3"
NYAA_FID_CODE_CONTENT_MISMATCH="-6"

mkdir -p "$TMP_PATH"
mkdir -p "$TORRENT_DOWNLOAD_DIR"
mkdir -p "$CONFIG_PATH"
[ ! -f "$TRACKMA_LOGFILE" ] && touch "$TRACKMA_LOGFILE"

check_setup() {
    # initial checks
    if [ ! -f "$CHECKPOINTFILE" ]; then
        printf "%s" "
READ FIRST --

    This program comes with ABSOLUTELY NO WARRANTY.
Anime Manager is a file sharing program. When you run a torrent (Anime Manager can play content by the means of running a torrent), its data will be made available to others by means of upload. Any content you share is your sole responsibility. No further notices will be issued.

-------------

Do you agree with this? [yes/no]: "
        while true; do
            read -r answer
            case "$answer" in
            "yes") break ;;
            "no") exit ;;
            *) printf "%s" "Please answer 'yes' or 'no': " && line_to_remove ;;
            esac
        done
        printf "%s\n" "$answer" >"$CHECKPOINTFILE"
    fi
    # use node if nvm is already installed
    if ! which node >/dev/null 2>&1; then
        PLATFORM_NVM_DIR=""
        if [ -d "$HOME/.config/nvm" ]; then
            PLATFORM_NVM_DIR="$HOME/.config/nvm"
        elif [ -d "$HOME/.nvm" ]; then
            PLATFORM_NVM_DIR="$HOME/.nvm"
        fi
        if [ -d "$PLATFORM_NVM_DIR" ]; then
            export NVM_DIR="$PLATFORM_NVM_DIR"
            # shellcheck disable=SC1091
            [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh" >/dev/null 2>&1 # This loads nvm
            # shellcheck disable=SC1091
            [ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion" >/dev/null 2>&1 # This loads nvm bash_completion
            if comand -v nvm >/dev/null 2>&1; then
                nvm use node >/dev/null 2>&1
            fi
        fi
    fi
    install_dependencies
}

# Create a safe temporary filename in a posix-compliant way
get_temp_filename() {
    {
        posix_mktemp_file_file=$(
            (mktemp -u "$TMP_PATH/anmaXXXXXXXX") 2>/dev/null
        )
    } || {
        posix_mktemp_file_file=$TMP_PATH/anma$$-$(awk 'BEGIN { srand(); print int(rand()*32768) }' /dev/null)
    } || exit $?
    printf "%s" "$posix_mktemp_file_file"
}

# get the account in use in Trackma
get_account_name() {
    while ! grep "using account" "$GLOBAL_TRACKMA_TMPFILE" >/dev/null 2>&1; do :; done
    sed -En "s/.*using account (.*)\(.*/\1/p" "$GLOBAL_TRACKMA_TMPFILE" # | sed "s/ $//g"
}

# gets the remote tracking service (mal, anilist, etc) used in trackma
# this is necessary because the lists differ between services
get_remote_tracker() {
    while ! grep "using account" "$GLOBAL_TRACKMA_TMPFILE" >/dev/null 2>&1; do :; done
    sed -En "s/.*using account (.*)\((.*)\).*/\2/p" "$GLOBAL_TRACKMA_TMPFILE"
}

get_trackma_tracker_name() {
    get_trackma_tracker_name_name="$1"
    case $get_trackma_tracker_name_name in
    "mal")
        printf "MAL"
        ;;
    "anilist")
        printf "Anilist"
        ;;
    esac
}

# returns a status code that trackma understands
get_trackma_status_code_function_code='get_trackma_status_code() {
    get_trackma_status_code_status_status="$1"
    case $get_trackma_status_code_status_status in
    "Watching" | "watching")
        printf "watching"
        ;;
    "Plan to Watch" | "plantowatch")
        printf "plantowatch"
        ;;
    "Rewatching" | "rewatching")
        printf "rewatching"
        ;;
    "Dropped" | "dropped")
        printf "dropped"
        ;;
    "Paused" | "paused")
        printf "paused"
        ;;
    "Completed" | "completed")
        printf "completed"
        ;;
    "On Hold" | "onhold")
        printf "onhold"
        ;;
    "$TO_MAIN_MENU")
        printf "%s" "$TO_MAIN_MENU"
        ;;
    "$SWITCH_STATUS_MSG_MENU_ENTRY")
        printf "%s" "$SWITCH_STATUS_MSG_MENU_ENTRY"
        ;;
    esac
}'
eval "$get_trackma_status_code_function_code"

# Update watched episodes
set_ep_as_watched() {
    printf "update %s\n" "$trackma_index" | trackma_query >/dev/null 2>&1
    # we check if theres actually something to save
    # save other shows and replace the new updated registry for this show
    preserved_history=$(awk "!/^$(sanitize_ext_regex "$anime_title_trackma").*$/" "$WATCH_HISTORY_FILE")
    # if there is content that is not replaced add a newline for the show to insert, and only in that case.
    [ -n "$preserved_history" ] && printf "%b" "$preserved_history\n" >"$WATCH_HISTORY_FILE" || printf "%b" "$preserved_history" >"$WATCH_HISTORY_FILE"
    printf "%s\n" "$anime_title_trackma////$anime_ep" >>"$WATCH_HISTORY_FILE"
}

# set episode status on the anime tracker service
# ARGS in order
# trackma_show_index the index of the show obtained from user input
set_show_status() {
    set_show_status_STATUS="$2"
    new_status="$(get_trackma_status_code "$set_show_status_STATUS")"
    prompt="$UPDATE_STATUS"
}

filter_trackma_list_function_code='filter_trackma_list() {
    printf "%b" "$1" | sed -En "s/$TRACKMA_LIST_REGEX/\1/p"
}'
eval "$filter_trackma_list_function_code"

# get all the shows the user has set as watching in their lists
# for presenting in unified way
get_watching_shows() {
    get_watching_shows_rewatching=""
    get_watching_shows_watching="$(printf "filter %s\nls\n" "watching" | trackma_query)"
    get_watching_shows_watching="$(filter_trackma_list "$get_watching_shows_watching")"
    if [ "$TRACKER_SERVICE" = "anilist" ]; then
        # exception for anilist
        get_watching_shows_rewatching="$(printf "filter %s\nls\n" "rewatching" | trackma_query)"
        get_watching_shows_rewatching="$(filter_trackma_list "$get_watching_shows_rewatching")"
    fi
    printf "%b\n%b" "$get_watching_shows_watching" "$get_watching_shows_rewatching"
}

# accepts a trackma entry and returns the cleaned show title
# to use with raw trackma entries only
get_show_title_function_code='get_show_title() {
    if [ -n "$(printf "%s" "$1" | sed -En "s/$TRACKMA_ENTRY_REGEX/\2/p")" ]; then
        # raw entry
        printf "%s" "$1" | sed -En "s/$TRACKMA_ENTRY_REGEX/\2/p" | sed -E "s/ *$//g" | sed -E "s/\.*$//g" | sed -E "s,$(printf "'"\033"'")\\[0-9;]*[a-zA-Z],," | sed -E "s,$(printf "'"\033"'")\\[0-9;]*[a-zA-Z],,g" | sed "s,\x1B\[[0-9;]*[a-zA-Z],,g" | sed "s/📣 //g" | sed -E "s/\[.*\]//g" | sed -E "s/ $//g"
    else
        printf "%s" "$1"
    fi
}'
eval "$get_show_title_function_code"

# gets the index of an entry
# "$("$play_episode_anime_title" | sed "s/'/'\"'\"'/g")"
get_entry_index_function_code='get_entry_index() {
    echo >"$GLOBAL_TRACKMA_TMPFILE"
    res_title=""
    anime_title="$1"
    status="$2"
    res="$(printf "filter %s\nsearch '"'"'%s'"'"'\n" "$(get_trackma_status_code "$status")" "$(printf "%s" "$anime_title" | sed "s/'"'"'/'"'"'\"'"'"'\"'"'"'/g")" | trackma_query)"
    res="$(filter_trackma_list "$res" | head -n1)"
    entry_index="$(printf "%s" "$res" | sed -En "s/$TRACKMA_ENTRY_REGEX/\1/p")"
    if [ -z "$entry_index" ]; then
        printf "%b\n" "💥 ERROR getting entry index.\nPlease report this error message to the developer."
        exit 1
    fi
    printf "%s" "$entry_index"
}'
eval "$get_entry_index_function_code"

# gets the status of a show
get_show_status() {
    if [ -n "$status" ]; then
        status="$(get_trackma_status_code "$status")"
        printf "%s" "$status"
    else
        res_title=""
        anime_title="$1"
        while read -r trackma_code; do
            # trackma search uses regex so we need to sanitize it
            res="$(printf "filter %s\nsearch '%s'\n" "$(get_trackma_status_code "$trackma_code")" "$(printf "%s" "$anime_title" | sed "s/'/'\"'\"'/g")" | trackma_query)"
            res="$(filter_trackma_list "$res" | head -n1)"
            [ -n "$res" ] && res_title="$(get_show_title "$res")"
            if [ -n "$res_title" ] && [ "$res_title" = "$anime_title" ]; then
                status="$trackma_code"
                break
            fi
        done <<EOF
$TRACKMA_STATUS_MENU_ENTRIES
EOF
        if [ -z "$status" ]; then
            printf "%b\n" "💥 ERROR getting show status.\nPlease report this error message to the developer."
            exit 1
        fi
        printf "%s" "$status"
    fi
}

# internet connectivity check with random selection of hosts
connectivity_check() {
    urls=$(array "ubuntu.com" "google.com" "duckduckgo.com" "bing.com")
    urls_len=$(printf '%s\n' "$urls" | array_len)
    rand_id=$(shuf -i 0-"$((urls_len - 1))" -n 1)
    rand_url=$(printf '%s\n' "$urls" | array_nth "$rand_id")
    if printf "%b" "GET https://$rand_url HTTP/1.0\n\n" | nc "$rand_url" 443 >/dev/null 2>&1; then
        true
    else
        false
    fi
}

# get shows info from Trackma
get_show_info_function_code='get_show_info() {
    get_show_info_show_title="$(get_show_title "$1")"
    get_show_info_status="$(get_trackma_status_code "$2")"
    if [ "$1" = "$TO_MAIN_MENU" ]; then
        printf "%s\n" "Go back to the main menu"
    elif [ "$1" = "$SWITCH_STATUS_MSG_MENU_ENTRY" ]; then
        printf "%s\n" "Switch to another list"
    else
        trackma_index="$(get_entry_index "$get_show_info_show_title" "$get_show_info_status")"
        get_show_info_info="$(printf "filter %s\ninfo \"%s\"\n" "$get_show_info_status" "$trackma_index" | trackma_query | sed -n "/https/,/Status/p" | sed -e "s/<[^>]*>//g")"
        printf "\n%b" "$get_show_info_info"
    fi
}'
eval "$get_show_info_function_code"

# get the last episode from a show in the re/watching list
# used when the user plays a show from the watch or watch history
# ARGS in order
# anime_title the title of the show as trackma sees it
get_last_show_ep() {
    # removes altname and trailing spaces, trackma cant find shows if the altname is in the query
    get_last_show_ep_anime_title="$(printf "%s" "$1" | sed "s/\[.*\]//g" | sed "s/ $//g")"
    get_last_show_ep_full_entry=$(get_show_entry "$get_last_show_ep_anime_title")
    [ -z "$get_last_show_ep_full_entry" ] && printf "💥 Error getting last episode!" && exit 1
    last_episode="$(printf "%b" "$get_last_show_ep_full_entry" | sed -En "s/$TRACKMA_ENTRY_REGEX/\5/p")"
    printf "%s" "$last_episode"
}

# get anime series across lists or from a particular list
# this is used to play any episode from the watch history
# the status code argument should be parseable by trackma
get_show_entry() {
    echo >"$GLOBAL_TRACKMA_TMPFILE"
    play_episode_anime_title="$1"
    status="$(get_show_status "$play_episode_anime_title")"
    # trackma search uses regex so we need to sanitize it
    res="$(printf "filter %s\nsearch '%s'\n" "$(get_trackma_status_code "$status")" "$(printf "%s" "$play_episode_anime_title" | sed "s/'/'\"'\"'/g")" | trackma_query)"
    get_show_entry_list="$(filter_trackma_list "$res" | head -n1)"
    # we assume we should find a result
    [ -z "$get_show_entry_list" ] &&
        printf "%b\n" "💥 ERROR getting show entry.\nPlease report this error message to the developer." && exit 1
    printf "%b" "$get_show_entry_list"
}

torrent_is_playing() {
    process_name="$(ps -p "$webtorrentpid" -o comm=)"
    if [ "$process_name" = "WebTorrent" ]; then
        true
    else
        false
    fi
}

# the menu that shows up when the media player opens
media_player_menu() {
    # block until the play status is set up
    while [ "$play_status" -eq "$PLAY_STATUS_WAITING" ]; do
        sleep 1
    done
    if [ "$play_status" -eq "$PLAY_STATUS_ERRORED" ]; then
        # fatal error, go back to mainmenu
        echo && line_to_remove
        if [ "$player_source" = "streaming" ]; then
            printf "$MSG_ERR_COLOR%s$RESET" "      💥 Unable to play the episode via streaming." && line_to_remove
        else
            printf "$MSG_ERR_COLOR%s$RESET" "      💥 Unable to stream the episode via torrenting." && line_to_remove
        fi
        printf "%s\n" "      [Enter]  Source selection ▶" && line_to_remove
        # recovery menu loop
        while true; do
            read -r key # TODO: -n1
            if [ "$key" = "" ]; then
                line_to_remove
                clear_lines
                break
            fi
        done
        player_source="torrenting"
        nyaa_search_res=""
        file_list=""
        magnet_link=""
        media_player_exit_code="$PLAYER_MENU_END_CODE"
        return
    elif [ "$play_status" = "$PLAY_STATUS_EXITED" ]; then
        # the user decided to go to main menu
        clear_lines
        clear_modifiers
        media_player_exit_code="$PLAYER_MENU_END_CODE"
        return
    fi
    clear_lines
    series_menu_title=$(trim "$anime_title")
    playing_menu=""
    if [ "$INCOGNITO_MODE" -eq 0 ]; then
        # trackma account entries
        if [ "$last_show_episode" != "?" ] && [ "$anime_ep" -eq "$last_show_episode" ]; then
            playing_menu="🏁 Set as Watched + Move to Completed list\n"
            [ "$show_type" != "movie" ] && series_menu_title="🏁 END! ─ $series_menu_title"
        else
            playing_menu="⏭️  Set as Watched + Play next\n✅ Set as Watched\n"
        fi
    fi
    # player reset entries
    if [ "$player_source" = "torrenting" ]; then
        playing_menu="${playing_menu}🔎 Select another search result\n💡 Switch to streaming\n🙈 Unexpected? Select another file ▸"
    elif [ "$player_source" = "streaming" ]; then
        playing_menu="${playing_menu}🔎 Select another search result\n😺 Switch to torrenting"
    fi
    FZF_PREVIEW_WINDOW_CMD="printf \"%s\" '$debug_match_info' | jq | bat -p --language=json"
    opt=$(printf "%b" "${playing_menu}\n${TO_MAIN_MENU}" |
        $FZF -i --prompt="Choose an action: " \
            --border-label "╢ 📺  NOW PLAYING$([ -n "$show_type" ] && printf "%s" " ($show_type)" |
                tr '[:lower:]' '[:upper:]') ─ ${series_menu_title}$([ -n "$show_type" ] && [ "$show_type" != "movie" ] && printf " ▶ Episode %s" "$anime_ep") ╟" \
            --header "⇅ Navigation ─ [ESC] Exit ─ [Enter] Select" \
            --header-first \
            --preview "$FZF_PREVIEW_WINDOW_CMD" \
            --bind "ctrl-l:toggle-preview" \
            --preview-window "$PREVIEW_WINDOW_OPTS" \
            --bind "shift-right:change-preview-window($MENU_PREVIEW_POS_MODES)+preview:$FZF_PREVIEW_WINDOW_CMD" \
            --preview-label "STREAM DEBUG")
    opt=$(printf "%s" "$opt" | cut -d " " -f1)
    if [ "$opt" = "◂" ]; then
        prompt="$TO_MAIN_MENU"
        clear_modifiers
        media_player_exit_code="$PLAYER_MENU_END_CODE"
    elif [ "$opt" = "✅" ]; then
        set_ep_as_watched
        clear_modifiers
        media_player_exit_code="$PLAYER_MENU_END_CODE"
    elif [ "$opt" = "⏭️" ]; then
        set_ep_as_watched
        if [ "$player_source" = "torrenting" ]; then
            nyaa_search_res="" # will query nyaa again
            magnet_link=""
            file_list=""
        elif [ "$player_source" = "streaming" ]; then
            animdl_playthrough=1
        fi
        play_method_menu_opt=""
        anime_ep=$((anime_ep + 1))
    elif [ "$opt" = "🏁" ]; then
        set_ep_as_watched
        set_show_status "$trackma_show_index" "Completed"
        media_player_exit_code="$PLAYER_MENU_END_CODE"
    elif [ "$opt" = "💡" ]; then
        player_source="streaming"
        magnet_link=""
        nyaa_search_res="" # will query nyaa again
    elif [ "$opt" = "😺" ]; then
        player_source="torrenting"
        file_list=""
        magnet_link=""
        nyaa_search_res="" # will query nyaa again
        media_player_exit_code="$PLAYER_MENU_SELECT_SEARCH_RES_CODE"
    elif [ "$opt" = "🔎" ]; then
        [ "$player_source" = "streaming" ] && animdl_playthrough=0
        [ "$player_source" = "torrenting" ] && nyaa_search_res="" && magnet_link=""
        file_list=""
        media_player_exit_code="$PLAYER_MENU_SELECT_SEARCH_RES_CODE"
    elif [ "$opt" = "🙈" ]; then
        play_status="$PLAY_STATUS_FILE_SEL"
        media_player_exit_code="$PLAYER_MENU_SOURCE_SELECT_CODE"
    fi
}

# global long-running trackma subprocess
spawn_trackma() {
    if [ "$DEBUG" -eq 1 ]; then
        GLOBAL_TRACKMA_TMPFILE="$CONFIG_PATH/debug_trackma_fifo"
    else
        GLOBAL_TRACKMA_TMPFILE="$(get_temp_filename)"
    fi
    GLOBAL_TRACKMA_FIFO="$(get_temp_filename)"
    mkfifo -m 600 "$GLOBAL_TRACKMA_FIFO"
    trackma <"$GLOBAL_TRACKMA_FIFO" >"$GLOBAL_TRACKMA_TMPFILE" 2>"$TRACKMA_LOGFILE" &
    exec 3>"$GLOBAL_TRACKMA_FIFO"
    # printf "%s" " ⚙️  Starting background process, please wait..." && line_to_remove
    while [ ! -s "$GLOBAL_TRACKMA_TMPFILE" ]; do :; done
    # clear_lines
}

close_trackma() {
    # printf "%s" "      ⚙️  Closing background processes, please wait..." && line_to_remove
    printf "exit\n" >"$GLOBAL_TRACKMA_FIFO"
    rm "$GLOBAL_TRACKMA_FIFO"
    echo >"$GLOBAL_TRACKMA_TMPFILE"
    # shellcheck disable=2188
    3>&-
}

trackma_query_function_code='trackma_query() {
    echo >"$GLOBAL_TRACKMA_TMPFILE"
    while read -r query </dev/stdin; do
        printf "%s\n" "$query" >"$GLOBAL_TRACKMA_FIFO"
    done
    # wait for various prompts as signal for operation finished
    while ! sed -En "/>>|\):/p" "$GLOBAL_TRACKMA_TMPFILE"; do :; done
    cat "$GLOBAL_TRACKMA_TMPFILE"
}'
eval "$trackma_query_function_code"

# attempts to play a series episode
play_episode() {
    reset_logs
    while ! connectivity_check; do
        echo && line_to_remove
        printf "$MSG_WARN_COLOR%s$RESET" "      🌴🦕 NO INTERNET CONNECTION ・・・" && line_to_remove
        printf "$MSG_WARN_COLOR%s$RESET" "      Please check your connection and press [Enter]" && line_to_remove
        read -r key # TODO: -n1
        [ "$key" = "" ] && clear_lines && continue
    done

    play_episode_anime_title="$1"
    play_episode_anime_episode="$2"
    player_source="$3"
    status="$4"
    show_type="$5"
    show_synonyms="$6"

    if [ "$player_source" = "torrenting" ]; then
        if [ -z "$magnet_link" ]; then
            # get magnet link and play it with webtorrent-cli
            if [ -z "$nyaa_search_res" ]; then
                echo && line_to_remove
                printf "$MSG_INFO_COLOR%s$RESET" "      😺 Searching Nyaa Torrents. Please wait..." && line_to_remove
                nyaa_search_res="$($NYAA_SEARCH_BIN --title "$play_episode_anime_title" --episode "$play_episode_anime_episode" --quality 1080 --show-type "$show_type")"
                nyaa_search_ret_msg=$(printf "%s" "$nyaa_search_res" | awk -F "////" '{print $1}')
                nyaa_search_ret_code=$(printf "%s" "$nyaa_search_res" | awk -F "////" '{print $2}')
                if [ "$nyaa_search_ret_code" = "$NYAA_SEARCH_CODE_NO_RESULTS" ]; then
                    echo && line_to_remove
                    printf "$MSG_WARN_COLOR%s$RESET" "      🚫 $nyaa_search_ret_msg" && line_to_remove
                    play_status=$PLAY_STATUS_ERRORED
                    return
                elif [ "$nyaa_search_ret_code" = "$NYAA_SEARCH_CODE_FATAL_ERROR" ]; then
                    echo && line_to_remove
                    printf "$MSG_WARN_COLOR%s$RESET" "      🚫 $nyaa_search_ret_msg" && line_to_remove
                    printf "$MSG_WARN_COLOR%s$RESET" "      Please contact development to work this out:" && line_to_remove
                    printf "$MSG_WARN_COLOR%s$RESET" "      https://github.com/anma-dev/Anime-Manager/issues" && line_to_remove
                    play_status=$PLAY_STATUS_ERRORED
                    return
                fi
            fi
            clear_lines
            FZF_PREVIEW_WINDOW_CMD="printf \"\n%s\n\n%b\" {} '────────────\nColor code: \n🟢 Trusted\n🔴 Remake\n⚪️ No category\n\nMore info: https://nyaa.si/help'"
            PROMPT_TEXT="Choose a search result: "
            nyaa_search_res=$(printf "%b" "$nyaa_search_res" | sed 's/'"'"'//g')
            choice=$(
                printf "%b" "{\"name\": \"$TO_MAIN_MENU\"}\n$nyaa_search_res" | jq '.name' | sed "s/^\"//g" | sed "s/\"$//g" |
                    $FZF -i --prompt "$PROMPT_TEXT" \
                        --border-label "╢ ♣  SEARCH RESULTS (Nyaa Torrents): $(trim "$play_episode_anime_title") ▶ $play_episode_anime_episode ♣  ╟" \
                        --header "⇅ Navigation ─ [ESC] Exit ─ [Ctrl-L] Expand ─ [Enter] Play (torrenting) ▸" \
                        --header-first \
                        --preview "$FZF_PREVIEW_WINDOW_CMD" \
                        --preview-window "$PREVIEW_WINDOW_OPTS" \
                        --preview-label ' Expanded view ' \
                        --bind "ctrl-l:toggle-preview" \
                        --bind "shift-right:change-preview-window($MENU_PREVIEW_POS_MODES)+preview:$FZF_PREVIEW_WINDOW_CMD" \
                        --bind "ctrl-l:toggle-preview" \
                        --bind "ctrl-b:change-prompt($(printf "\033[44;37m BLU-RAY: \033[0m"))+reload:printf \"%s\" '$nyaa_search_res' | jq '.name' | sed 's/^\"//g' | sed 's/\"$//g' | sed -En '/[bB][dD]|[bB][lL][uU][\-]*[rR][aA][yY]/p'" \
                        --bind "tab:change-prompt($PROMPT_TEXT)+reload:printf \"%s\" '$nyaa_search_res' | jq '.name' | sed 's/^\"//g' | sed 's/\"$//g'" \
                        --bind "ctrl-a:change-prompt($(printf "\033[43;37m DUAL-AUDIO: \033[0m"))+reload:printf \"%s\" '$nyaa_search_res' | jq '.name' | sed 's/^\"//g' | sed 's/\"$//g' | sed -n '/[dD][uU][aA][lL]/p'" \
                        --bind "ctrl-d:change-prompt($(printf "\033[46;37m DUBBED: \033[0m"))+reload:printf \"%s\" '$nyaa_search_res' | jq '.name' | sed 's/^\"//g' | sed 's/\"$//g' | sed -n '/[dD][uU][bB]/p'" \
                        --bind "ctrl-r:change-prompt($(printf "\033[101;37m RAW: \033[0m"))+reload:printf \"%s\" '$nyaa_search_res' | jq '.name' | sed 's/^\"//g' | sed 's/\"$//g' | sed -n '/[rR][aA][wW]/p'" \
                        --bind "ctrl-s:change-prompt($(printf "\033[103;90m SUBBED: \033[0m"))+reload:printf \"%s\" '$nyaa_search_res' | jq '.name' | sed 's/^\"//g' | sed 's/\"$//g' | sed -n '/[sS][uU][bB]/p'" \
                        --bind "ctrl-f:change-prompt($(printf "\033[104;37m MULTI: \033[0m"))+reload:printf \"%s\" '$nyaa_search_res' | jq '.name' | sed 's/^\"//g' | sed 's/\"$//g' | sed -n '/[mM][uU][lL][tT][iI]/p'" \
                        --bind "ctrl-v:change-prompt($(printf "\033[100;90m VHS: \033[0m"))+reload:printf \"%s\" '$nyaa_search_res' | jq '.name' | sed 's/^\"//g' | sed 's/\"$//g' | sed -n '/[vV][hH][sS]/p'" \
                        --bind "ctrl-t:change-prompt($(printf "\033[42;37m TRUSTED: \033[0m"))+reload:printf \"%s\" '$nyaa_search_res' | jq '.name' | sed 's/^\"//g' | sed 's/\"$//g' | sed -n '/🟢/p'" \
                        --bind "ctrl-o:change-prompt($(printf "\033[45;37m OVA: \033[0m"))+reload:printf \"%s\" '$nyaa_search_res' | jq '.name' | sed 's/^\"//g' | sed 's/\"$//g' | sed -n '/[oO][vV][aA]/p'"
            )
            [ "$choice" = "$TO_MAIN_MENU" ] && play_status="$PLAY_STATUS_EXITED" && return
            magnet_link="$(printf "%s" "$nyaa_search_res" | jq -c "select( .name == \"$choice\" )" | jq --raw-output ".magnet")"
        fi
        if [ -z "$file_list" ]; then
            echo && line_to_remove
            printf "$MSG_INFO_COLOR%s$RESET" "      🗃️  Searching for matching file..." && line_to_remove
            play_episode_TORRENT_INFO="$(python3 "$NYAA_FE_BIN" --title "$play_episode_anime_title" --synonyms "$(printf "%s" "$show_synonyms")" --magnet-link "$magnet_link" --episode "$play_episode_anime_episode" --type "$show_type")"
            EP_DATA="$(printf "%s" "$play_episode_TORRENT_INFO" | awk -F"////" '{print $1}')"
            file_list="$(printf "%s" "$play_episode_TORRENT_INFO" | awk -F"////" '{print $2}')"
            file_index="$(printf "%s" "$play_episode_TORRENT_INFO" | awk -F"////" '{print $3}')"
            debug_match_info=$EP_DATA
        fi

        [ "$file_index" = "$NYAA_FID_CODE_CONTENT_MISMATCH" ] && play_status="$PLAY_STATUS_FILE_SEL"

        if [ "$play_status" = "$PLAY_STATUS_FILE_SEL" ]; then
            if [ "$file_list" = "None" ]; then
                printf "$MSG_WARN_COLOR%s$RESET" "      🚫 No matching files, please select another source" && line_to_remove
                magnet_link=""
                file_list=""
                play_status=$PLAY_STATUS_ERRORED
                return
            fi
            FZF_PREVIEW_WINDOW_CMD="printf \"\n%s\n\n%b\" {}"
            file_index=$(
                printf "%b" "$file_list\n◀ Now Playing" | sed "s/\"//g" |
                    $FZF -i --prompt "Choose a file: " \
                        --border-label "╢ ♣  🗃️  FILE SELECTION: $(trim "$play_episode_anime_title") ▶ $play_episode_anime_episode ♣  ╟" \
                        --header "⇅ Navigation ─ [ESC] Exit ─ [Ctrl-L] Expand ─ [Enter] Stream (torrenting) ▸" \
                        --header-first \
                        --preview "$FZF_PREVIEW_WINDOW_CMD" \
                        --preview-window "$PREVIEW_WINDOW_OPTS" \
                        --bind "shift-right:change-preview-window($MENU_PREVIEW_POS_MODES)+preview:$FZF_PREVIEW_WINDOW_CMD" \
                        --preview-label ' Expanded view ' \
                        --bind "ctrl-l:toggle-preview" | cut -d " " -f1
            )
        fi

        [ "$file_index" = "◀" ] && play_status="$PLAY_STATUS_OKPLAYING" && return

        if [ "$file_index" != "$NYAA_SEARCH_CODE_FATAL_ERROR" ]; then
            # run completely detached from terminal for availability
            torrent_pid_file="$(get_temp_filename)"
            set +m
            (
                nohup node "$WEBTORRENT_CLI" download "$magnet_link" --select "$file_index" --out "$TORRENT_DOWNLOAD_DIR" --"$MEDIA_PLAYER" >"$WEBTORRENT_LOGFILE" 2>&1 &
                echo $! >"$torrent_pid_file"
            )
            set -m
            # printf "%s" "$EP_DATA" | jq '.name' >"$CURRENTLY_PLAYING_LOGFILE"
            # remove from job queue to avoid info messages if we have to end the process with kill
            echo && line_to_remove
            printf "$MSG_INFO_COLOR%s$RESET" "      🚀 Torrent is playing soon (please wait...)" && line_to_remove
            play_episode_torrent_status=$(check_torrent_health "$(cat "$torrent_pid_file")")
            if [ "$play_episode_torrent_status" -eq $TORRENT_STATUS_ERRORED ]; then
                printf "$MSG_WARN_COLOR%s$RESET" "      🚫 Unable to play torrent" && line_to_remove
                magnet_link=""
                play_status=$PLAY_STATUS_ERRORED
            else
                rm "$torrent_pid_file"
                play_status=$PLAY_STATUS_OKPLAYING
            fi
        else
            printf "$MSG_WARN_COLOR%s$RESET" "      🚫 Unable to get file index" && line_to_remove
            magnet_link=""
            file_list=""
            play_status=$PLAY_STATUS_ERRORED
        fi
    elif [ "$player_source" = "streaming" ]; then
        stream_providers=$(array "animepahe" "allanime" "zoro" "animeout" "gogoanime" "tenshi")
        echo && line_to_remove
        printf "$MSG_INFO_COLOR%s$RESET" "      💡 Streaming (animdl)" && line_to_remove
        while IFS= read -r provider; do
            d_provider=$(printf '%s\n' "$provider" | array_element_decode)
            if [ "$animdl_playthrough" -eq 0 ]; then
                play_episode_stream_fifo_write="$(get_temp_filename)"
                mkfifo -m 600 "$play_episode_stream_fifo_write"
                # TODO: can't stream with iina
                set +m
                nohup animdl stream "$d_provider:$play_episode_anime_title" --range "$anime_ep" --player "mpv" <"$play_episode_stream_fifo_write" >"$ANIMDL_LOGFILE" 2>&1 &
                animdl_pid=$!
                set -m
                exec 4>"$play_episode_stream_fifo_write"
                printf "$MSG_INFO_COLOR%s$RESET" "      🔎 Please wait, searching the stream provider ($d_provider)..." && line_to_remove
                stream_health=10
                while [ $stream_health -gt 0 ]; do
                    # check for search result prompt
                    if ! grep "Select the search result" "$ANIMDL_LOGFILE" >/dev/null 2>&1; then
                        if [ -z "$(sed -En "s/AV:|libmpv|A-V/&/p" "$ANIMDL_LOGFILE")" ]; then
                            stream_health=$((stream_health - 1))
                        else
                            # stream started automatically
                            play_status=$PLAY_STATUS_OKPLAYING
                            printf "$MSG_INFO_COLOR%s$RESET" "      🚀 The stream is starting (please wait...)" && line_to_remove
                            return
                        fi
                    else
                        break
                    fi
                    sleep 1
                done
                if [ $stream_health -eq 0 ]; then
                    printf "$MSG_WARN_COLOR%s$RESET" "      🚫 No results found ($d_provider), next..." && line_to_remove
                    play_status=$PLAY_STATUS_ERRORED
                    # next provider
                    echo >"$ANIMDL_LOGFILE"
                    continue
                fi
                clear_lines
                results=$(sed -En '/^[[:space:]]+[0-9]+\./p' "$ANIMDL_LOGFILE")
                animdl_search_index="$(
                    printf "%b" "$TO_MAIN_MENU\n$results" | sed "s/^[[:space:]]*//" |
                        $FZF --prompt="Select a search result: " \
                            --border-label "╢ ♣  SEARCH RESULTS ($d_provider): $(trim "$play_episode_anime_title") ▶ Episode $anime_ep ♣  ╟" \
                            --header "⇅ Navigation ─ [ESC] Exit ─ [Enter] Play" \
                            --header-first | cut -d '.' -f1
                )"
                [ -z "$animdl_search_index" ] && exit 1
                [ "$animdl_search_index" = "$TO_MAIN_MENU" ] && play_status=$PLAY_STATUS_EXITED && animdl_search_index="" && return
                printf "%b" "$animdl_search_index\n" >&4
                # shellcheck disable=2188
                4>&-
                sleep 2 # wait for the stream to start
                stream_health=15
                printf "$MSG_INFO_COLOR%s$RESET" "      Trying to stream with $d_provider" && line_to_remove
                while [ $stream_health -gt 0 ]; do
                    if [ -z "$(sed -En "s/AV:|libmpv|A-V/&/p" "$ANIMDL_LOGFILE")" ]; then
                        stream_health=$((stream_health - 1))
                    else
                        break
                    fi
                    sleep 1
                done
                if [ $stream_health -eq 0 ]; then
                    echo && line_to_remove
                    printf "$MSG_WARN_COLOR%s$RESET" "      🚫 Unable to stream with $d_provider, next..." && line_to_remove
                    play_status=$PLAY_STATUS_ERRORED
                    # next provider
                    echo "" >"$ANIMDL_LOGFILE"
                    continue
                else
                    rm "$play_episode_stream_fifo_write"
                    unset stream_tmpfile
                    unset stream_fifo_write
                    printf "$MSG_INFO_COLOR%s$RESET" "      🚀 The stream is starting (please wait...)" && line_to_remove
                    play_status=$PLAY_STATUS_OKPLAYING
                    return
                fi
            else
                [ -z "$animdl_search_index" ] && exit 1
                # TODO: can't stream with iina
                set +m
                nohup animdl stream "$d_provider:$play_episode_anime_title" --index "$animdl_search_index" --range "$anime_ep" --player "mpv" >"$ANIMDL_LOGFILE" 2>&1 &
                set -m
                sleep 2 # wait for the stream to start before presenting the streaming options
                stream_health=10
                while [ $stream_health -gt 0 ]; do
                    if [ -z "$(sed -En "s/AV:|libmpv|A-V/&/p" "$ANIMDL_LOGFILE")" ]; then
                        stream_health=$((stream_health - 1))
                    else
                        break
                    fi
                    sleep 1
                done
                if [ $stream_health -eq 0 ]; then
                    echo && line_to_remove
                    printf "$MSG_WARN_COLOR%s$RESET" "      🚫 Unable to stream with $d_provider" && line_to_remove
                    play_status=$PLAY_STATUS_ERRORED
                    # next provider
                    continue
                else
                    play_status=$PLAY_STATUS_OKPLAYING
                    return
                fi
            fi
        done <<EOF
$stream_providers
EOF
    elif [ "$player_source" = "self_magnet" ]; then
        echo && line_to_remove
        printf "$MSG_INFO_COLOR%s$RESET" "      🧲 Paste your magnet link and press Enter (silent input): " && line_to_remove
        stty_orig=$(stty -g)
        stty -echo
        read -r magnet_link
        stty "$stty_orig"
        magnet_link="$(printf "%s" "$magnet_link" | sed "s/;//g" | tr -d '\012')" # newline esc seq in octal
        clear_lines
        player_source="torrenting"
        play_episode "$anime_title_trackma" "$anime_ep" "$player_source" "$status" "$show_type" "$show_synonyms"
    fi
}

paint_logo() {
    LOGO_MONOCHROME="H4sIAEdnvWMAA+Pi4lIAg/DUnOT83FSFknwF0sGjOSugxjya1vFoWgMYdSBzWoCciWDWRLhwC7oyhccNDbhlsZiIXaYByURkNchObAEjqLaJYATiNEDUw4Ub4DIYTkSXxWEiFhk0TyOpaYA7sQFmRgMWTgOaMJoMxIlYZInkoNiAYheYU2agZ6BnyAUAdHKfkjoCAAA="
    LOGO_DEFAULT_B64="H4sIAEFjvWMAA73WO24bMRAG4F5XcMMTBHzvLuYgKVIG7mKkCVKrcKFWTaocIOdyLpJ/tPIuZ4aSFoHkQpbxYTgkxeHj6UsaKVIs5fTxL7un/xEnJDxK8gD5bOTZyDcjX418FxIhL0aejTgjP4yIzPhPtfpQyQ8T/yiJpqLuJqaiHidh+EBJjxJvKupuYirqgWJq7CRvv/8Y221o10qY6h3l7ddBWDjZfqPZtu5W1DjYbFfs1ZjrRB03ZpNxuvZm0eNNnWypM7ZO3DDZfCdzm6L62aTpypvl735LlO4zd/J7O9Oz9eIOxtymKJWt1ot2MOY2Rels8aK9GnOdqMOtbKVThWc7GHObonS2TsVdNNeJOtwnW+7Ub+7U6hWzbXdC9L16PzE1mjs1mju7oGuBgm6bBoqyB0gyUSNlfT7hBVSMFaqmbaFB9RBp1L80bDItEwWzJIxB5fMUomkMTHp8seJX0BnjgLIxkUAzlRlF3zHjjDBxfOCabvjGMRgYZUZ8myOSUc06jEyq5zDh6WXm4vGqND2fUUSGihe7yXlC2Teqppi4TLHqmruI5kcLgdFpGntxoxk4vieNeGNFU1R+oqT21Ew6rlIKeuAX0ZSfT4xOk9lZ77gOHAWFB1uSZcroZzxYdIICJbk2acV9g9NIqXZtzYddibHItVrt9aoFmgoluQ9ggW3XSqTU7gG/ScaJcrOOOJU3SaUc2hHlcbFjawPleMHWtgPhWZWbZWbJlJOOCrOt2SqNvmOIE+u+2NoDTtNRR80m1jfnvhU21wpmL6ogp8WOtwyzH4TFxfateba110ADZiUq44LVQZs/m2sFM53aIzNNVAubM9LkYktUxMsbf7fZQNVTEbW0mLsaVRc7NlZGKqLicG++2761wrb2kM/SRsEwXlFdKfUt6rawQKWpONzM2G5F1DQMm6mIWzPx8nFLZQMVUV+4mFHWpalCljK3XKIitm5WLdnS3OtqWHoMcNAWuO3SAy5ulInKhncO5iCqC++DpMfLxsvTZIMU3SeOuoyFbWfPhvGKmsN7AT+KagvzHLf2kHBzcZ8/Wxk5v18En8qtPrXCRdPE4K5MMgYSOSYsgoeA58z/APGbmLr7FAAA"
    LOGO_XMAS_B64="H4sIALYVt2MAA8XXPW4UQRAF4NynWC6A+r9nVGcgBgkngMiwkAAhk22wAQFCckLqu8EFOAKvZtbWdvWb8RpYO7DX+lRb1d1T3dM+v/SvX8ZBgoScpx93cXZ+LG6OQn8ifG4wVeBbhu8YvmH4nuGFxcAKBTLOCT8x7Aqxr+Ovx8T0UOgeCAPrz5Mga9rHRV9PhL+vv++sRxas+Iyh3UoTfjgGnfbtF4a2+oQvGNrdPeEri9q3Hxk+YdhVT9NCfbtmbo9WnoH18wnQjwX488dXztt7MU3SFfQ81vPMq7xjbAsOdYq94mwzr0UvZLZTWcoc6Zj3vBDd5SZbbSm2jjTzGtvME/7aHheb+CgSL5foaqxHd7lZR0+4EEsyr/JRBQvv/sL3yjrb9ShsC5XACwaeeZVpElsw80bPvNH/gruCvKMz3ytr/G+ZE98re7ZJJj5jaEfBkVwt/guSkTrabetMk3QFeWws4smxGqsEzpElGSR1BWOWQh4RuLIUQQYWHWTsM0fxdC5wOhknPrDk8LgQn0j+UNGP3WhUy0I0W4CQcFwx1xdGn13fnuSkx93S9ysT8MlWRp2tjB9mt9n9iNsriQ8ON3qWf3I7Gl/w/xSJxnU1ZNLOi54ksBWevasKZR3m/ezdGsCHFe/y4LNfedxWoX20GyWyrbvoRaJneSbvqkIDi46z2zmpR/K8b7zJgz7FFTiana3qVEm0l5ht9rjo4yDRPL4bNLlxCNSZd4YxvrrMTUEvY5Y4tO8BoFfcHINBonnwjuMwSnJ3I142M7YjVS6S7H5Nw128NVwlhbZgFVxJkz0LlZMkexQqe8JFBjfz1jCi2265RROLd8CwyLZVUtrzxmDmsViNYscc78tYJttBKex5Y9CRWC8VE7evtGUuVbnJ7KRg2vbwV87Kh7Fx3GOb94AP54ffJUq2/07dzU3uKsVJbs+kWzSx5ZavWsYls+cseZBsu1Q5K28YmtgkOEuybd0lhgWSBOwltx2NCwn2crbdD8a2zdlm1oetKXrGxO3tAPcObJjcNrpinlPY2NSnCDhP4jwOy6FPEtBfXpNsDDqSAicwZmhbVxkztP0f8GKqXWZgJrE4lhMaxCySMqZiexrXJ30G3TjATqObghEvZY39bHDQcu4Q8VP0608Nai+2kbgWxC4SOA3KHyIuRU4L/QEhaktX3RcAAA=="
    LOGO_HALLOWEEN_B64="H4sIADEPt2MAA8XXO24UQRAG4NynWC6A+j09qgtwAwJIAJHxChCPbCUcECE5IeUg3AYuwBH4a2ZtbVf/PV4DNoG91qfaqu6e6p724w/+6aNYJUjIeflxL88en4q7k9DfEj40mCbgc4YvGD5j+JrhS4uBFQpknAu+ZdgVYl/HX/8T012huyMMrD9vBVnT3i3++vblk3E/keAFHzB8wvDNSRiBHxl21SOrHln1SDayqyO0+2vB9wztRuaoffuK4T2GdpoL/vp28Z25PVp5BtbPt4B+LsAfXz9z3t+IaZKuoOexnmfe5HPGtmCdltgLzjbzVvQgs53KKHOkYz7wILrLTXbVKHaaaeYttpkX/Lk/LTbxUSReLtHV2I7ucrOOXnAQSzJv8kkFC+/+wvfKNtv1KGwLlcALBp55k2kSWzDzRs+80f+Au4K8ozPfK1v8d5kT3ysHtkkWPmNoR8GRXC3+CZKROtpt20yTdAV5bCziybEaJwmcI0tSJXUFY5ZCHhF4YimCVBYdZO4zR/F0LnA6GSc+sOTwOIhPJH+Y0I/daFTLIJotQEg4rpjrC6PPrm9PctLjbun7lQn4ZCujzlbG19Vtdj/j9krig8ONnuVf3I7GF/w/RaJxVw2ZtPPQkwS2wqt3VaGsw7xfvVsDeN3wLg8++5XHbRXaR7tZItu6Qy8SPcuzeFcVGlh0XN3OST2S533pTR70Ka7A0exsVadKor3EbLPHoc9Vonl8l2hy4xCYVj43jPFNY24KepmzxNq+B4BecXcKBonmwTuOdZbkrke8bFZsR6pcJNn9mup1vDc8SQptwUlwJU32LFROkuxRqOwJF6lu5b1hRLfdcoUmFu+AOmTbKikdeGcw81isRrFjjjdlLJPtoBQOvDPoSKyXCRO3r7Qxl0m5yeykYNr28FfOysexcT5gm/eIj+eH3yVKtv9OXc9N7kmKk9yeSVdoYssVX7SMS2bPWXKVbLtUOSvvGJrYJDhLsm3dEcMCSQL2ktuOxoUEeznb7gdj2+ZsM+vD1hQ9Y+L2doB7BzZMbhtdMa8pbGzqUwScJ3Edh+XQJwnoL69JdgYdSYETGDO0rauMGdr+D3gxTV1mYCaxOJYTGsQskjKmYnsa1yd9Bt04wE6jm4IRL2WNfWewajl3jPgp+vX7BrUX20hcC2IXCVwG5Y8RlyKnhc5+AyB6tXLeFwAA"

    # print the logos
    [ "$MONOCHROME_LOGO" -eq 1 ] && LOGO_B64=$LOGO_MONOCHROME || LOGO_B64=$LOGO_DEFAULT_B64
    # special dates
    [ "$DATE_MONTH" -eq 10 ] && [ "$DATE_DAY" -eq 31 ] && LOGO_B64=$LOGO_HALLOWEEN_B64
    [ "$DATE_MONTH" -eq 12 ] && [ "$DATE_DAY" -eq 24 ] || [ "$DATE_DAY" -eq 25 ] && LOGO_B64=$LOGO_XMAS_B64
    # [ $DATE_MONTH -eq 12 ] && [ $DATE_DAY -eq 31 ] && LOGO_B64=$LOGO_NEWYEAR_B64

    if [ "$DEBUG" -eq 0 ]; then
        printf "%b\n" "$(
            base64 -d <<EOF | gunzip
$LOGO_B64
EOF
        )"
    fi
    printf "$TITLE_COLOR%s$RESET" "      🍿 Watch and Track Anime from Your Terminal"
    printf "$MSG_HELP_COLOR%s$RESET" "         Use arrow keys/mouse scroll to navigate. Type to filter results" && echo

}

print_account() {
    clear_lines
    printf "$SUBTITLE_COLOR%s$RESET" "      👤 Account ─ ${USERNAME} │"
}

print_incognito_msg() {
    clear_lines
    printf "      "
    printf "$INCOGNITO_MODE_COLORS%s$RESET" "🕵  INCOGNITO MODE "
}

check_torrent_health() {
    # allow it to start first
    sleep 2
    check_torrent_health_waitingtime=0
    check_torrent_health_checkinterval=5
    check_torrent_health_torrent_status=$TORRENT_STATUS_STALLED
    check_torrent_health_webtorrentpid="$1"
    while [ $check_torrent_health_torrent_status = "$TORRENT_STATUS_STALLED" ] && [ $check_torrent_health_waitingtime -lt $TORRENT_TMOUT ]; do
        # if the torrent is not finding peers
        # before or after download start
        lastlog="$(tail -n20 "$WEBTORRENT_LOGFILE")"
        if [ -z "$(printf "%s" "$lastlog" | sed -n "/Streaming/p")" ] || [ -n "$(printf "%s" "$lastlog" | sed -n "/Peers: 0\/0/p")" ]; then
            check_torrent_health_waitingtime=$((check_torrent_health_waitingtime + check_torrent_health_checkinterval))
            sleep $check_torrent_health_checkinterval
        else
            break
        fi
    done
    if [ $check_torrent_health_waitingtime -eq $TORRENT_TMOUT ]; then
        # kill the process
        kill -9 "$check_torrent_health_webtorrentpid" >/dev/null 2>&1
        printf "%s" "$TORRENT_STATUS_ERRORED"
    else
        printf "%s" "$TORRENT_STATUS_OKPLAYING"
    fi
}

account_menu() {
    MAIN_MENU_HELPTEXT="
🐇  Follow the white rabbit for more menu options.
───
🕵️  Switch Incognito Mode on. Browse and watch without syncing your activity with any account.
───
👍  Score an anime or change an anime score.
───
🔄  Update the status of your anime.
───
📙  Browse all your lists. It can also play anime.
───
🧩  Add a new anime to your Plan to Watch list.
───
🔀  Select one random anime from your watching lists (watching, rewatching) and play it.
───
📺  Open your watching lists (watching, rewatching) for playing an anime.
───
👁️  Your watching history with anime and episode count.
"

    SUB_MENU_HELPTEXT="
🌟  Display your lists in descending order by score.
───
↑  Upload your local progress to your tracking service.
───
↓  Download your remote progress and update your local lists.
───
📝  Set the alternative name for an anime.
───
🔄  Update your watching progress on an anime.
───
📣  Display your lists by showing currently airing anime only.
───
📣  Play one random, currently airing anime from your watching lists (watching, rewatching).
───
🗑️  Delete an anime from your lists. You will lose all your progress on that anime.
───
👤  Switch between the various accounts connected to Trackma.
"
    prompt=""
    MAINMENU_ENTRIES="$WATCH_HISTORY\n$WATCH\n$WATCH_RANDOM\n$ADD_SHOW\n$LIST\n$UPDATE_STATUS\n$SCORE_SHOW\n$ENTER_INCOGNITO_MODE\n$TO_SUBMENU"
    SUBMENU_ENTRIES="$SWITCH_ACCOUNTS\n$DELETE_SERIES\n$WATCH_RAND_AIRING\n$LIST_AIRING\n$UPDATE_EPISODES\n$SET_ALTNAME\n$PULL\n$PUSH\n$LIST_BY_SCORE\n$TO_MAIN_MENU"
    MAINMENU_TITLE="MAIN MENU"
    SUBMENU_TITLE="SUB 🐰 MENU"
    menu_entries=$MAINMENU_ENTRIES
    menu_title=$MAINMENU_TITLE
    menu_help_text=$MAIN_MENU_HELPTEXT
    WATCH_HISTORY_FILE="${CONFIG_PATH}/$(printf "%s" "$USERNAME" | sed -E 's/[^a-zA-Z0-9]//g')-watch-history"
    [ ! -f "$WATCH_HISTORY_FILE" ] && touch "$WATCH_HISTORY_FILE"
    if [ "$TRACKER_SERVICE" = "anilist" ]; then
        # exception for anilist
        TRACKMA_STATUS_MENU_ENTRIES="$(printf "%b" "Watching\nCompleted\nRewatching\nPaused\nDropped\nPlan to Watch" | sort -r)"
    else
        TRACKMA_STATUS_MENU_ENTRIES="$(printf "%b" "Watching\nCompleted\nOn Hold\nDropped\nPlan to Watch" | sort -r)"
    fi
    while true; do
        if [ -z "$prompt" ]; then
            clear_modifiers
            FZF_PREVIEW_WINDOW_CMD="printf \"%s\" \"$menu_help_text\""
            prompt=$(
                printf "%b" "$menu_entries" |
                    $FZF -i --prompt="Choose an action: " \
                        --border-label "╢ ♣  $menu_title ♣  ╟" \
                        --header "⇅ Navigation ─ [ESC] Exit ─ [Ctrl-L] Help ─ [Enter] Select" \
                        --header-first \
                        --preview "$FZF_PREVIEW_WINDOW_CMD" \
                        --preview-window "$PREVIEW_WINDOW_OPTS" \
                        --bind "shift-right:change-preview-window($MENU_PREVIEW_POS_MODES)+preview:$FZF_PREVIEW_WINDOW_CMD" \
                        --bind "ctrl-l:toggle-preview" \
                        --preview-label " Help "
            )
        fi
        case $prompt in
        "$SWITCH_ACCOUNTS")
            line_to_remove # remove account label
            clear_lines    # remove account label
            printf "account\n" | trackma_query >/dev/null 2>&1
            # select_account
            break
            ;;
        "$ENTER_INCOGNITO_MODE")
            INCOGNITO_MODE=1
            line_to_remove # remove account label
            clear_lines    # remove account label
            close_trackma
            break
            ;;
        "$TO_MAIN_MENU")
            menu_entries=$MAINMENU_ENTRIES
            menu_title=$MAINMENU_TITLE
            menu_help_text=$MAIN_MENU_HELPTEXT
            clear_modifiers
            ;;
        "$TO_SUBMENU")
            menu_entries=$SUBMENU_ENTRIES
            menu_title=$SUBMENU_TITLE
            menu_help_text=$SUB_MENU_HELPTEXT
            clear_modifiers
            ;;
        "$WATCH_HISTORY")
            clear_modifiers
            if [ ! -s "$WATCH_HISTORY_FILE" ]; then
                sel=$(printf "Your watch history is empty\n%s" "$TO_MAIN_MENU" | $FZF -i --border-label "╢ ♣  YOUR WATCH HISTORY ♣  ╟" --header "⇅ Navigation ─ [ESC] Exit" --header-first)
            else
                HIST=$(column -t -s "////" "$WATCH_HISTORY_FILE")
                HIST="$TO_MAIN_MENU\n$HIST"
                sel=$(printf "%b" "$HIST" | $FZF -i --prompt="Select an anime: " --border-label "╢ ♣  WATCH HISTORY ♣  ╟" --header "[Enter] Play ▸ new episode" --header "⇅ Navigation ─ [ESC] Exit ─ [Enter] Play ▸" --header-first --tac --no-sort)
                [ "$sel" = "$TO_MAIN_MENU" ] && prompt=$TO_MAIN_MENU && continue
                anime_title_trackma=$(printf "%s" "$sel" | sed -En "s/^(.*)[[:space:]]+([[:digit:]]+)$/\1/p" | sed "s/[[:space:]]*$//")
                last_show_episode="$(get_last_show_ep "$anime_title_trackma")"
                [ -z "$last_show_episode" ] && printf "Could not get last episode" && exit 1
                last_watched_ep=$(printf "%s" "$sel" | sed -En "s/^(.*)[[:space:]]+([[:digit:]]+)$/\2/p" | sed "s/[[:space:]]*$//")
                # only increment if it's not the last episode of the show
                # if we don't know the last aired apisode just attempt playing the next episode
                [ "$last_show_episode" = "?" ] || [ "$last_watched_ep" -lt "$last_show_episode" ] && anime_ep=$((last_watched_ep + 1)) || anime_ep="1"
                status="$(get_show_status "$(printf "%s" "$anime_title_trackma" | sed "s/\[.*\]//g" | sed "s/ $//g")")"
                trackma_index="$(get_entry_index "$(printf "%s" "$anime_title_trackma" | sed "s/\[.*\]//g" | sed "s/ $//g")" "$status")"
                prompt="$WATCH"
            fi
            ;;
        "$WATCH_RANDOM")
            random_anime=1
            prompt=$WATCH
            ;;
        "$WATCH_RAND_AIRING")
            random_airing=1
            prompt=$WATCH
            ;;
        "$WATCH")
            # This section plays shows currently being watched by default or one specified show
            if [ -z "$anime_title_trackma" ] && [ -z "$anime_ep" ]; then
                full_info=$(get_watching_shows)

                if [ ! "$full_info" ]; then
                    full_info="Your watching list is empty"
                    choice=$(
                        printf "%s\n%s" "$full_info" "$TO_MAIN_MENU" |
                            $FZF -i --prompt "Choose an anime to watch: " \
                                --border-label "╢ ♣  YOUR $(
                                    if [ "$TRACKER_SERVICE" = "anilist" ]; then
                                        printf "%s" "(RE)WATCHING LISTS"
                                    else
                                        printf "%s" "WATCHING LIST"
                                    fi
                                ) ♣  ╟" \
                                --header "⇅ Navigation ─ [ESC] Exit ─ [Enter] Play ▸" \
                                --header-first
                    )
                    clear_modifiers
                    continue
                fi

                # remove character sequences and add an emoji next to shows currently airing
                full_info=$(printf '%s\n' "$full_info" | sed "s,$(printf '\033')\\[[0-9;]*[a-zA-Z],📣 ," | sed "s,$(printf '\033')\\[[0-9;]*[a-zA-Z],,g" | sed "s,\x1B\[[0-9;]*[a-zA-Z],,g" | sed -E "/📣/ s/(.*)\.{3}(.*)/\1\2/")

                if [ "$random_anime" -eq 1 ]; then
                    choice=$(printf "%s" "$full_info" | shuf -n 1)
                elif [ "$random_airing" -eq 1 ]; then
                    # format and filter airing shows, select one randomly
                    choice=$(printf "%s" "$full_info" | sed "s,$(printf '\033')\\[[0-9;]*[a-zA-Z],📣 ," | sed "s,\x1B\[[0-9;]*[a-zA-Z],,g" | sed -n "/📣/p" | shuf -n 1)
                else
                    full_info="$(printf "%s" "$full_info" | sort -r --version-sort)"
                    choice=$(
                        printf "%s\n%s" "$TO_MAIN_MENU" "$full_info" |
                            $FZF -i --prompt "Choose an anime to watch: " \
                                --border-label "╢ ♣  YOUR $(
                                    if [ "$TRACKER_SERVICE" = "anilist" ]; then
                                        printf "%s" "(RE)WATCHING LISTS"
                                    else
                                        printf "%s" "WATCHING LIST"
                                    fi
                                ) ♣  ╟" \
                                --header "⇅ Navigation ─ [ESC] Exit ─ [Enter] Play ▸" \
                                --header-first
                    )
                fi

                [ "$choice" = "$TO_MAIN_MENU" ] && prompt=$TO_MAIN_MENU && continue

                if [ ! "$choice" ]; then
                    echo && line_to_remove
                    printf "$MSG_WARN_COLOR%s$RESET" "      We couldn't find any anime of this type!" && line_to_remove
                    sleep 2
                    clear_lines
                    clear_modifiers
                    continue
                fi
                trackma_index="$(printf "%s" "$choice" | sed -En "s/$TRACKMA_ENTRY_REGEX/\1/p")"
                anime_title_trackma=$(get_show_title "$choice")
                status="$(get_show_status "$(printf "%s" "$anime_title_trackma" | sed "s/\[.*\]//g" | sed "s/ $//g")")"
                trackma_show_index=$(printf "%s" "$choice" | cut -d " " -f1)
                last_watched_ep="$(printf "%s" "$choice" | sed -En "s/.*[[:space:]]+([0-9]*) \/.*/\1/p")"
                last_show_episode="$(get_last_show_ep "$anime_title_trackma")"

                [ -z "$last_show_episode" ] && printf "Couldn't get last episode" && exit 1
                # if we just don't know what the last episode is we increment anyways and give it a try
                [ "$last_show_episode" = "?" ] || [ "$last_watched_ep" -lt "$last_show_episode" ] && anime_ep=$((last_watched_ep + 1)) || anime_ep="1"
            fi

            [ -z "$status" ] && printf "Couldn't get status" && exit 1

            if [ "$(get_trackma_status_code "$status")" != "$(get_trackma_status_code "Watching")" ] && [ "$(get_trackma_status_code "$status")" != "$(get_trackma_status_code "Rewatching")" ]; then
                new_status="Watching"
                menu_play_options="▶️  Play\n🔄 Set status as Watching + Play"
                if [ "$status" = "$(get_trackma_status_code "Completed")" ]; then
                    menu_play_options="▶️ Play\n🔄 Set status as Watching + Reset watched + Continue Playing"
                    reset_episodes=1
                    if [ "$TRACKER_SERVICE" = "anilist" ]; then
                        new_status="Rewatching"
                        menu_play_options="▶️ Play\n🔄 Set status as Rewatching + Continue Playing"
                    fi
                else
                    reset_episodes=0
                fi

                selected_play_option=$(printf "%b\n%s" "$menu_play_options" "$TO_MAIN_MENU" |
                    $FZF -i --prompt "Choose an option: " --border-label "╢ ♣  PLAY OPTIONS ♣  ╟" --header "⇅ Navigation ─ [ESC] Exit ─ [Enter] Select" --header-first | cut -d " " -f1)
                [ "$selected_play_option" = "◂" ] && clear_modifiers && continue
                if [ "$selected_play_option" = "🔄" ]; then
                    printf "filter %s\nstatus '%s' %s\n" "$(get_trackma_status_code "$status")" "$trackma_index" "$(get_trackma_status_code "$new_status")" | trackma_query >"$TRACKMA_LOGFILE" 2>&1
                    if [ $reset_episodes -eq 1 ]; then
                        printf "filter %s\nupdate '%s' %s\n" "$(get_trackma_status_code "$status")" "$trackma_index" "0" | trackma_query >>"$TRACKMA_LOGFILE"
                        anime_ep="1"
                        last_watched_ep="0"
                    fi
                    status=$new_status
                    # update series index after changing lists
                    trackma_index="$(printf "filter %s\nsearch '%s'\n" "$(get_trackma_status_code "$status")" "$(printf "%s" "$anime_title_trackma" | sed "s/'/'\"'\"'/g")" | trackma_query | sed -En "s/$TRACKMA_ENTRY_REGEX/\1/p")"
                fi
            fi

            # We query trackma again because we want official english and romaji titles
            series_info=$(printf "filter %s\ninfo %s\n" "$(get_trackma_status_code "$status")" "$trackma_index" | trackma_query)
            anime_title_ro="$(printf "%s" "$series_info" | sed -n "/Romaji/p" | cut -d ":" -f2 | sed "s/ //")"
            anime_title_en="$(printf "%s" "$series_info" | sed -n "/English/p" | cut -d ":" -f2 | sed "s/ //")"
            # give preference to Romaji, then Japanese, then English titles, as this gives better matching
            if [ -n "$anime_title_ro" ] && [ "$anime_title_ro" != "None" ]; then
                anime_title=$anime_title_ro
            else
                anime_title=$anime_title_trackma
            fi
            show_type=""
            show_synonyms=""
            # player loop
            play_method_menu_opt=""
            player_source=""
            while true; do
                if [ -z "$player_source" ]; then
                    if [ "$random_anime" -eq 1 ]; then
                        menu_label="SELECT SOURCE: 🔀 $(trim "$anime_title_trackma") ▶ $anime_ep"
                    elif [ "$random_airing" -eq 1 ]; then
                        menu_label="SELECT SOURCE: 📣 $(trim "$anime_title_trackma") ▶ $anime_ep"
                    else
                        menu_label="SELECT SOURCE: $(trim "$anime_title_trackma") ▶ $anime_ep"
                    fi
                    play_method_menu_opt="$(
                        printf "%b" "$PLAY_METHOD_MENU" |
                            $FZF -i --prompt="Select a source: " \
                                --border-label "╢ ♣  $menu_label ♣  ╟" \
                                --header "⇅ Navigation ─ [ESC] Exit ─ [Enter] Select" \
                                --header-first | cut -d " " -f1
                    )"
                    if [ "$play_method_menu_opt" = "◂" ]; then
                        prompt="$TO_MAIN_MENU"
                        clear_modifiers
                        break
                    elif [ "$play_method_menu_opt" = "💡" ]; then
                        player_source="streaming"
                    elif [ "$play_method_menu_opt" = "😺" ]; then
                        player_source="torrenting"
                    elif [ "$play_method_menu_opt" = "🧲" ]; then
                        player_source="self_magnet"
                    fi
                fi
                show_info="$(get_show_info "$anime_title_trackma" "$status")"
                if [ -z "$show_type" ]; then
                    if printf "%s" "$show_info" | grep "Type: " >/dev/null 2>&1; then
                        show_type="$(printf "%b" "$show_info" | grep "Type: " | awk -F": " '{print $2}')"
                    fi
                fi
                if [ -z "$show_synonyms" ]; then
                    if printf "%s" "$show_info" | grep "Synonyms: " >/dev/null 2>&1; then
                        show_synonyms="$(printf "%b" "$show_info" | grep "Synonyms: " | awk -F": " '{print $2}')"
                        show_synonyms="$anime_title_trackma, $anime_title_en, $(printf "%s" "$show_synonyms" | sed "s/[]'[]//g")"
                    fi
                fi
                # finally, play the content and hope for the best
                while true; do
                    play_episode "$anime_title" "$anime_ep" "$player_source" "$status" "$show_type" "$show_synonyms"
                    clear_lines
                    media_player_exit_code=""
                    media_player_menu
                    if [ "$media_player_exit_code" = "$PLAYER_MENU_SOURCE_SELECT_CODE" ] || [ "$media_player_exit_code" = "$PLAYER_MENU_SELECT_SEARCH_RES_CODE" ]; then
                        continue
                    elif [ "$media_player_exit_code" = "$PLAYER_MENU_END_CODE" ]; then
                        # exit player go to main menu
                        break 2
                    fi
                done
            done
            set +u nounset
            if ps "$animdl_pid" >/dev/null 2>&1; then
                kill -9 "$animdl_pid"
            fi
            set -u nounset
            ;;
        "$ADD_SHOW")
            status="Plan to Watch"
            echo && line_to_remove
            printf "      🧩 What anime do you plan to watch❔ \n         👉 " && line_to_remove
            read -r series_title
            series_title="$(printf "%s" "$series_title" | sed -E 's/[^a-zA-Z0-9 ]//g')"
            clear_lines
            if [ -z "$series_title" ]; then
                line_to_remove && clear_lines
                clear_modifiers
                continue
            fi
            results="$(printf "filter %s\nadd '%s'\n" "$(get_trackma_status_code "$status")" "$series_title" | trackma_query)"
            printf "$MSG_INFO_COLOR%s$RESET" "      🔎 Searching the anime tracker ($TRACKER_SERVICE), please wait..." && line_to_remove
            while [ -z "$(sed -En "/Choose|DataError/p" "$GLOBAL_TRACKMA_TMPFILE")" ]; do :; done
            clear_lines
            results="$(sed -En "/^[0-9]+:/p" "$GLOBAL_TRACKMA_TMPFILE")"
            [ -z "$results" ] && results="No results found.\n$TO_MAIN_MENU"
            choice="$(
                printf "%b" "$results\n$TO_MAIN_MENU" |
                    $FZF --prompt="Choose the anime to add: " \
                        --border-label "╢ ♣  ADD NEW ANIME ($status list) ♣  ╟" \
                        --header "⇅ Navigation ─ [ESC] Exit ─ [Enter] Add" \
                        --header-first
            )"
            [ -z "$results" ] && clear_modifiers && continue
            if [ "$choice" = "$TO_MAIN_MENU" ]; then
                printf "\n" >"$GLOBAL_TRACKMA_FIFO"
                clear_modifiers && continue
            fi
            choice_id=$(printf "%s" "$choice" | cut -d ':' -f1)
            printf "%b\n" "$choice_id" >"$GLOBAL_TRACKMA_FIFO"
            clear_modifiers
            ;;
        "$DELETE_SERIES")
            status=$(
                printf "%b\n%s" "$TRACKMA_STATUS_MENU_ENTRIES" "$TO_SUBMENU" |
                    $FZF -i --prompt="Choose a status: " \
                        --border-label "╢ ♣  DELETE ANIME (Status select) ♣  ╟" \
                        --header "⇅ Navigation ─ [ESC] Exit ─ [Enter] Select" \
                        --header-first
            )
            [ "$status" = "$TO_SUBMENU" ] && prompt="$TO_SUBMENU" && continue
            status=$(get_trackma_status_code "$status")
            FULL_LIST=$(printf "filter %s\nls\n" "$status" | trackma_query | sed -En "s/$TRACKMA_LIST_REGEX/\1/p" | sed "s,$(printf '\033')\\[[0-9;]*[a-zA-Z],📣 ," | sed "s,$(printf '\033')\\[[0-9;]*[a-zA-Z],,g" | sed "s,\x1B\[[0-9;]*[a-zA-Z],,g" | sed -E "/📣/ s/(.*)\.{3}(.*)/\1\2/" | sort -r --version-sort)
            [ -z "$FULL_LIST" ] && FULL_LIST="No entries found in this list..."
            FULL_LIST="$FULL_LIST\n$TO_SUBMENU\n$SWITCH_STATUS_MSG_MENU_ENTRY"
            trackma_show_index=$(
                printf "%b" "$FULL_LIST" |
                    $FZF -i --prompt="Choose an anime to DELETE: " \
                        --border-label "╢ ♣  DELETE ANIME ♣  ╟" \
                        --header "⇅ Navigation ─ [ESC] Exit ─ [Enter] Delete" \
                        --header-first | cut -d" " -f1
            )
            [ "$trackma_show_index" = "🐇" ] && prompt="$TO_SUBMENU" && continue
            [ "$trackma_show_index" = "🔄" ] && continue
            printf "filter %s\ndelete %s\ny\n" "$status" "$trackma_show_index" | trackma_query >"$TRACKMA_LOGFILE" 2>&1
            ;;
        "$UPDATE_EPISODES" | "$UPDATE_STATUS")
            if [ "$prompt" = "$UPDATE_EPISODES" ]; then
                menuitem="$TO_SUBMENU"
            else
                menuitem="$TO_MAIN_MENU"
            fi
            if [ -z "$new_status" ] && [ -z "$trackma_show_index" ]; then
                # let the user select a show
                status=$(
                    printf "%s\n%s" "$TRACKMA_STATUS_MENU_ENTRIES" "$menuitem" |
                        $FZF -i --prompt="Choose a status: " \
                            --border-label "╢ ♣  UPDATE EPISODE (Select an anime to update) ♣  ╟" \
                            --header "⇅ Navigation ─ [ESC] Exit ─ [Enter] Select" \
                            --header-first
                )
                [ "$status" = "$menuitem" ] && prompt=$menuitem && continue

                status=$(get_trackma_status_code "$status")

                res="$(printf "filter %s\nls\n" "$status" | trackma_query | sed -En "s/$TRACKMA_LIST_REGEX/\1/p" | sort -r)"
                if [ -z "$res" ]; then
                    res="This list has no items..."
                    choice="$(
                        printf "%b" "$res\n$menuitem" | $FZF -i --prompt="Choose an anime: " \
                            --border-label "╢ ♣  UPDATE EPISODE ($status list) ♣  ╟" \
                            --header "⇅ Navigation ─ [ESC] Exit ─ [Enter] Select" \
                            --header-first
                    )"
                    prompt=$menuitem && continue
                fi

                choice="$(
                    printf "%b" "$res\n$menuitem" |
                        $FZF -i --prompt="Choose an anime: " \
                            --border-label "╢ ♣  UPDATE EPISODE ($status list) ♣  ╟" \
                            --header "⇅ Navigation ─ [ESC] Exit ─ [Enter] Select" \
                            --header-first
                )"
                [ "$choice" = "$menuitem" ] && prompt=$menuitem && continue
                trackma_show_index="$(printf "%s" "$choice" | cut -d" " -f1)"
                anime_title_trackma="$(get_show_title "$choice")"

            fi
            if [ "$prompt" = "$UPDATE_EPISODES" ]; then
                echo && line_to_remove
                printf "$MSG_INFO_COLOR%s$RESET" "      How many episodes of this anime have you watched so far❔" && line_to_remove
                printf "%s" "         👉 " && line_to_remove
                read -r NEW_EPISODE_COUNT # TODO: -n4
                NEW_EPISODE_COUNT="$(printf "%s" "$NEW_EPISODE_COUNT" | sed -E 's/[^0-9]//g')"
                clear_lines
                [ -z "$NEW_EPISODE_COUNT" ] && clear_modifiers && continue
                printf "filter %s\nupdate '%s' %s\n" "$status" "$trackma_show_index" "$NEW_EPISODE_COUNT" | trackma_query >"$TRACKMA_LOGFILE" 2>&1
                # update watch history
                new_hist_content="$(sed -E "s,($(sanitize_ext_regex "$anime_title_trackma"))////.*,\1////$NEW_EPISODE_COUNT,g" "$WATCH_HISTORY_FILE" | sed -E '/^\s*$/d')"
                printf "%s\n" "$new_hist_content" >"$WATCH_HISTORY_FILE"
            else
                if [ -z "$new_status" ]; then
                    new_status=$(
                        printf "%b" "$menuitem\n$TRACKMA_STATUS_MENU_ENTRIES" |
                            $FZF -i --prompt="Choose the new status: " \
                                --border-label "╢ ♣  UPDATE EPISODE status (Select the NEW status) ♣  ╟" \
                                --header "⇅ Navigation ─ [ESC] Exit ─ [Enter] Select" \
                                --header-first
                    )
                    [ "$new_status" = "$menuitem" ] && prompt=$menuitem && clear_modifiers && continue
                    new_status="$(get_trackma_status_code "$new_status")"
                fi
                [ -n "$trackma_show_index" ] && TRACKMA_ID="$trackma_show_index" || TRACKMA_ID="$anime_title_trackma"
                printf "filter %s\nstatus '%s' %s\n" "$status" "$TRACKMA_ID" "$new_status" | trackma_query >"$TRACKMA_LOGFILE" 2>&1
            fi
            clear_modifiers
            ;;
        "$SCORE_SHOW")
            # status selection loop
            while true; do
                status=$(
                    printf "%b" "$TO_MAIN_MENU\n$TRACKMA_STATUS_MENU_ENTRIES" |
                        $FZF -i --prompt="Choose a status: " \
                            --border-label "╢ ♣  SCORE ANIME (Status select) ♣  ╟" \
                            --header "⇅ Navigation ─ [ESC] Exit ─ [Enter] Select" \
                            --header-first
                )
                status=$(get_trackma_status_code "$status")
                [ "$status" = "$TO_MAIN_MENU" ] && prompt=$TO_MAIN_MENU && clear_modifiers && break
                while true; do
                    full_info="$(printf "filter %s\nls\n" "$status" | trackma_query | sort -r | sed -En "s/$TRACKMA_LIST_REGEX/\1/p")"
                    # remove character sequences and add an emoji next to airing shows
                    full_info=$(printf '%s\n' "$full_info" | sed "s,\x1B\[[0-9;]*[a-zA-Z],,g" | sed "s,$(printf '\033')\\[[0-9;]*[a-zA-Z],📣 ," | sed "s,$(printf '\033')\\[[0-9;]*[a-zA-Z],,g" | sed -E "/📣/ s/(.*)\.{3}(.*)/\1\2/")
                    full_info="$full_info\n$TO_MAIN_MENU\n$SWITCH_STATUS_MSG_MENU_ENTRY"
                    # anime selection loop
                    anime_choice="$(
                        printf "%b" "$full_info" |
                            $FZF -i --prompt="Choose an anime: " \
                                --border-label "╢ ♣  SCORE ANIME ($status) ♣  ╟" \
                                --header "⇅ Navigation ─ [ESC] Exit ─ [Enter] Select" \
                                --header-first
                    )"
                    [ "$anime_choice" = "$TO_MAIN_MENU" ] && clear_modifiers && break 2
                    [ "$anime_choice" = "$SWITCH_STATUS_MSG_MENU_ENTRY" ] && break
                    anime_choice_id="$(printf "%s" "$anime_choice" | cut -d" " -f1)"
                    anime_choice_name=$(get_show_title "$anime_choice")
                    SCORE_MENU="(10) Masterpiece\n(9) Great\n(8) Very Good\n(7) Good\n(6) Fine\n(5) Average\n(4) Bad\n(3) Very Bad\n(2) Horrible\n(1) Appalling"
                    score=$(
                        printf "%b" "$SCORE_MENU" | $FZF -i --prompt="Select a score: " \
                            --border-label "╢ ♣  SCORING ANIME: $(trim "$anime_choice_name") ♣  ╟" \
                            --header "⇅ Navigation ─ [ESC] Exit ─ [Enter] Select" \
                            --pointer 🌟 \
                            --header-first | sed -En "s/\(([[:digit:]]+)\).*/\1/p"
                    )
                    clear_lines
                    printf "filter %s\nscore %s %s\n" "$status" "$anime_choice_id" "$score" | trackma_query >/dev/null 2>&1
                done
            done
            ;;
        "$SET_ALTNAME")
            status=$(
                printf "$TRACKMA_STATUS_MENU_ENTRIES\n%s" "$TO_SUBMENU" |
                    $FZF -i --prompt="Choose a status: " \
                        --border-label "╢ ♣  SET ALTERNATIVE NAME (Status select) ♣  ╟" \
                        --header "⇅ Navigation ─ [ESC] Exit ─ [Enter] Select" \
                        --header-first
            )

            [ "$status" = "$TO_SUBMENU" ] && prompt=$TO_SUBMENU && continue

            while true; do
                full_info="$(printf "filter %s\nls\n" "$status" | trackma_query | sort -r | sed -En "s/$TRACKMA_LIST_REGEX/\1/p")"
                full_info=$(printf '%s\n' "$full_info" | sed "s,\x1B\[[0-9;]*[a-zA-Z],,g" | sed "s,$(printf '\033')\\[[0-9;]*[a-zA-Z],📣 ," | sed "s,$(printf '\033')\\[[0-9;]*[a-zA-Z],,g" | sed -E "/📣/ s/(.*)\.{3}(.*)/\1\2/")
                full_info="$full_info\n$TO_SUBMENU\n$SWITCH_STATUS_MSG_MENU_ENTRY"
                trackma_show_index="$(
                    printf "%b" "$full_info" |
                        $FZF -i --prompt="Choose an anime: " \
                            --border-label "╢ ♣  SET ALTERNATIVE NAME ($status list) ♣  ╟" \
                            --header "⇅ Navigation ─ [ESC] Exit ─ [Enter] Select" \
                            --header-first
                )"
                [ "$trackma_show_index" = "$TO_SUBMENU" ] && prompt=$TO_SUBMENU && break
                [ "$trackma_show_index" = "$SWITCH_STATUS_MSG_MENU_ENTRY" ] && break
                trackma_show_index=$(printf "%s" "$trackma_show_index" | cut -d" " -f1)
                printf "%b" "
                 ℹ  What is the altname❔ "
                read -r NEWNAME
                printf "altname %s '%s'\n" "$trackma_show_index" "$NEWNAME" | trackma_query >"$TRACKMA_LOGFILE" 2>&1
            done
            clear_modifiers
            ;;
        "$PULL")
            sel=$(
                printf "🔄 Overwrite local lists\n%s" "$TO_MAIN_MENU" |
                    $FZF -i --prompt="Choose an option: " \
                        --border-label "╢ ♣  $PULL ♣  ╟" \
                        --header "⇅ Navigation ─ [ESC] Exit ─ [Enter] Select" \
                        --header-first | cut -d" " -f1
            )
            [ "$sel" = "$TO_MAIN_MENU" ] && prompt=$TO_MAIN_MENU && continue
            [ "$sel" = "🔄" ] &&
                printf "retrieve\n" | trackma_query >/dev/null 2>&1
            clear_modifiers
            ;;
        "$PUSH")
            sel=$(
                printf "🔄 Overwrite remote lists\n%s" "$TO_MAIN_MENU" |
                    $FZF -i --prompt="Choose an option: " \
                        --border-label "╢ ♣  $PUSH ♣  ╟" \
                        --header "⇅ Navigation ─ [ESC] Exit ─ [Enter] Select" \
                        --header-first | cut -d" " -f1
            )
            [ "$sel" = "$TO_MAIN_MENU" ] && clear_modifiers && continue
            [ "$sel" = "🔄" ] &&
                printf "send\n" | trackma_query >/dev/null 2>&1
            clear_modifiers
            ;;
        "$LIST_AIRING")
            sort_airing=1
            prompt=$LIST
            ;;
        "$LIST_BY_SCORE")
            sort_score=1
            prompt=$LIST
            ;;
        "$LIST")
            status=$(
                printf "%s\n%s" "$TRACKMA_STATUS_MENU_ENTRIES" "$TO_MAIN_MENU" |
                    $FZF -i --prompt="Choose a status: " \
                        --border-label " ♣  LIST$(
                            if [ "$sort_score" -eq 1 ]; then
                                printf ' BY SCORE 🌟'
                            elif [ "$sort_airing" -eq 1 ]; then
                                printf ' AIRING SHOWS 📣'
                            else
                                printf " SHOWS"
                            fi
                        ) (Status select) ♣  " \
                        --header "⇅ Navigation ─ [ESC] Exit ─ [Enter] Select" \
                        --header-first
            )
            [ "$status" = "$TO_MAIN_MENU" ] && prompt=$TO_MAIN_MENU && continue

            status=$(get_trackma_status_code "$status")

            if [ "$sort_score" -eq 1 ]; then
                # sort by score
                msg="$(printf "filter %s\nsort my_score\nls\n" "$status" | trackma_query)"
                msg="$(filter_trackma_list "$msg" | sort -r)"
            else
                msg="$(printf "filter %s\nls\n" "$status" | trackma_query)"
                msg="$(filter_trackma_list "$msg" | sort -r --version-sort)"
            fi
            # remove character sequences and add an emoji next to airing shows
            msg=$(printf "%s\n" "$msg" | sed "s,$(printf '\033')\\[[0-9;]*[a-zA-Z],📣 ," | sed "s,$(printf '\033')\\[[0-9;]*[a-zA-Z],,g" | sed -E "/📣/ s/(.*)\.{3}(.*)/\1\2/" | sed "s,\x1B\[[0-9;]*[a-zA-Z],,g")

            if [ "$sort_airing" -eq 1 ]; then
                # filter airing show per user request
                msg=$(printf "%s" "$msg" | sed -n "/📣/p")
            fi

            if [ ! "$msg" ]; then
                msg="This list has no items... "
                sel=$(
                    printf "%s\n%s\n%s" "$msg" "$TO_MAIN_MENU" "$SWITCH_STATUS_MSG_MENU_ENTRY" |
                        $FZF -i --border-label " ♣  LIST$(
                            if [ "$sort_score" -eq 1 ]; then
                                printf ' BY SCORE 🌟'
                            elif [ "$sort_airing" -eq 1 ]; then
                                printf ' AIRING SHOWS 📣'
                            else
                                printf " SHOWS"
                            fi
                        ) ($status list) ♣  " \
                            --header "⇅ Navigation - [Enter] Go back" \
                            --prompt ""
                )
                [ "$sel" = "$TO_MAIN_MENU" ] && prompt="$TO_MAIN_MENU" && continue
                continue
            fi

            export status
            while true; do
                FZF_PREVIEW_WINDOW_CMD="TRACKMA_LIST_REGEX=\"$TRACKMA_LIST_REGEX\"; TRACKMA_ENTRY_REGEX=\"$TRACKMA_ENTRY_REGEX\"; GLOBAL_TRACKMA_FIFO=$GLOBAL_TRACKMA_FIFO; GLOBAL_TRACKMA_TMPFILE=$GLOBAL_TRACKMA_TMPFILE; $trackma_query_function_code; $sanitize_ext_regex_function_code; $get_show_title_function_code; $get_trackma_status_code_function_code; $get_show_info_function_code; $filter_trackma_list_function_code; $get_entry_index_function_code; get_show_info {} $status | bat --style=plain --color=always --language=yaml"

                sel=$(
                    printf "%s\n%s\n%s" "$msg" "$TO_MAIN_MENU" "$SWITCH_STATUS_MSG_MENU_ENTRY" |
                        $FZF -i --bind "ctrl-l:toggle-preview" --preview "$FZF_PREVIEW_WINDOW_CMD" \
                            --preview-window "$PREVIEW_WINDOW_OPTS" \
                            --bind "shift-right:change-preview-window($MENU_PREVIEW_POS_MODES)+preview:$FZF_PREVIEW_WINDOW_CMD" \
                            --preview-label ' Info ' \
                            --border-label " ♣  LIST$(
                                if [ "$sort_score" -eq 1 ]; then
                                    printf ' BY SCORE 🌟'
                                elif [ "$sort_airing" -eq 1 ]; then
                                    printf ' AIRING SHOWS 📣'
                                else
                                    printf " SHOWS"
                                fi
                            ) ($status list) ♣  " \
                            --header "⇅ Navigation - [Ctrl-L] Toggle info - [ESC] Exit - [Enter] Play ▸" \
                            --prompt "Choose an anime: "
                )
                [ "$sel" = "$TO_MAIN_MENU" ] && clear_modifiers && break
                [ "$sel" = "$SWITCH_STATUS_MSG_MENU_ENTRY" ] && break
                anime_title_trackma=$(get_show_title "$sel")
                last_show_episode="$(get_last_show_ep "$anime_title_trackma")"
                [ -z "$last_show_episode" ] && printf "Couldn't get last show episode" && exit 1
                last_watched_ep="$(printf "%s" "$sel" | sed -En "s/$TRACKMA_ENTRY_REGEX/\4/p")"
                # only increment if it's not the last episode of the show
                # if we don't know the last aired apisode just attempt playing the next episode
                # last_show_episode can be a string or integer
                if [ "$last_show_episode" = "?" ]; then
                    anime_ep=$((last_watched_ep + 1))
                elif [ "$last_watched_ep" -lt "$last_show_episode" ]; then
                    anime_ep=$((last_watched_ep + 1))
                else
                    anime_ep="1"
                fi
                trackma_index="$(printf "%s" "$sel" | sed -En "s/$TRACKMA_ENTRY_REGEX/\1/p")"
                prompt="$WATCH"
                break
            done
            ;;
        esac
    done
}

incognito_menu() {
    INCOGNITO_MENU_HELPTEXT="
👤  Switch Incognito Mode off.
───
💡  Stream with animdl. You will need to type a search query and episode number. This option uses streaming for playing content.
───
😺  Search Nyaa Torrents. You will need to type a search query, type and episode number and select a search result to play it. This option uses torrenting for playing content.
"
    INCOGNITO_MENU_ENTRIES="$PLAY_METHOD_TORRENTING\n$PLAY_METHOD_STREAMING\n$EXIT_INCOGNITO_MODE"
    MAINMENU_TITLE="MAIN MENU"
    menu_entries=$INCOGNITO_MENU_ENTRIES
    menu_title=$MAINMENU_TITLE
    menu_help_text=$INCOGNITO_MENU_HELPTEXT
    prompt=""
    while true; do
        if [ -z "$prompt" ]; then
            FZF_PREVIEW_WINDOW_CMD="printf \"%s\n\" \"$menu_help_text\""
            clear_modifiers
            prompt=$(
                printf "%b" "$menu_entries" |
                    $FZF -i --prompt="Choose an action: " \
                        --border-label "╢ ♣  $menu_title ♣  ╟" \
                        --header "⇅ Navigation ─ [ESC] Exit ─ [Ctrl-L] Help ─ [Enter] Select" \
                        --header-first \
                        --preview-window "$PREVIEW_WINDOW_OPTS" \
                        --bind "shift-right:change-preview-window($MENU_PREVIEW_POS_MODES)+preview:$FZF_PREVIEW_WINDOW_CMD" \
                        --preview "$FZF_PREVIEW_WINDOW_CMD" \
                        --bind "ctrl-l:toggle-preview" \
                        --preview-label " Help "
            )
        fi
        case $prompt in
        "$PLAY_METHOD_TORRENTING")
            player_source="torrenting"
            incognito_play_msg_emoji="😺"
            prompt="PLAY"
            ;;
        "$PLAY_METHOD_STREAMING")
            player_source="streaming"
            incognito_play_msg_emoji="💡"
            prompt="PLAY"
            ;;
        "PLAY")
            echo && line_to_remove
            printf "$MSG_INFO_COLOR      %s What anime do you want to watch❔$RESET" "$incognito_play_msg_emoji" && line_to_remove
            printf "         👉 " && line_to_remove
            read -r anime_title
            clear_lines
            [ -z "$anime_title" ] && clear_modifiers && continue
            anime_title="$(printf "%s" "$anime_title" | sed -E 's/[^a-zA-Z0-9 ]//g' | sed "s/[[:space:]]*$//g" | sed "s/^[[:space:]]*//g")"
            echo && line_to_remove
            printf "      %s Enter an episode number if applicable\n" "$incognito_play_msg_emoji" && line_to_remove
            printf "         👉 " && line_to_remove
            read -r anime_ep
            clear_lines
            anime_ep="$(printf "%s" "$anime_ep" | sed -E 's/[^0-9]//g')"
            if [ -z "$anime_ep" ]; then
                anime_ep=1
                show_type="movie"
            else
                show_type="tv"
            fi
            last_show_episode=0
            while true; do
                play_episode "$anime_title" "$anime_ep" "$player_source" "" "$show_type" ""
                clear_lines
                media_player_exit_code=""
                media_player_menu
                if [ "$media_player_exit_code" = "$PLAYER_MENU_SOURCE_SELECT_CODE" ] || [ "$media_player_exit_code" = "$PLAYER_MENU_SELECT_SEARCH_RES_CODE" ]; then
                    continue
                elif [ "$media_player_exit_code" = "$PLAYER_MENU_END_CODE" ]; then
                    # exit player go to main menu
                    break
                fi
            done
            ;;
        "$EXIT_INCOGNITO_MODE")
            INCOGNITO_MODE=0
            line_to_remove # remove incognito label
            clear_lines    # remove incognito label
            break
            ;;
        esac
    done
}

if [ "$OSTYPE" = "Darwin" ]; then
    MEDIA_PLAYER="iina"
else
    MEDIA_PLAYER="mpv"
fi

export BACK_MSG
export TO_MAIN_MENU
export SWITCH_STATUS_MSG_MENU_ENTRY
export TRACKMA_ENTRY_REGEX
export TRACKMA_LOGFILE

# fzf colors
export FZF_DEFAULT_OPTS='--color=fg:#ffffff,bg:-1,hl:#ba9c41 --color=fg+:#ffbf00,bg+:#262626,hl+:#5fd7ff --color=info:#ffffff,prompt:#ffbf00,pointer:#af5fff --color=marker:#87ff00,spinner:#af5fff,header:#d7005f --color=label:#ffbf00'

# regex for extracting trackma results
# gets the whole series list
TRACKMA_LIST_REGEX="^\|[[:space:]]+([0-9]+[[:space:]]+.*[0-9]+[[:space:]]+\/[[:space:]]+[0-9?]+[[:space:]]+[0-9]+).*\|$"
# gets the multiple parts of an entry, by matching groups
#	1- list index
#	2- series title
#	3- unused
#	4- last watched ep
#	5- end episode
#	6- series score
# Caveat: removing possesive quantifier makes the \2 match to end
# with a residual dot, we will have to remove it with sed.
# We also have no way of making a distinction between series that
# actually end with a dot from a residual dot.
TRACKMA_ENTRY_REGEX="^([[:digit:]]+)[[:space:]]+(([^.]*|.*))\.*[[:space:]]+([[:digit:]]+)[[:space:]]\/[[:space:]]([[:digit:]]+|\?)[[:space:]]+([[:digit:]]+)$"

# mainmenu entries
WATCH_HISTORY="👁️  Watch History"
WATCH="📺 Watch"
WATCH_RANDOM="🔀 Watch Random"
ADD_SHOW="🧩 Add Anime"
LIST="📙 Lists"
UPDATE_STATUS="🔄 Update Anime Status"
SCORE_SHOW="👍 Score Anime"
EXIT_INCOGNITO_MODE="👤 Exit Incognito Mode"
ENTER_INCOGNITO_MODE="🕵️  Enter Incognito Mode"
TO_SUBMENU="🐇 SUBMENU ▸"
# submenu entries
SWITCH_ACCOUNTS="Switch Accounts 👤"
DELETE_SERIES="Delete Anime 🗑️"
WATCH_RAND_AIRING="Watch Random Anime (Currently Airing 📣)"
LIST_AIRING="List Anime (Currently Airing 📣)"
UPDATE_EPISODES="Update Anime Episodes 🔄"
SET_ALTNAME="Set Alternative Name 📝"
PULL="Pull Lists from Remote ↓"
PUSH="Push Local Lists to Remote ↑"
LIST_BY_SCORE="List Anime (Sort by Rating 🌟)"
TO_MAIN_MENU="◂ MAINMENU"
SWITCH_STATUS_MSG_MENU_ENTRY="🔄 SWITCH STATUS"
# used in account_menu, incognito_menu
PLAY_METHOD_TORRENTING="😺 Search Nyaa Torrents (torrenting)"
PLAY_METHOD_STREAMING="💡 Stream with animdl (streaming)"
PLAY_METHOD_MAGNET="🧲 Paste a magnet link (torrenting)"
PLAY_METHOD_MENU="$PLAY_METHOD_TORRENTING\n$PLAY_METHOD_MAGNET\n$PLAY_METHOD_STREAMING\n$TO_MAIN_MENU"
# used in media_player_menu
PLAYER_MENU_SOURCE_SELECT_CODE=0
PLAYER_MENU_END_CODE=1
PLAYER_MENU_SELECT_SEARCH_RES_CODE=2

main() {
    check_setup
    # common fzf args
    PREVIEW_WINDOW_OPTS="right,70%,hidden,wrap"
    MENU_PREVIEW_POS_MODES="down,70%|left,70%|top,70%|"
    if [ "$MINIMAL" -eq 1 ]; then
        # initial preview options
        FZF="fzf -0 --ansi --cycle --ellipsis (...) --color dark --pointer > --border-label-pos 1 --reverse --border top --layout=reverse --info inline --no-separator --bind change:first"
    else
        FZF="fzf -0 --ansi --cycle --ellipsis (...) --height 70% --border rounded --pointer 👉 --margin 5% --padding=1,0,0,0 --border-label-pos -1 --bind change:first"
    fi
    paint_logo
    while true; do
        if [ "$INCOGNITO_MODE" -eq 0 ]; then
            spawn_trackma
            check_trackma_config
        fi
        if [ "$INCOGNITO_MODE" -eq 0 ]; then
            [ "$MINIMAL" -eq 0 ] && print_account
            account_menu
        else
            [ "$MINIMAL" -eq 0 ] && print_incognito_msg
            incognito_menu
        fi
    done
}
main
trap - 1 2 3 15

#!/bin/sh
# shellcheck disable=SC2016,SC2034
set -o errexit
set -o nounset

#*********************************
#* ANIME MANAGER - Watch and sync anime from your terminal.
# Project repository: https://github.com/anma-dev/Anime-Manager
# LICENSE: GNU GPL 3.0
VERSION="v0.5.3-alpha"
#*********************************

#*********************************
#* UTILITY FUNCTIONS
#*********************************

#*********************************
#* GENERAL UTILITIES
#*********************************

# Empties the watch history file
delete_watch_history() {
    printf "" >"$WATCH_HISTORY_FILE"
}

# Internet connectivity check with random selection of hosts
connectivity_check() {
    connectivity_check_tmout=3
    urls=$(array "ubuntu.com" "google.com" "duckduckgo.com" "bing.com")
    urls_len=$(printf '%s\n' "$urls" | array_len | sed "s/[[:space:]]//g")
    rand_id=$(shuf -i 0-"$((urls_len - 1))" -n 1)
    rand_url=$(printf '%s\n' "$urls" | array_nth "$rand_id")
    if [ "$OSTYPE" = "Darwin" ]; then
        if printf "%b" "GET https://$rand_url HTTP/1.0\n\n" | nc -G $connectivity_check_tmout "$rand_url" 443 >/dev/null 2>&1; then
            true
        else
            false
        fi
    elif [ "$OSTYPE" = "Linux" ]; then
        if printf "%b" "GET https://$rand_url HTTP/1.0\n\n" | timeout $connectivity_check_tmout nc "$rand_url" 443 >/dev/null 2>&1; then
            true
        else
            false
        fi
    fi
}

#! Unused
torrent_is_playing() {
    process_name="$(ps -p "$webtorrentpid" -o comm=)"
    if [ "$process_name" = "WebTorrent" ]; then
        true
    else
        false
    fi
}

# get the shell configuration file path
get_shell_config_file() {
    get_shell_config_file_cfg_file=""
    if [ "$SHELL" = "/bin/bash" ]; then
        [ "$OSTYPE" = "Linux" ] && touch "$HOME/.bashrc" && get_shell_config_file_cfg_file="$HOME/.bashrc"
        [ "$OSTYPE" = "Darwin" ] && touch "$HOME/.bash_profile" && get_shell_config_file_cfg_file="$HOME/.bash_profile"
    fi
    # nvm on macos needs the shell config file
    [ "$SHELL" = "/bin/zsh" ] && touch "$HOME/.zshrc" && get_shell_config_file_cfg_file="$HOME/.zshrc"
    printf "%s" "$get_shell_config_file_cfg_file"
}

# Clear all modifiers. A 'modifier' for us is a flow control variable for the
# menu navigation
clear_modifiers() {
    random_anime=0
    random_airing=0
    prompt=""
    sort_airing=0
    sort_score=0
    anime_title=""
    entry_index=""
    cur_anime_episode=""
    status=""
    new_status=""
    last_watched_ep=""
    nyaa_search_res=""
    play_status=$PLAY_STATUS_WAITING
    # do not clear player source when in playlist mode
    [ "$playlist_mode" -eq 0 ] && player_source=""
    magnet_link=""
    play_method_menu_opt=""
    debug_match_info=""
    file_list=""
    file_index=""
    animdl_playthrough=0
    animdl_search_index=1
    nyaa_search_ret_code=""
    watch_choice=""
    list_choice=""
    media_player_helper=""
}

reset_logs() {
    echo >"$WEBTORRENT_LOGFILE"
    echo >"$TRACKMA_LOGFILE"
    echo >"$ANIMDL_LOGFILE"
    # echo > "$CURRENTLY_PLAYING_LOGFILE"
    echo >"$NYAA_SEARCH_LOGFILE"
    echo >"$NYAA_FE_LOGFILE"
}

# returns a substring of a string
# starting from the beginning
start_substring() {
    cut_string_string="$1"
    cut_string_end_id="$2"
    printf "%s" "$cut_string_string" | cut -c1-"$cut_string_end_id"
}

get_playback_time() {
    case "$MEDIA_PLAYER_APP" in
    "vlc")
        playback_time="$(printf "get_time\n" | $netcat_comm "$MEDIA_PLAYER_VLC_SOCKET" 2>/dev/null)"
        ;;
    "mpv")
        playback_time=$(printf '{ "command": ["get_property", "playback-time"] }\n' | $netcat_comm "$MEDIA_PLAYER_MPV_SOCKET" 2>/dev/null)
        ;;
    "iina")
        playback_time=$(printf '{ "command": ["get_property", "playback-time"] }\n' | $netcat_comm "$MEDIA_PLAYER_IINA_SOCKET" 2>/dev/null)
        ;;
    esac
}

get_video_length() {
    case "$MEDIA_PLAYER_APP" in
    "vlc")
        playback_length="$(printf "get_length\n" | $netcat_comm "$MEDIA_PLAYER_VLC_SOCKET" 2>/dev/null)"
        ;;
    "mpv")
        playback_length=$(printf '{ "command": ["get_property", "duration"] }\n' | $netcat_comm "$MEDIA_PLAYER_MPV_SOCKET" 2>/dev/null)
        ;;
    "iina")
        playback_length=$(printf '{ "command": ["get_property", "duration"] }\n' | $netcat_comm "$MEDIA_PLAYER_IINA_SOCKET" 2>/dev/null)
        ;;
    esac
}

# approximate*
get_playback_percent() {
    case "$MEDIA_PLAYER_APP" in
    "vlc")
        get_video_length
        get_playback_time
        cur_playback_percent=$((playback_time * 100 / playback_length))
        ;;
    "mpv")
        cur_playback_percent=$(printf '{ "command": ["get_property", "percent-pos"] }\n' | $netcat_comm "$MEDIA_PLAYER_MPV_SOCKET" 2>/dev/null | jq --raw-output '.data' | cut -d. -f1)
        ;;
    "iina")
        cur_playback_percent=$(printf '{ "command": ["get_property", "percent-pos"] }\n' | $netcat_comm "$MEDIA_PLAYER_IINA_SOCKET" 2>/dev/null | jq --raw-output '.data' | cut -d. -f1)
        ;;
    esac
    if [ -z "$cur_playback_percent" ] || [ -n "$(printf "%s" "$cur_playback_percent" | sed -n "/null/p")" ]; then
        cur_playback_percent=0
    fi
}

# trim long show titles
trim() {
    MAX_MENU_TITLE_SERIES_LEN=20
    title="$1"
    c_count=$(printf "%s" "$title" | wc -c | sed "s/ //g")
    if [ "$c_count" -gt $MAX_MENU_TITLE_SERIES_LEN ]; then
        printf "%s" "$title" | cut -c 1-"$MAX_MENU_TITLE_SERIES_LEN" | sed "s/$/(...)/"
    else
        printf "%s" "$title"
    fi
}

line_to_remove() {
    lines_to_remove="$((lines_to_remove + 1))"
}

# sanitizes a string to be used in an extended regular expression
# used for updating watch history file
sanitize_ext_regex_function_code='sanitize_ext_regex() {
    printf "%s" "$1" |
        sed "s,$(printf "\033")\\[[0-9;]*[a-zA-Z],," |
        sed "s,$(printf "\033")\\[[0-9;]*[a-zA-Z],,g" |
        sed "s,\033\[[0-9;]*[a-zA-Z],,g" |
        sed "s/[]\/\$*.^+()\"['"'"'-]/\\\&/g" |
        sed "s/ $//"
}'
eval "$sanitize_ext_regex_function_code"

# clear n number of lines from output
# caveat: wrapped lines
clear_lines() {
    if [ "$DEBUG" -eq 0 ]; then
        while [ "$lines_to_remove" -gt 0 ]; do
            printf "%b" "${OVERWRITE}"
            lines_to_remove=$((lines_to_remove - 1))
        done
    fi
}

sanitize_bash() {
    printf "%s" "$1" | LC_ALL=C sed -e 's/[^a-zA-Z0-9,._+@%/-]/\\&/g; 1{$s/^$/""/}; 1!s/^/"/; $!s/$/"/'
}

getcwd() {
    printf "%s" "$(lsof -p "$$" | grep cwd | awk '{print $9}')"
}

# Create a safe temporary filename in a posix-compliant way
get_temp_filename() {
    {
        posix_mktemp_file_file=$(
            (mktemp -u "$TMP_PATH/anmaXXXXXXXX") 2>/dev/null
        )
    } || {
        posix_mktemp_file_file=$TMP_PATH/anma$$-$(awk 'BEGIN { srand(); print int(rand()*32768) }' /dev/null)
    } || exit $?
    printf "%s" "$posix_mktemp_file_file"
}

get_xxhash() {
    hash_input="$1"
    hash_title_hash="$(printf "%s" "$hash_input" | xxh128sum | sed "s/[[:space:]]*stdin//g")"
    printf "%s" "$hash_title_hash"
}

# Prints the account currently in use by Trackma
print_account() {
    clear_lines
    printf "$SUBTITLE_COLOR%s$RESET" "      👤 ${USERNAME}"
}

# Prints a message to inform the user that they are in incognito mode
print_incognito_msg() {
    clear_lines
    printf "      "
    printf "$INCOGNITO_MODE_COLORS%s$RESET" "🕵  INCOGNITO MODE"
}

print_subheader() {
    if [ "$INCOGNITO_MODE" -eq 1 ]; then
        print_incognito_msg
    else
        print_account
    fi
    printf " │"
    if [ "$playlist_mode" -eq 1 ]; then
        printf "%b" " ${MSG_WARN_COLOR}AUTO UPDATE ON${RESET} │"
        printf "%b" " ${MSG_HELP_COLOR}🎦 PLAYLIST MODE${RESET} │"
    elif [ "$AUTO_UPDATE" -eq 1 ]; then
        printf "%b" " ${MSG_WARN_COLOR}AUTO UPDATE ON${RESET} │"
    fi
    printf "\n"
}

# Print the application logo.
# The logos are compressed for efficiency.
paint_logo() {
    # print the logos
    LOGO_B64=$LOGO_DEFAULT_B64
    # special dates
    if [ "$DATE_MONTH" -eq 10 ] && [ "$DATE_DAY" -eq 31 ]; then
        LOGO_B64=$LOGO_HALLOWEEN_B64
    fi
    if [ "$DATE_MONTH" -eq 12 ]; then
        if [ "$DATE_DAY" -eq 24 ] || [ "$DATE_DAY" -eq 25 ]; then
            LOGO_B64=$LOGO_XMAS_B64
        fi
    fi
    [ "$MONOCHROME_LOGO" -eq 1 ] && LOGO_B64=$LOGO_MONOCHROME
    if [ "$DEBUG" -eq 0 ]; then
        tput clear
        printf "%b\n" "$(
            base64 -d <<EOF | gunzip
$LOGO_B64
EOF
        )"
    fi
    printf "$TITLE_COLOR%s$RESET\n" "      🍿 Watch and Sync Anime from Your Terminal"
    printf "$MSG_HELP_COLOR%s$RESET\n" "         Use arrow keys/mouse scroll to navigate. Type to filter results" && echo

}

#*********************************
#* INITIALIZATION
# Defaults, set environment variables, parse arguments, imports, etc
#*********************************

# Override locale categories
eval export "$(locale)"
unset LC_ALL
LANG="C"
LC_ALL="C"
LC_COLLATE="C"
LC_CTYPE="C"
LC_MESSAGES="C"
LC_MONETARY="C"
LC_NUMERIC="C"
LC_TIME="C"
LC_ADDRESS="C"
LC_IDENTIFICATION="C"
LC_MEASUREMENT="C"
LC_NAME="C"
LC_PAPER="C"
LC_TELEPHONE="C"
LANGUAGE="en_US.UTF-8"
export LANG LC_ALL \
    LC_COLLATE \
    LC_CTYPE \
    LC_MESSAGES \
    LC_MONETARY \
    LC_NUMERIC \
    LC_TIME \
    LANGUAGE \
    LC_ADDRESS \
    LC_IDENTIFICATION \
    LC_MEASUREMENT \
    LC_NAME \
    LC_PAPER \
    LC_TELEPHONE \
    LANGUAGE

#* IMPORTS
. ./lib/array

#* DEFAULTS
LOGO_MONOCHROME="H4sIABqJ4GMAA+NSAINH0zoeTWsAow5kTguQMxHMmggXbkFXpvC4oQG3LBYTscs0IJmIrIYLyYktYATVNhGMQJwGiHq4cANcBsOJ6LI4TMQig+ZpJDUNcCc2wMxowMJpQBNGk4E4EYsskRwUG1DsAnPKDPRM9Yx1E3MKMhIBoQHlpvYBAAA="
LOGO_DEFAULT_B64="H4sIABuJ4GMAA8XWvW7cMAwA4L2vkEUv0EIS9WOBD9KhU1EU6BAjHYrOHjJkvSVTH6DPlb5IqfOdTZFyfElz6HC5yweSkixa9s0nGNCjj/H4seO7GynmxeJeLR+VfOUSMsmtki9K7pSMStrKXs7nKD+U3F2Q1Qj9+p8Srib2WuJVR11RVB9eT1y+msC1xKqOuqKoHvsHefr1W1lztlnVd28krqSuPD0+dGy60Npc2Vuz9KJktW27f36EIR+jDh2bLorrVXvYrQZ6bifrxT0oM3tRuehqm2aU/Jn2okJnzNCpH/RKn4lr66kePEovSlbbtleMkDr9+4zdKzOdqHYE36m2bTrX7EXFThe+yEwnqh2h07+bZjpRr68mckMRp+Is5g1EPmm3RM4o6s7oWqf7gurRzShxPvUMEjqZCxl9OwL9CvJK07tSVJkRk4qLmEU1j4PK9FjU3ACd2uCKTkVadF6VJAQxMlGQcT5T28hhNjG1FX2gM0Iej74ewiLuSHJkR48guRZP32rVZ1SRavNcoZeyduyZ5NiWXkplv7lE7/Zb2A5DPRLFMFBJxgX0SU58E7NKdxWNJHUlHX0XNfEe2oKg7pYZzX5cQlDNd8ZJorrmFioaSdCLg6YidRm920FQaCuahhxCuw2w4v0elgGhvYXPth6gdKvSXPi2XCIOS0QYWnFKPEJhYk/CZ7TagdlQMDS3CB3XZ5uUGS4JQ7OBYVjssGcZg29yM9L7V2DbXCVgABnlpCUcbMcojm3xIjyKjthhtoOwuGsBc5xt4kZrZUddgJPwqA3z0jxmuiKsF6rYKuzcXGyNcphppUNTa7V1BRZT7hittEiLsy31oJzMcAGMTdfQ37MdLrQ1N2OyGB0b4Sw8Ki12YBYHjL6xuNjELVYzSngUPa5pbtBU6xksNnHz7Qj0r8PYdGE1KzNpswpNRtogc8kyRtZx9KimVheZZFFkerqdQ80UBjV3qeapGWh6uYkic3Pmsnp6woOcb7VB5tLx3s63St2w8ecidNzFmme5BNro8cMidEhCzYpcXM1aY+hpQNe1jMCElkhZ77nUtho/L0KfVLNuudT2Gb8vQo9SqDHfuPgas9ah9wRbK/8FWoqfTkQVAAA="
LOGO_XMAS_B64="H4sIABuJ4GMAA8XYvW4TQRAH8D6vkOZ4AKL93jvNM1CDRIVQJIpYQYCQ6Fy4cIGQ3ND63eAF8gj812efd2bW8SUkUCRBP83M7t7N7a64fOt7cuRi3P2YxcWllO7BYh8tr5Vc1xIy5EbJeyW3ShZKeGUn57OTL0puZ2Qxwb/+p4RnE/Nc4lRHPZmorvuXYvOj5W77Y3UmzENeKblW8mmGfKvFqKbayRslCyXvlHxmUprqhZJOyd32+1bhxYxELqrT/kJ+/VxXZoe0s+VM07ndrChZzZ60lbKuEbU5V63POq6XzXeIWjesVW11Ns436nk16qmodjVmeZDVdvJ7OSdKjLk3nhn0SvfWilsr685GmUa106Zzu1lRM0ZISa81qZ5OjZ5OjZ5ummvkypP2dFS7GrPY6MKo+jw2+vxkpjTVv7HRv7HRq/eYzq13RRtU/z6ZyLN1FDGjva1mGs9VPRoaPbq3zUxjuT6R5SP4TE4+aZhXmT0FFRcoimqRksqMlOXcvKNeVXM0qDhP1qqChqwT44L0lPfIRnF4AmohLqOVeMVCSW6OLmA7EHFlt5UjH5CtBbcjO6iR8Ve9uQOuJYp3ZwfcuWTcAVm3OYNbp0SbcHlX6Tvkw6BFoorzI7KJ20AuncK1RPEkrS0k44C9mngT8XeQ6biAAdkwZiCvHu4B2cRNIm/lCzvgWqLoSOMLyTig6kiN6DJc5Xz9GgqZQnXFgpZ8ZI/Ct3HIoy1r68mnavs8yHFYfJKYSH6gWBoi+Z6LVeLI8+/BTLY5Y/1AgR0Q2K5H6yoZDAUro9JoU7XQty1TYBtjMV/sOELeSx0FCxS8NCstUW+KdbUgKoio3I92nFs8aex7DGGyZW2xWFcLVp9YlJ9vWH/15oPbS7VvFjM8ylLGStkBUNmmspSlmbZhpayX/EApFuuUiChPkX35+H2fHXMzJUOx2pInqaPSZJvKcFvS1lNkvYSDc7SuliijcAgj2bNqMC/NT7aszfERIJYi60IczPjkRKbDo8RkmJUXKHNhWGu1p+BURluLTFgUmQ6fc1maNF9yp2oOLx7TyywKZsfMafU4ztEmohq2xF7mYifn8y1SXs7iay2x5JlJsN0FvOjFVS2Y6bCIk2CTtCXrqhZTYvwkOFSHMtbLWvpSefp/hXIPSCXrppbSKouPk+CA3I3+oRZXYo51cCUwpfIfX4h68xAVAAA="
LOGO_HALLOWEEN_B64="H4sIAByJ4GMAA8XYsW4UMRAA0D6/kGb5ACLbY3u9mh/gDyioEIpEkSMUCER3EldchXQNbT6Ev4EfyCcws3u355nx5TaQiAISPc2M7d1Z28rlGygYMKQ0/nOri0st3aPF/7W8NnJdS+xJboy8M3JrZGVEVg56PqN8MnK7IEsI/fY/JT6buOeSYDrqycR03ZPK/d33bw+HeW68V0beGvm4QL4KATMWmLHAjAX6g7Liim77Ub4YuV4gH4RwU70w0hm5v9v9NHixIFGK6bR/kF8/tpX5IY+2Xmg2t1sUpav5k7Yx1jWidueqld7GjdY1orYNa1XbnI2DRj3d4Kej2tWE9YOuNsrv9ZIoNebeZGa0K91bK25rrDsb5RrVTpvN7RZFLRghZ7vWbHo6N3o6N3q6aaGRq0/a01HtasJSowuT6fPU6POTmdpM/6ZG/6ZGrz5gNrfeFX00/ftkos/WSdSM9rZZaDLX9Ghs9OjedgtN5EJGL0eAHoN+0mRgMgtGExcxqWoJs8lM2Ou5QcBiqgUcTByg96agQx/UuER2ynsUowR6AmYhoadWkhWZst4cQ6TtQMXxbqtHPqBYC12N/GBGpp/mzR1wq1G9Oz/QhUvHHVB0W3B069ToM13eTfqIchhqkWTiYEIxcR8x5FO41aiepPdMOo6wmIk3kX4OOp0uYIRiGDcgmId7QDFxlxG8fmEH3GpUHemASccRmo60SF1GVzmoXwOTY6orMnqEJB4FtHHoJ1vXVhBytX0e5DgsfZI0kf6R4nFICEWKNxIQ5PfgZtudsTJgFAcEbdeTdZUMDqPXUXmyuVosbesxio2RDdiOI/R7qaPIIkbQ5rVlLI6tq4Wioorqy2THuaWTJr7HGGdb15bYulpo9VlEwXKj9VdvPoa9VPsmm5NRHntaqTgAKttVlnttrm20UtFLMGBObJ0RFQWYxJdP/z9kx9wes8NUbcmz1FF5tl1ldFuyVjCJXqKDc7KulqSj6BCmZBDVyEAbzLauLcgRSDwm0YV0MNMnpzIDPUqajDB+gTqXjNZa7Sl0KlNbq0yypDIDfc68NG3AuXO1QC+epteLKDI/Zc6rp+Oc2kRVoy2x6FzayeV8WfjlrD7XkjjPzULbXaQXvbqqhWY6rNIstEl6zrqqxXEMzEKH6sBjvaylcOX5bxh8D8icdVMLt8rx7yV01Qjj6O9rCRxzrENXAseV/wBBvHhFEBUAAA=="

DEFAULT_DOWNLOADS_DIR="/tmp/anime-manager/webtorrent"
MEDIA_PLAYERS="mpv | iina | vlc"
DEFAULT_LINUX_PLAYER="mpv"
DEFAULT_DARWIN_PLAYER="iina"

lines_to_remove=0
playlist_mode=0
LINENO=0
# Message color palette
RESET="\033[0m"
MSG_INFO_COLOR="\033[38;2;255;255;224m" # lightyellow
MSG_WARN_COLOR="\033[38;2;255;165;0m"   # orange
MSG_ERR_COLOR="\033[31m"                # red
MSG_HELP_COLOR="\033[1;34m"             # lightblue, bold
TITLE_COLOR="\033[33m"                  # yellow
SUBTITLE_COLOR="\033[1;34m"             # lightblue, bold
INCOGNITO_MODE_COLORS="\033[37;45m"     # magenta bg, white fg
OVERWRITE='\r\033[1A\033[0K'

DATE_MONTH=$(date "+%m")
DATE_DAY=$(date "+%d")
CONFIG_PATH="$HOME/.config/anime-manager"
LOG_DIR="$CONFIG_PATH/log"
TMP_PATH="/tmp/anime-manager"

cached_playback=0
animdl_playthrough=0
AUTOINSTALL=0
GLOBAL_TRACKMA_FIFO=""
# Define player socket for ipc comms. Standard naming: all socket files must
# be in this path with this file name for compatibility with third party
# tools. Can be updated if compatibility issues arise.
MEDIA_PLAYER_VLC_SOCKET="/tmp/vlcsocket"
MEDIA_PLAYER_MPV_SOCKET="/tmp/mpvsocket"
MEDIA_PLAYER_IINA_SOCKET="/tmp/iinasocket"

ANIMDL_CONF_FILE="$CONFIG_PATH/animdl_config.yml"
PLAYER_LOGFILE="$CONFIG_PATH/log/media_player.log"
NYAA_SEARCH_BIN="$(getcwd)/lib/nyaa_search.py"
NYAA_SEARCH_LOGFILE="$LOG_DIR/nyaa_search.log"
NYAA_FE_LOGFILE="$LOG_DIR/file_extractor.log"
NYAA_FE_BIN="$(getcwd)/lib/file_extractor.py"
WEBTORRENT_CLI="lib/webtorrent-cli/bin/cmd.js"

# logfiles
WEBTORRENT_LOGFILE="$LOG_DIR/webtorrent.log"
TRACKMA_LOGFILE="$LOG_DIR/trackma.log"
# CURRENTLY_PLAYING_LOGFILE="$CONFIG_PATH/now_playing.log"
ANIMDL_LOGFILE="$LOG_DIR/animdl.log"
# webtorrent globals
# torrent status codes
TORRENT_TMOUT=20
TORRENT_STATUS_OKPLAYING=0
TORRENT_STATUS_STALLED=1
TORRENT_STATUS_ERRORED=2
file_list=""
webtorrentpid=""
# threshold percentage of video duration that when reached will
# trigger the episode to be set as watched
MEDIA_PLAYER_PERCENT_WATCHED=80
# player status codes
PLAY_STATUS_WAITING=0
PLAY_STATUS_OKPLAYING=1
PLAY_STATUS_ERRORED=2
PLAY_STATUS_EXITED=3
# PLAY_STATUS_OFFLINE=4
PLAY_STATUS_FILE_SEL=5
PLAY_STATUS_SEARCH_SYNONYM=6
PLAY_STATUS_SELECT_SOURCE=7
play_status=$PLAY_STATUS_WAITING
# nyaa search return codes, corresponds with lib/return_codes.py
NYAA_SEARCH_CODE_NO_RESULTS="-1"
NYAA_SEARCH_CODE_FATAL_ERROR="-3"
NYAA_FID_CODE_CONTENT_MISMATCH="-6"

export BACK_MSG
export TO_MAIN_MENU
export SWITCH_STATUS_MSG_MENU_ENTRY
export TRACKMA_ENTRY_REGEX
export TRACKMA_LOGFILE
export MEDIA_PLAYER_PERCENT_WATCHED

# fzf colors
export FZF_DEFAULT_OPTS='--color=fg:#ffffff,bg:-1,hl:#ba9c41 --color=fg+:#ffbf00,bg+:#262626,hl+:#5fd7ff --color=info:#ffffff,prompt:#ffbf00,pointer:#af5fff --color=marker:#87ff00,spinner:#af5fff,header:#d7005f --color=label:#ffbf00'

# regex for extracting trackma results
# gets the whole series list
TRACKMA_LIST_REGEX="^\|[[:space:]]+([0-9]+[[:space:]]+.*[0-9]+[[:space:]]+\/[[:space:]]+[0-9?]+[[:space:]]+[0-9]+).*\|$"
# gets the multiple parts of an entry, by matching groups
#	1- list index
#	2- anime title fragment
#	3- unused
#	4- last watched ep
#	5- end episode
#	6- series score
# Caveat: removing possesive quantifier makes the \2 match to end
# with a residual dot, we will have to remove it with sed.
# We also have no way of making a distinction between series that
# actually end with a dot from a residual dot.
TRACKMA_ENTRY_REGEX="^([[:digit:]]+)[[:space:]]+(([^.]*|.*))\.*[[:space:]]+([[:digit:]]+)[[:space:]]\/[[:space:]]([[:digit:]]+|\?)[[:space:]]+([[:digit:]]+)$"
# mainmenu entries
WATCH_HISTORY="👁️  Watch History"
WATCH="📺 Watch"
WATCH_RANDOM="🔀 Watch Random"
ADD_ANIME="🧩 Add Anime"
LIST="📙 Lists"
UPDATE_STATUS="🔄 Update Anime Status"
SCORE_SHOW="👍 Score Anime"
EXIT_INCOGNITO_MODE="👤 Exit Incognito Mode"
ENTER_INCOGNITO_MODE="🕵️  Enter Incognito Mode"
TO_SUBMENU="MORE OPTIONS ▸"
BACK_TO_SUBMENU="◂ BACK"
# submenu entries
PLAYLIST="Create Playlist 🎦"
SWITCH_ACCOUNTS="Switch Accounts 👤"
DELETE_ANIME="Delete Anime 🗑️"
WATCH_RAND_AIRING="Watch Random Anime (Currently Airing 🆕)"
LIST_AIRING="List Anime (Currently Airing 🆕)"
UPDATE_EPISODES="Update Anime Episodes 🔄"
SET_ALTNAME="Set Alternative Name 📝"
PULL="Pull Lists from Remote ↓"
PUSH="Push Local Lists to Remote ↑"
LIST_BY_SCORE="List Anime (Sort by Rating 🌟)"
TO_MAIN_MENU="◂ MAIN MENU"
SELECT_SOURCE="◂ SELECT SOURCE"
DELETE_HIST="🗑️  Delete watch history"
SWITCH_STATUS_MSG_MENU_ENTRY="🔄 SWITCH STATUS"
# used in account_menu, incognito_menu
PLAY_METHOD_TORRENTING="😺 Search Nyaa Torrents (torrenting)"
PLAY_METHOD_SAVED_LINK="🔖 Load from Bookmarks (torrenting)"
PLAY_METHOD_STREAMING="💡 Play with animdl (streaming)"
PLAY_METHOD_MAGNET="🧲 Play a magnet link (torrenting)"
NYAA_SEARCH_SYNONYM="🔎 Search again using a title synonym"
MAIN_MENU_HELPTEXT="
🕵️  Switch Incognito Mode on. Browse and watch without syncing your activity with any account.
───
👍  Score an anime or change an anime score.
───
🔄  Update the status of your anime.
───
📙  Browse all your lists. It can also play anime.
───
🧩  Add a new anime to your Plan to Watch list.
───
🔀  Select one random anime from your watching lists (watching, rewatching) and play it.
───
📺  Open your watching lists (watching, rewatching) for playing an anime.
───
👁️  Your watching history with anime and episode count.
"

SUB_MENU_HELPTEXT="
🌟  Display your lists in descending order by score.
───
↑  Upload your local progress to your tracking service.
───
↓  Download your remote progress and update your local lists.
───
📝  Set the alternative name for an anime.
───
🔄  Update your watching progress on an anime.
───
🆕  Display your lists by showing currently airing anime only.
───
🆕  Play one random, currently airing anime from your watching lists (watching, rewatching).
───
🗑️  Delete an anime from your lists. You will lose all your progress on that anime.
───
👤  Switch between the various accounts connected to Trackma.
"
# used in media_player_menu
PLAYER_MENU_FILE_SELECT_CODE=0
PLAYER_MENU_END_CODE=1
PLAYER_MENU_SELECT_SEARCH_RES_CODE=2
PLAYER_MENU_SEARCH_SYNONYM=3

# Parse arguments
parser_definition() {
    setup REST help:usage -- "Usage: anime-manager [options]..." ''
    msg -- 'Options:'
    flag AUTO_UPDATE -a --auto-update init:="0" -- "Automatically update the lists when the playback time reaches  
                              the threshold (80% of video duration)."
    flag MINIMAL -m --minimal init:="0" -- "Minimalistic interface. It does not print the logo, the menu  
                              fills the screen and is reversed. Dimmer colors."
    flag INCOGNITO_MODE -i --incognito init:="0" -- "Switch Incognito Mode on. Your activity will not be synced 
                              with the remote anime cataloguing service."
    flag MONOCHROME_LOGO --monochrome-logo init:="0" -- "Print the monochromatic logo instead of the big orange one.
                              Suitable for terminals that do not support 24-bit colors."
    flag TORRENT_ONLY -t --torrent-only init:="0" -- "Always torrent the anime selection. Always load bookmark if 
                              possible or automatically search the torrent tracker."
    param TORRENT_DOWNLOADS_DIR -f --downloads-folder init:="$DEFAULT_DOWNLOADS_DIR" -- "Full path for a persistent downloads folder for torrenting.
                              It is created if it does not exist."
    param MEDIA_PLAYER_APP -p --player pattern:"$MEDIA_PLAYERS" -- "Select the media player. Defaults to mpv or iina (macOS)
                              Available players: iina, mpv, vlc."
    flag DEBUG -d --debug init:="0" -- "Start debug mode."
    disp :usage -h --help
    disp VERSION -v --version init:="0"
}

eval "$(utils/getoptions parser_definition) exit 1"

if [ "$DEBUG" -eq 1 ]; then
    set -x
    export NYAA_DEBUG="$DEBUG"
else
    unset NYAA_DEBUG
fi

# Further validate arguments
if [ "$MONOCHROME_LOGO" -eq 1 ] && [ "$MINIMAL" -eq 1 ]; then
    printf "Error: Incompatible options --monochrome-logo, --minimal\nPlease use one or the other."
    exit
fi

if printf "%s" "$TORRENT_DOWNLOADS_DIR" | grep -- "--" >/dev/null 2>&1; then
    printf "Requires an argument: --downloads-folder\n"
    exit 1
fi

if printf "%s" "$TORRENT_DOWNLOADS_DIR" | grep -- "~" >/dev/null 2>&1; then
    printf "Full path required: --downloads-folder\n"
    exit 1
fi

if printf "%s" "$TORRENT_DOWNLOADS_DIR" | grep -- "\./" >/dev/null 2>&1; then
    printf "Full path required: --downloads-folder\n"
    exit 1
fi

if printf "%s" "$TORRENT_DOWNLOADS_DIR" | grep -- "\\$" >/dev/null 2>&1; then
    printf "Full path required: --downloads-folder\n"
    exit 1
fi

#* TRACKMA UTILITIES =====

# Returns the index of a Trackma entry.
get_entry_index_function_code='get_entry_index() {
    printf "%s" "$1" | sed -En "s/$TRACKMA_ENTRY_REGEX/\1/p"
}'
eval "$get_entry_index_function_code"

# Returns the last episode from a Trackma entry
get_last_show_episode() {
    printf "%s" "$1" | sed -En "s/$TRACKMA_ENTRY_REGEX/\5/p"
}

# Returns the last watched episode from a Trackma entry
get_last_watched_episode() {
    printf "%s" "$1" | sed -En "s/$TRACKMA_ENTRY_REGEX/\4/p"
}

# Returns the score from a Trackma entry
get_score() {
    printf "%s" "$1" | sed -En "s/$TRACKMA_ENTRY_REGEX/\6/p"
}

# get the account in use in Trackma
get_account_name() {
    while ! grep "using account" "$GLOBAL_TRACKMA_TMPFILE" >/dev/null 2>&1; do :; done
    sed -En "s/.*using account (.*)\(.*/\1/p" "$GLOBAL_TRACKMA_TMPFILE" # | sed "s/ $//g"
}

# gets the remote tracking service (mal, anilist, etc) used in trackma
# this is necessary because the lists differ between services
get_remote_tracker() {
    while ! grep "using account" "$GLOBAL_TRACKMA_TMPFILE" >/dev/null 2>&1; do :; done
    sed -En "s/.*using account (.*)\((.*)\).*/\2/p" "$GLOBAL_TRACKMA_TMPFILE"
}

get_trackma_tracker_name() {
    get_trackma_tracker_name_name="$1"
    case $get_trackma_tracker_name_name in
    "mal")
        printf "MAL"
        ;;
    "anilist")
        printf "Anilist"
        ;;
    esac
}

# Filter and return an entry from a Trackma list.
get_entry_from_title() {
    [ -z "$anime_title" ] && printf "💥 Unable to get entry (no title)." && kill $$
    while read -r get_entry_from_title_status; do
        printf "filter %s\nsearch \"^%s$\"\n" "$get_entry_from_title_status" "$anime_title" | trackma_query >/dev/null 2>&1
        while ! grep "results" "$GLOBAL_TRACKMA_TMPFILE" >/dev/null 2>&1; do :; done
        format_trackma_list_res="$(cat "$GLOBAL_TRACKMA_TMPFILE")"
        get_entry_from_title_entry="$(format_trackma_list "$format_trackma_list_res")"
        if [ -n "$get_entry_from_title_entry" ]; then
            status="$get_entry_from_title_status"
            break
        fi
    done <<EOF
$TRACKMA_STATUS_MENU_ENTRIES
EOF
    if [ -z "$get_entry_from_title_entry" ]; then
        printf "%b\n" "💥 ERROR getting entry from title (no results)."
        kill $$
    fi
    printf "%s" "$get_entry_from_title_entry"
}

# Format anime info.
format_anime_info_function_code='format_anime_info() {
    ENTRY_TEXT="\x1b[38;2;255;255;224m" # lightyellow
    ENTRY_NAME="\x1b[38;2;255;165;0m"   # orange
    RESET="\x1b[0m"
    formatted_info="$1"
    # add abbreviation for empty values
    formatted_info="$(printf "$formatted_info" | sed -E "s/^(.*):[[:space:]]\[\]/\1: N\/A/g")"
    # remove square brackets around lists
    formatted_info="$(printf "$formatted_info" | sed -E "s/\[(.*)\]/\1/g")"
    # colorize text
    formatted_info="$(printf "%b" "$formatted_info" | sed -E "1,3 s/^(.*)/${ENTRY_NAME}\1${RESET}/")"
    formatted_info="$(printf "%b" "$formatted_info" | sed -E "s/^(English):(.*)/${ENTRY_NAME}\1${RESET}:${ENTRY_TEXT}\2${RESET}/")"
    formatted_info="$(printf "%b" "$formatted_info" | sed -E "s/^(Japanese):(.*)/${ENTRY_NAME}\1${RESET}:${ENTRY_TEXT}\2${RESET}/")"
    formatted_info="$(printf "%b" "$formatted_info" | sed -E "s/^(Romaji):(.*)/${ENTRY_NAME}\1${RESET}:${ENTRY_TEXT}\2${RESET}/")"
    formatted_info="$(printf "%b" "$formatted_info" | sed -E "s/^(Synonyms):(.*)/${ENTRY_NAME}\1${RESET}:${ENTRY_TEXT}\2${RESET}/")"
    formatted_info="$(printf "%b" "$formatted_info" | sed -E "s/^(Synopsis):(.*)/${ENTRY_NAME}\1${RESET}:${ENTRY_TEXT}\2${RESET}/")"
    formatted_info="$(printf "%b" "$formatted_info" | sed -E "s/^(Type):(.*)/${ENTRY_NAME}\1${RESET}:${ENTRY_TEXT}\2${RESET}/")"
    formatted_info="$(printf "%b" "$formatted_info" | sed -E "s/^(Genres):(.*)/${ENTRY_NAME}\1${RESET}:${ENTRY_TEXT}\2${RESET}/")"
    formatted_info="$(printf "%b" "$formatted_info" | sed -E "s/^(Studios):(.*)/${ENTRY_NAME}\1${RESET}:${ENTRY_TEXT}\2${RESET}/")"
    formatted_info="$(printf "%b" "$formatted_info" | sed -E "s/^(Mean score):(.*)/${ENTRY_NAME}\1${RESET}:${ENTRY_TEXT}\2${RESET}/")"
    formatted_info="$(printf "%b" "$formatted_info" | sed -E "s/^(Status):(.*)/${ENTRY_NAME}\1${RESET}:${ENTRY_TEXT}\2${RESET}/")"
    formatted_info="$(printf "%b" "$formatted_info" | sed -E "/^(Mean score|Status|Type|Synopsis|Synonyms|Romaji|Japanese|English):(.*)/! s/(.*)/${ENTRY_TEXT}\1${RESET}/")"
    printf "\n%s\n" "$formatted_info"
}'
eval "$format_anime_info_function_code"

# returns a status code that trackma understands
get_trackma_status_code_function_code='get_trackma_status_code() {
    get_trackma_status_code_status_status="$1"
    case $get_trackma_status_code_status_status in
    "Watching" | "watching")
        printf "watching"
        ;;
    "Plan to Watch" | "plantowatch")
        printf "plantowatch"
        ;;
    "Rewatching" | "rewatching")
        printf "rewatching"
        ;;
    "Dropped" | "dropped")
        printf "dropped"
        ;;
    "Paused" | "paused")
        printf "paused"
        ;;
    "Completed" | "completed")
        printf "completed"
        ;;
    "On Hold" | "onhold")
        printf "onhold"
        ;;
    "$TO_MAIN_MENU")
        printf "%s" "$TO_MAIN_MENU"
        ;;
    "$SWITCH_STATUS_MSG_MENU_ENTRY")
        printf "%s" "$SWITCH_STATUS_MSG_MENU_ENTRY"
        ;;
    esac
}'
eval "$get_trackma_status_code_function_code"

# Update watched episodes and update watch history
set_ep_as_watched() {
    date="$(date "+%Y/%m/%d %H:%M:%S %p")"
    # avoid 'EngineError: Show already at episode X'
    if [ "$cur_anime_episode" -ne "$last_watched_ep" ]; then
        printf "update %s %s\n" "$entry_index" "$cur_anime_episode" | trackma_query >/dev/null 2>&1
        # leave the full title at the end to avoid formatting it :P
        printf "%s\n" "$date |////${cur_anime_episode}////${anime_title}" >>"$WATCH_HISTORY_FILE"
    fi
}

# set the status of an anime
set_anime_status() {
    set_anime_status_new_status="$(get_trackma_status_code "$1")"
    status="$(get_trackma_status_code "$status")"
    printf "filter %s\nstatus '%s' %s\n" "$status" "$entry_index" "$set_anime_status_new_status" | trackma_query >/dev/null 2>&1
}

filter_trackma_list_function_code='filter_trackma_list() {
    printf "%b" "$1" | sed -En "s/$TRACKMA_LIST_REGEX/\1/p"
}'
eval "$filter_trackma_list_function_code"

# returns a formatted trackma list
# it also adds status emojis to the entries
format_trackma_list() {
    format_trackma_list_list="$(filter_trackma_list "$1")"
    # remove character sequences and add an emoji next to shows currently airing
    format_trackma_list_list=$(printf '%b' "$format_trackma_list_list" | sed "s,$(printf '\033')\\[[0-9;]*[a-zA-Z],🆕 ," | sed "s,$(printf '\033')\\[[0-9;]*[a-zA-Z],,g" | sed "s,\x1B\[[0-9;]*[a-zA-Z],,g" | sed -E "/🆕/ s/(.*)\.{3}(.*)/\1\2/")
    printf "%b" "$format_trackma_list_list"
}

# cleans a trackma entry from status emoji and escape codes
# this is required for the trackma_entry_regex to work properly
clean_trackma_entry() {
    clean_trackma_entry_entry="$1"
    clean_trackma_entry_cleaned="$(printf "%s" "$clean_trackma_entry_entry" | sed -E "s/ *$//g" | sed -E "s/\.*$//g" | sed -E "s,$(printf '\033')\\[0-9;]*[a-zA-Z],," | sed -E "s,$(printf '\033')\\[0-9;]*[a-zA-Z],,g" | sed "s,\x1B\[[0-9;]*[a-zA-Z],,g" | sed "s/🆕 //g" | sed -E "s/\[.*\]//g" | sed -E "s/ $//g")"
    printf "%s" "$clean_trackma_entry_cleaned"
}

# get all the shows the user has set as watching in their lists
# for presenting in unified way
get_watching_shows() {
    get_watching_shows_rewatching=""
    get_watching_shows_watching="$(printf "filter %s\nls\n" "watching" | trackma_query)"
    get_watching_shows_watching="$(format_trackma_list "$get_watching_shows_watching")"
    if [ "$TRACKER_SERVICE" = "anilist" ]; then
        # exception for anilist
        get_watching_shows_rewatching="$(printf "filter %s\nls\n" "rewatching" | trackma_query)"
        get_watching_shows_rewatching="$(format_trackma_list "$get_watching_shows_rewatching")"
    fi
    printf "%b\n%b" "$get_watching_shows_watching" "$get_watching_shows_rewatching"
}

# Gets a full anime title from the user selection. This is a workaround for the
# caveats of our regex pattern that is unable to extract the anime title
# correctly. It will get the complete anime title from the first line in the
# information output, including any trailing dots. This title doesn't need
# cleaning because  we are not getting it from a list.
get_anime_title() {
    [ -z "$entry_index" ] && printf "💥 Unable to get anime title (no index set)." && kill $$
    [ -z "$status" ] && printf "💥 Unable to get anime title (no status set)." && kill $$
    # Split the Trackma commands in two parts otherwise the Trackma prompt gets
    # in the same line as the anime title.
    printf "filter %s\n" "$status" | trackma_query >/dev/null 2>&1
    printf "info %s\n" "$entry_index" | trackma_query >/dev/null 2>&1
    while ! grep "Status" "$GLOBAL_TRACKMA_TMPFILE" >/dev/null 2>&1; do :; done
    get_anime_title_title="$(head -n1 "$GLOBAL_TRACKMA_TMPFILE")"
    [ -z "$get_anime_title_title" ] && printf "💥 Unable to get anime title (no info)." && kill $$
    printf "%s" "$get_anime_title_title"
}

# Get a cleaned title fragment.
get_title_fragment_function_code='get_title_fragment() {
    if [ -n "$(printf "%s" "$1" | sed -En "s/$TRACKMA_ENTRY_REGEX/\2/p")" ]; then
        # raw entry
        printf "%s" "$1" | sed -En "s/$TRACKMA_ENTRY_REGEX/\2/p" | sed -E "s/ *$//g" | sed -E "s/\.*$//g" | sed -E "s,$(printf "'"\033"'")\\[0-9;]*[a-zA-Z],," | sed -E "s,$(printf "'"\033"'")\\[0-9;]*[a-zA-Z],,g" | sed "s,\x1B\[[0-9;]*[a-zA-Z],,g" | sed "s/🆕 //g" | sed -E "s/\[.*\]//g" | sed -E "s/ $//g"
    else
        printf "%s" "$1"
    fi
}'
eval "$get_title_fragment_function_code"

get_last_show_ep_from_title() {
    [ -z "$anime_title" ] && printf "💥 Unable to get last episode (no title)" && kill $$
    if [ -n "$status" ]; then
        status="$(get_trackma_status_code "$status")"
        printf "%s" "$status"
    else
        while read -r trackma_code; do
            printf "filter %s\nsearch '^%s$'\n" "$(get_trackma_status_code "$trackma_code")" "$(printf "%s" "$title_fragment" | sed "s/'/'\"'\"'/g")" | trackma_query >/dev/null 2>&1
            while ! grep "result" "$GLOBAL_TRACKMA_TMPFILE" >/dev/null 2>&1; do :; done
            # Filter by index because we may get more than one match by fragment.
            res_title="$(filter_trackma_list "$(cat "$GLOBAL_TRACKMA_TMPFILE")")"
            if [ -n "$res_title" ]; then
                last_show_episode="$(get_last_show_ep "$res_title")"
                break
            fi
        done <<EOF
$TRACKMA_STATUS_MENU_ENTRIES
EOF
        if [ -z "$status" ]; then
            printf "%b\n" "💥 ERROR getting show status."
            kill $$
        fi
        printf "%s" "$status"
    fi
}

# Gets the status of an entry. This is used when we have a menu with mixed lists
# and we want to know the status of a particular entry.
get_show_status() {
    [ -z "$entry_index" ] && printf "💥 Unable to get status (no index)" && kill $$
    [ -z "$title_fragment" ] && printf "💥 Unable to get status (no title fragment)" && kill $$
    if [ -n "$status" ]; then
        status="$(get_trackma_status_code "$status")"
        printf "%s" "$status"
    else
        while read -r trackma_code; do
            # Filter by title fragment. Escape single quotes in title for search
            # query
            printf "filter %s\nsearch '%s'\n" "$(get_trackma_status_code "$trackma_code")" "$(printf "%s" "$title_fragment" | sed "s/'/'\"'\"'/g")" | trackma_query >/dev/null 2>&1
            while ! grep "result" "$GLOBAL_TRACKMA_TMPFILE" >/dev/null 2>&1; do :; done
            # Filter by index because we may get more than one match by fragment.
            res_title="$(filter_trackma_list "$(cat "$GLOBAL_TRACKMA_TMPFILE")")"
            res_title="$(printf "%s" "$res_title" | sed -En "/^$entry_index/p")"
            if [ -n "$res_title" ]; then
                status="$(get_trackma_status_code "$trackma_code")"
                break
            fi
        done <<EOF
$TRACKMA_STATUS_MENU_ENTRIES
EOF
        if [ -z "$status" ]; then
            printf "%b\n" "💥 ERROR getting show status."
            kill $$
        fi
        printf "%s" "$status"
    fi
}

# Get anime info for an entry from a mixed list.
get_mixed_anime_info_function_code='get_mixed_anime_info() {
    if [ "$1" = "$TO_MAIN_MENU" ]; then
        get_mixed_anime_info_info="Go back to the main menu"
    else
        while read -r get_mixed_anime_info_status; do
            get_mixed_anime_info_title_fragment="$(get_title_fragment "$1")"
            get_mixed_anime_info_entry_index="$(get_entry_index "$1")"
            printf "filter %s\n" "$(get_trackma_status_code "$get_mixed_anime_info_status")" | trackma_query >/dev/null 2>&1
            printf "search '\''%s'\''\n" "$(printf "%s" "$get_mixed_anime_info_title_fragment" | sed "s/'\''/'\''\"'\''\"'\''/g")" | trackma_query >/dev/null 2>&1
            # Filter by index because we may get more than one match by fragment.
            get_mixed_anime_info_info="$(filter_trackma_list "$(cat "$GLOBAL_TRACKMA_TMPFILE"| tr -d '\''\0'\'')" | sed -En "/^$get_mixed_anime_info_entry_index/p")"
            if [ -n "$get_mixed_anime_info_info" ]; then
                printf "info '\''%s'\''\n" "$get_mixed_anime_info_entry_index" | trackma_query >/dev/null 2>&1
                while ! grep "Status" "$GLOBAL_TRACKMA_TMPFILE" >/dev/null 2>&1; do :; done
                get_mixed_anime_info_info="$(cat "$GLOBAL_TRACKMA_TMPFILE" | tr -d '\''\0'\'' | sed -n "1,/Status/p" | sed -e "s/<[^>]*>//g")"
                break
            fi
        done <<EOF
$TRACKMA_STATUS_MENU_ENTRIES
EOF
    fi
    if [ -z "$get_mixed_anime_info_info" ]; then
        printf "%s\n" "💥 ERROR getting anime info."
    else
        format_anime_info "$get_mixed_anime_info_info"
    fi
}'
eval "$get_mixed_anime_info_function_code"

# get anime series across lists or from a particular list
# this is used to play any episode from the watch history
# the status code argument should be parseable by trackma
get_show_entry() {
    status="$(get_show_status)"
    # trackma search uses regex so we need to sanitize it
    printf "filter %s\nsearch '^%s$'\n" "$(get_trackma_status_code "$status")" "$(printf "%s" "$anime_title" | sed "s/'/'\"'\"'/g")" | trackma_query >/dev/null 2>&1
    while ! grep "result" "$GLOBAL_TRACKMA_TMPFILE" >/dev/null 2>&1; do :; done
    res="$(cat "$GLOBAL_TRACKMA_TMPFILE")"
    get_show_entry_list="$(filter_trackma_list "$res")"
    # we assume we should find a result
    [ -z "$get_show_entry_list" ] &&
        printf "%b\n" "💥 ERROR getting show entry." && kill $$
    printf "%b" "$get_show_entry_list"
}

# get shows info from Trackma
get_anime_info_function_code='get_anime_info() {
    if [ "$1" = "$TO_MAIN_MENU" ]; then
        get_anime_info_info="Go back to the main menu"
    elif [ "$1" = "$SWITCH_STATUS_MSG_MENU_ENTRY" ]; then
        get_anime_info_info="Switch to another list"
    else
        get_anime_info_status="$(get_trackma_status_code "$2")"
        entry_index="$(printf "%s" "$1" | sed -En "s/$TRACKMA_ENTRY_REGEX/\1/p")"
        printf "filter %s\n" "$(get_trackma_status_code "$get_anime_info_status")" | trackma_query >/dev/null 2>&1
        printf "info '\''%s'\''\n" "$(printf "%s" "$entry_index" | sed "s/'\''/'\''\"'\''\"'\''/g")" | trackma_query >/dev/null 2>&1
        while ! grep "Status" "$GLOBAL_TRACKMA_TMPFILE" >/dev/null 2>&1; do :; done
        get_anime_info_info="$(cat "$GLOBAL_TRACKMA_TMPFILE" | sed -n "1,/Status/p" | sed -e "s/<[^>]*>//g")"
    fi
    format_anime_info "$get_anime_info_info"
}'
eval "$get_anime_info_function_code"

#*********************************
#* SYSTEM SETUP - Detect environment, autoinstall
#*********************************

OSTYPE="$(uname -s 2>/dev/null)"
if [ "$OSTYPE" = "Linux" ]; then
    DISTRO_ID="$(awk -F= '$1 == "ID" {print $2}' /etc/*-release)"
    DISTRO_VERSION="$(awk -F= '$1 == "VERSION_ID" {print $2}' /etc/*-release | sed "s/\"//g")"
fi

# set the default media player
reset_media_player_app() {
    if [ -n "$media_player_helper" ]; then
        MEDIA_PLAYER_APP="$media_player_helper"
    fi
}

# check if we can run automatic install for missing dependencies
auto_compat() {
    if [ "$OSTYPE" = "Linux" ]; then
        case $DISTRO_ID in
        "ubuntu")
            true
            ;;
        "debian")
            true
            ;;
        *)
            false
            ;;
        esac
    elif [ "$OSTYPE" = "Darwin" ]; then
        true
    else
        printf "%s" "Automatic installation does not support your platform yet\nbut we may add support for it in the future.\n\nPlease install the dependencies manually.\nhttps://github.com/anma-dev/Anime-Manager#dependencies"
        exit 0
    fi
}

# install dependencies automatically if we can
install_dependencies() {
    shell_cfg="$(get_shell_config_file)"
    install_dep_msg="🎉 Finished the autoinstall!\nRestart your shell to start using Anime Manager."
    if ! which fzf nc animdl trackma jq node "$MEDIA_PLAYER_APP" xxh128sum >/dev/null 2>&1 || [ ! -d "./lib/webtorrent-cli/node_modules" ]; then
        printf "%b" "Anime Manager can automatically install its dependencies.\nSome dependencies were not found!\n" && line_to_remove
        AUTOINSTALL=1
        AM_SHELL_CFG_MSG="### Anime Manager autoinstall ###"
        printf "%s\n" "$AM_SHELL_CFG_MSG"
        if auto_compat; then
            printf "%s" "Install missing dependencies now? [y/N] " && line_to_remove
            read -r yn </dev/tty
            if [ -z "$yn" ]; then
                yn="n"
            fi
            case "$yn" in
            [Yy]*) ;;
            [Nn]*) exit ;;
            *) printf "%s\n" "      Please answer 'yes' or 'no'." && line_to_remove ;;
            esac
        fi
        # begin installation
        if [ "$OSTYPE" = "Linux" ]; then
            printf "%s\n" "🐧 Installing Linux dependencies."
            if ! sudo -v; then
                printf "%s" "💥 Your current user account has no administrative privileges.\nRequired dependencies unable to install\nPlease contact your system administrator." && exit 1
            fi
            sudo apt update
            sudo apt -y install build-essential procps netcat curl wget file git python3-setuptools python3-pip jq xxhash
            mkdir -p "$HOME/.local/bin"
            if ! grep '$HOME/.local/bin:$PATH' "$shell_cfg"; then
                printf "\n%s\n%s\n" "$AM_SHELL_CFG_MSG" 'export PATH="$HOME/.local/bin:$PATH"' >>"$shell_cfg"
            fi
            if ! command -v "$MEDIA_PLAYER_APP"; then
                case "$MEDIA_PLAYER_APP" in
                "mpv")
                    sudo apt -y install mpv
                    ;;
                "vlc")
                    sudo apt -y install vlc
                    ;;
                esac
            fi
            if ! command -v fzf; then
                if [ -d "$HOME/.fzf" ]; then
                    printf "\n\n%s\n\n" "INSTALLATION CONFLICT! Existing $HOME/.fzf folder found!\nfzf was not installed. Please install it manually."
                else
                    # require an fzf version with label and label coloring support
                    git clone --depth 1 https://github.com/junegunn/fzf.git "$HOME/.fzf"
                    "$HOME/.fzf/install" --all --update-rc
                fi
            else
                fzf_version="$(fzf --version)"
                if [ -z "$(printf "%s" "$fzf_version" | awk -F. '$1 >= 0 && $2 >= 35 {print $0}')" ]; then
                    printf "\n\n%s\n\n" "Please manually update your fzf installation to version >= 0.35.x."
                fi
            fi
            ./utils/install-webtorrent.sh
            if ! command -v animdl; then
                # https://github.com/justfoolingaround/animdl
                pip3 install animdl
            fi
            if ! command -v trackma; then
                sudo apt install lsof
                sudo apt -y install python3-pyqt5
                # https://github.com/z411/trackma
                pip3 install pillow \
                    pydbus \
                    setuptools \
                    wheel \
                    pyinotify \
                    nyaapy \
                    anitopy \
                    'requests>=2.20.0' \
                    beautifulsoup4==4.6.0 \
                    lxml \
                    dbus-python
                pip3 install Trackma==0.8.5
            fi
        elif [ "$OSTYPE" = "Darwin" ]; then
            printf "%s" "🍏 Installing macOS dependencies."
            if ! pkgutil --pkg-info=com.apple.pkg.CLTools_Executables | grep version >/dev/null 2>&1; then
                # xcode command line tools is a dependency of nvm and homebrew
                xcode-select --install
            fi
            if ! command -v brew; then
                # Install homebrew unattended
                NONINTERACTIVE=1 /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
            fi
            if ! grep 'export PATH="/opt/homebrew/bin/:$PATH"' "$shell_cfg" >/dev/null 2>&1; then
                printf "\n%s\n%s\n" "$AM_SHELL_CFG_MSG" 'export PATH="/opt/homebrew/bin/:$PATH"' >>"$shell_cfg"
            fi
            brew install curl jq grep axel openssl@1.1 ffmpeg git xxhash
            brew install patchelf cmake automake fzf
            if ! command -v "$MEDIA_PLAYER_APP"; then
                case "$MEDIA_PLAYER_APP" in
                "mpv")
                    brew install --cask mpv
                    ;;
                "vlc")
                    brew install --cask vlc
                    ;;
                "iina")
                    brew install --cask iina
                    # we install mpv anyway because some stream providers don't go well with iina.
                    brew install --cask mpv
                    ;;
                esac
            fi
            if ! command -v animdl; then
                # https://github.com/justfoolingaround/animdl
                pip3 install animdl
            fi
            ./utils/install-webtorrent.sh
            if ! command -v trackma; then
                # https://github.com/z411/trackma
                # dbus-python module is broken on macOS and cannot be built. This means no trackma mpris support.
                # pip3 install dbus-python
                # inotify is not available on macosx-XX-arm64
                # pip3 install pyinotify
                # Installs qt5 for trackma gui
                pip3 install pillow \
                    PyQt5 \
                    pydbus \
                    setuptools \
                    setuptools_scm \
                    scikit-build \
                    nyaapy \
                    anitopy \
                    'requests>=2.20.0' \
                    beautifulsoup4==4.6.0 \
                    lxml \
                    wheel \
                    Trackma==0.8.5
            fi
        fi
        echo
        printf "%s" "$install_dep_msg"
        exit 0
    fi
}

check_setup() {
    # initial checks
    clear_modifiers
    # set default media player
    if [ -z "$MEDIA_PLAYER_APP" ]; then
        # follow defaults
        if [ "$OSTYPE" = "Darwin" ]; then
            MEDIA_PLAYER_APP="$DEFAULT_DARWIN_PLAYER"
        else
            MEDIA_PLAYER_APP="$DEFAULT_LINUX_PLAYER"
        fi
    fi
    # use node if nvm is already installed
    if ! which node >/dev/null 2>&1; then
        PLATFORM_NVM_DIR=""
        if [ -d "$HOME/.config/nvm" ]; then
            PLATFORM_NVM_DIR="$HOME/.config/nvm"
        elif [ -d "$HOME/.nvm" ]; then
            PLATFORM_NVM_DIR="$HOME/.nvm"
        fi
        if [ -d "$PLATFORM_NVM_DIR" ]; then
            export NVM_DIR="$PLATFORM_NVM_DIR"
            # shellcheck disable=SC1091
            [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh" >/dev/null 2>&1 # This loads nvm
            # shellcheck disable=SC1091
            [ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion" >/dev/null 2>&1 # This loads nvm bash_completion
            if comand -v nvm >/dev/null 2>&1; then
                nvm use node >/dev/null 2>&1
            fi
        fi
    fi
    # install animdl conf file
    if [ ! -s "$ANIMDL_CONF_FILE" ]; then
        printf "players:
    vlc:
        executable: vlc
        opts: ['--extraintf oldrc', '--rc-fake-tty', '--rc-unix %s', '--verbose=1', '--file-logging', '--logfile=%s', '--play-and-exit']
    iina:
        executable: iina-cli
        opts: ['--mpv-keep-open=no', '--mpv-log-file=%s', '--mpv-input-ipc-server=%s']
    mpv:
        executable: mpv
        opts: ['--keep-open=no', '--log-file=%s', '--input-ipc-server=%s']
" "$MEDIA_PLAYER_VLC_SOCKET" "$PLAYER_LOGFILE" "$PLAYER_LOGFILE" "$MEDIA_PLAYER_IINA_SOCKET" "$PLAYER_LOGFILE" "$MEDIA_PLAYER_MPV_SOCKET" >"$ANIMDL_CONF_FILE"
    fi
    case "$OSTYPE" in
    "Linux")
        netcat_comm="nc -U -N"
        ;;
    "Darwin")
        netcat_comm="nc -U"
        ;;
    esac
    install_dependencies
}

if [ "$OSTYPE" != "Darwin" ] && [ "$MEDIA_PLAYER_APP" = "iina" ]; then
    printf "The iina media player is not available for your platform.\n"
    exit 1
fi

mkdir -p "$TMP_PATH"
mkdir -p "$TORRENT_DOWNLOADS_DIR"
mkdir -p "$CONFIG_PATH"
mkdir -p "$LOG_DIR"
touch "$TRACKMA_LOGFILE"
printf "" >"$PLAYER_LOGFILE"

#*********************************
#* MAIN LOGIC
#*********************************

#* TRACKMA SUBPROCESS
# global long-running trackma subprocess
spawn_trackma() {
    if [ "$DEBUG" -eq 1 ]; then
        GLOBAL_TRACKMA_TMPFILE="$LOG_DIR/debug_trackma_fifo"
        echo >"$GLOBAL_TRACKMA_TMPFILE"
    else
        GLOBAL_TRACKMA_TMPFILE="$(get_temp_filename)"
    fi
    GLOBAL_TRACKMA_FIFO="$(get_temp_filename)"
    mkfifo -m 600 "$GLOBAL_TRACKMA_FIFO"
    trackma <"$GLOBAL_TRACKMA_FIFO" >"$GLOBAL_TRACKMA_TMPFILE" 2>"$TRACKMA_LOGFILE" &
    exec 3>"$GLOBAL_TRACKMA_FIFO"
    # printf "%s" " ⚙️  Starting background process, please wait..." && line_to_remove
    while [ ! -s "$GLOBAL_TRACKMA_TMPFILE" ]; do :; done
    # clear_lines
}

# Sends a query to the Trackma process and returns the result.
trackma_query_function_code='trackma_query() {
    # Reset temp file w/o adding a newline
    printf "" >"$GLOBAL_TRACKMA_TMPFILE"
    while read -r query </dev/stdin; do
        printf "%s\n" "$query" >"$GLOBAL_TRACKMA_FIFO"
    done
    # wait for various prompts as signal for operation finished
    while ! sed -En "/>>|\):/p" "$GLOBAL_TRACKMA_TMPFILE"; do :; done
    cat "$GLOBAL_TRACKMA_TMPFILE"
}'
eval "$trackma_query_function_code"

close_trackma() {
    # printf "%s" "      ⚙️  Closing background processes, please wait..." && line_to_remove
    if [ -n "$(sed -En "s/no account|Available accounts/&/p" "$GLOBAL_TRACKMA_TMPFILE")" ]; then
        printf "q\n" >"$GLOBAL_TRACKMA_FIFO"
    else
        printf "exit\n" >"$GLOBAL_TRACKMA_FIFO"
    fi
    rm "$GLOBAL_TRACKMA_FIFO"
    if [ "$DEBUG" -eq 0 ]; then
        rm "$GLOBAL_TRACKMA_TMPFILE"
    fi
    # shellcheck disable=2188
    3>&- # this syntax is valid by POSIX https://pubs.opengroup.org/onlinepubs/009695399/utilities/xcu_chap02.html#tag_02_07_06
    true # fix weird 'Syntax error: "}" missing' by the language server.
}

print_readme_first_msg() {
    if [ ! -f "$CHECKPOINTFILE" ]; then
        printf "%s" "
┌────────────────────────────────────────────────────────────────────────┐
│ READ FIRST:                                                            │
│                                                                        │
│    This program comes with ABSOLUTELY NO WARRANTY.                     │
│ Anime Manager is a file sharing program. When you run a torrent (Anime │
│ Manager can play content by the means of running a torrent), its data  │
│ will be made available to others by means of upload. Any content you   │
│ share is your sole responsibility. No further notices will be issued.  │
│                                                                        │
└────────────────────────────────────────────────────────────────────────┘

 Do you agree with this? [yes/no]: "
        while true; do
            read -r answer
            case "$answer" in
            "yes") break ;;
            "no") exit ;;
            *) printf "%s" " Please answer 'yes' or 'no': " ;;
            esac
        done
        printf "%s\n" "$answer" >"$CHECKPOINTFILE"
    fi
    tput clear
}

select_account() {
    [ "$MINIMAL" -eq 0 ] && paint_logo
    # account selection
    TRACKMA_ACCOUNTS="$(sed -nE "/[0-9]+:/p" "$GLOBAL_TRACKMA_TMPFILE")"
    if [ -n "$TRACKMA_ACCOUNTS" ]; then
        TRACKMA_ACCOUNTS_MENU_ENTRIES="$(printf "%s" "$TRACKMA_ACCOUNTS" | sed "s/^[0-9]: /👤 /g")"
    else
        TRACKMA_ACCOUNTS_MENU_ENTRIES="No account was found"
    fi
    TRACKMA_ACCOUNTS_MENU_ENTRIES="🕵️  Incognito Mode\n$TRACKMA_ACCOUNTS_MENU_ENTRIES"
    while [ -n "$(sed -En "s/no account|Available accounts/&/p" "$GLOBAL_TRACKMA_TMPFILE")" ] && [ "$INCOGNITO_MODE" -eq 0 ]; do
        account_choice=$(
            printf "%b" "$TRACKMA_ACCOUNTS_MENU_ENTRIES" |
                $FZF -i --prompt="Select an option: " \
                    --border-label "╢ ♣  ACCOUNT SELECTION ♣  ╟" \
                    --header "⇅ Navigation ─ [ESC] Exit ─ [Enter] Select" \
                    --header-first
        )
        if [ "$(printf "%s" "$account_choice" | cut -d " " -f1)" = "🕵️" ]; then
            INCOGNITO_MODE=1
            close_trackma
            break
        elif [ "$account_choice" = "No account was found" ]; then
            exit
        else
            acc_id="$(printf "%s" "$TRACKMA_ACCOUNTS" | grep "$(printf "%s" "$account_choice" | sed "s/^👤 //g")" | cut -d ":" -f1)"
            [ -z "$acc_id" ] && exit
            printf "r%s\n" "$acc_id" | trackma_query >/dev/null 2>&1
        fi
    done
    if [ "$INCOGNITO_MODE" -eq 0 ]; then
        USERNAME="$(get_account_name)"
        TRACKER_SERVICE="$(get_remote_tracker)"
    fi
    printf "ls\n" >"$GLOBAL_TRACKMA_FIFO"
    tput clear
}

check_trackma_config() {
    check_trackma_config_config_file=""
    if [ -s "$HOME"/.trackma/config.json ]; then
        check_trackma_config_config_file="$HOME/.trackma/config.json"
    elif [ -s "$HOME"/.config/trackma/config.json ]; then
        check_trackma_config_config_file="$HOME/.config/trackma/config.json"
    fi
    AUTORET_VALUE="$(jq --raw-output '.autoretrieve' "$check_trackma_config_config_file")"
    AUTOSEN_VALUE="$(jq --raw-output '.autosend' "$check_trackma_config_config_file")"
    if [ "$AUTORET_VALUE" = "always" ] || [ "$AUTOSEN_VALUE" = "always" ]; then
        printf "%b" "
💥 Anime Manager was unable to start!
   Please change the 'autoretrieve' and 'autosave' options
   in '$check_trackma_config_config_file'
   to a value other than 'always'.
"
        exit
    fi
    select_account
}

#* BOOKMARKS

# Generate and return a bookmark's filename from the anime title
get_cache_filename() {
    if [ -z "$anime_title" ]; then
        printf "💥 ERROR: unable to get bookmark file (no title).\n"
        kill $$
    fi
    get_xxhash "$(
        printf "%s" "$anime_title"
    )"
}

# saves a magnet link to a cache file
cache_link() {
    if [ -n "$magnet_link" ]; then
        cache_link_filename="$(get_cache_filename)"
        printf "%s" "$magnet_link" | gzip -cf | base64 >"$LINK_CACHE_DIR/$cache_link_filename"
    fi
}

# prints a cached magnet link
get_cached_link() {
    cached_file_content="$(cat "$LINK_CACHE_DIR/$(get_cache_filename)")"
    printf "%b\n" "$(
        base64 -d <<EOF | gunzip
$cached_file_content
EOF
    )"
}

# checks if there is a cached magnet link for the current anime title
has_cached_link() {
    if [ -s "$LINK_CACHE_DIR/$(get_cache_filename)" ]; then
        true
    else
        false
    fi
}

# deletes a cached link
delete_link_cache() {
    delete_link_cache_filename="$(get_cache_filename)"
    delete_link_cache_file="${LINK_CACHE_DIR}/${delete_link_cache_filename}"
    if [ -n "$delete_link_cache_filename" ] && [ -s "$delete_link_cache_file" ]; then
        rm -f "$delete_link_cache_file"
    fi
}

# monitors playback progress and updates anime episode count
monitor_playback_time() {
    get_playback_percent
    # check for app exit and playback percent value
    while [ -z "$(sed -En "/finished playback|\[cplayer\] EOF code: 1|\[main\] Exiting...|end of playlist, exiting/p" "$PLAYER_LOGFILE")" ] && [ "$cur_playback_percent" -lt "$MEDIA_PLAYER_PERCENT_WATCHED" ]; do
        sleep 2
        get_playback_percent
    done
    if [ -n "$cur_playback_percent" ]; then
        if [ "$cur_playback_percent" -ge "$MEDIA_PLAYER_PERCENT_WATCHED" ]; then
            set_ep_as_watched
        fi
    fi
}

# Monitor the player log file for player exit messages. This is
# part of the playlist mode to automatically play the next anime
# functionality.
monitor_media_player_app_exit() {
    while [ -z "$(sed -En "/finished playback|\[cplayer\] EOF code: 1|\[main\] Exiting...|end of playlist, exiting/p" "$PLAYER_LOGFILE")" ]; do sleep 1; done
    # re enable command log
    [ "$DEBUG" -eq 1 ] && set -x
    curl -XPOST localhost:6266 -d 'abort' >/dev/null 2>&1
}

#* MEDIA PLAYER MENU
# the menu that shows up when the media player opens
media_player_menu() {
    media_player_exit_code=""
    # block until the play status is set up
    while [ "$play_status" -eq "$PLAY_STATUS_WAITING" ]; do
        sleep 1
    done
    if [ "$play_status" -eq "$PLAY_STATUS_ERRORED" ]; then
        # fatal error, go back to mainmenu
        echo && line_to_remove
        if [ "$player_source" = "streaming" ]; then
            printf "$MSG_ERR_COLOR%s$RESET\n" "      💥 Unable to play (streaming)." && line_to_remove
        else
            printf "$MSG_ERR_COLOR%s$RESET\n" "      💥 Unable to play (torrenting)." && line_to_remove
        fi
        printf "%s\n" "      [Enter]  ◂ MAIN MENU" && line_to_remove
        # recovery menu loop
        while true; do
            read -r key
            key="$(start_substring "$key" 1)"
            if [ "$key" = "" ]; then
                line_to_remove
                clear_lines
                break
            fi
        done
        player_source="torrenting"
        nyaa_search_res=""
        file_list=""
        magnet_link=""
        media_player_exit_code="$PLAYER_MENU_END_CODE"
        return
    elif [ "$play_status" = "$PLAY_STATUS_EXITED" ]; then
        # the user decided to go to main menu
        clear_lines
        clear_modifiers
        media_player_exit_code="$PLAYER_MENU_END_CODE"
        return
    fi
    clear_lines
    if [ -z "$anime_title" ]; then
        printf "💥 anime_title is not set"
        kill $$
    fi
    trimmed_anime_title=$(trim "$anime_title")
    playing_menu=""
    if [ "$INCOGNITO_MODE" -eq 0 ]; then
        # trackma account entries
        if [ "$last_show_episode" != "?" ] && [ "$cur_anime_episode" -eq "$last_show_episode" ]; then
            playing_menu="🏁 Set as Watched\n"
            [ "$show_type" != "movie" ] && trimmed_anime_title="🏁 END! ─ $trimmed_anime_title"
        else
            playing_menu="⏭️  Set as Watched + Play next ▶\n✅ Set as Watched\n"
        fi
    fi
    # player reset entries
    if [ "$player_source" = "torrenting" ] || [ "$player_source" = "cached_link" ]; then
        # common menu for torrenting
        playing_menu="${playing_menu}🙈 Unexpected? Select another file ▸"
        if [ -n "$nyaa_search_res" ]; then
            playing_menu="${playing_menu}\n🔎 Select another search result"
        fi
        if [ "$INCOGNITO_MODE" -eq 0 ]; then
            if ! has_cached_link; then
                playing_menu="${playing_menu}\n🔖 Add magnet link to Bookmarks"
            elif has_cached_link && [ "$player_source" = "torrenting" ]; then
                # the user performed a new search, let them overwrite cached links with the new magnet
                playing_menu="${playing_menu}\n🔖 Overwrite bookmarked link\n🗑️  Delete bookmark"
            elif has_cached_link && [ "$player_source" = "cached_link" ]; then
                playing_menu="${playing_menu}\n🗑️  Delete bookmark"
            fi
        fi
    elif [ "$player_source" = "streaming" ]; then
        if [ -n "$animdl_search_index" ]; then
            playing_menu="${playing_menu}🔎 Select another search result"
        fi
    fi
    # for some reason fzf doesn't like this logic inside the label text
    media_player_menu_label="$(
        if [ -n "$show_type" ]; then
            printf "%s" " ($show_type)" | tr '[:lower:]' '[:upper:]'
        fi
    ) ─ ${trimmed_anime_title}$(
        if [ -n "$show_type" ] && [ "$show_type" != "movie" ]; then
            printf " ▶ %s" "$cur_anime_episode"
        fi
    )"
    if [ "$AUTO_UPDATE" -eq 1 ]; then
        {
            monitor_playback_time
        } &
    fi
    if [ "$playlist_mode" -eq 1 ]; then
        {
            monitor_media_player_app_exit
        } &
    fi
    FZF_PREVIEW_WINDOW_CMD="printf \"%s\" '$debug_match_info' | jq"
    media_player_menu_choice=$(printf "%b" "${playing_menu}\n${TO_MAIN_MENU}" |
        $FZF -i --prompt="Choose an action: " \
            --border-label "╢ ♣  📺  NOW PLAYING${media_player_menu_label} ♣  ╟" \
            --header "⇅ Navigation ─ [ESC] Exit ─ [Enter] Select" \
            --header-first \
            --preview "$FZF_PREVIEW_WINDOW_CMD" \
            --bind "ctrl-l:toggle-preview" \
            --preview-window "$PREVIEW_WINDOW_OPTS" \
            --bind "shift-right:change-preview-window($MENU_PREVIEW_POS_MODES)+preview:$FZF_PREVIEW_WINDOW_CMD" \
            --listen 6266 \
            --preview-label "STREAM DEBUG" | cut -d " " -f1)
    # silence loop debug log for readability
    if [ "$media_player_menu_choice" = "◂" ]; then
        prompt="$TO_MAIN_MENU"
        clear_modifiers
        media_player_exit_code="$PLAYER_MENU_END_CODE"
    elif [ "$media_player_menu_choice" = "✅" ]; then
        set_ep_as_watched
        # Do not clear modifiers when in playlist mode. This is to avoid losing
        # global state when playing more than one episode per anime.
        [ "$playlist_mode" -eq 0 ] && clear_modifiers
        media_player_exit_code="$PLAYER_MENU_END_CODE"
    elif [ "$media_player_menu_choice" = "⏭️" ]; then
        set_ep_as_watched
        if [ "$player_source" = "torrenting" ] || [ "$player_source" = "cached_link" ]; then
            # will query nyaa again or resume from cache
            if has_cached_link; then
                # if a bookmark is set switch the player source
                # for searching the next episode
                player_source="cached_link"
            else
                # If no bookmark is set switch to nyaa search.
                # This could happen if the user deleted the
                # bookmark from the 'now playing' menu.
                player_source="torrenting"
            fi
            nyaa_search_res=""
            magnet_link=""
            file_list=""
        elif [ "$player_source" = "streaming" ]; then
            animdl_playthrough=1
        fi
        play_method_menu_opt=""
        cur_anime_episode=$((cur_anime_episode + 1))
    elif [ "$media_player_menu_choice" = "🏁" ]; then
        set_ep_as_watched
        media_player_exit_code="$PLAYER_MENU_END_CODE"
    elif [ "$media_player_menu_choice" = "🔎" ]; then
        if [ "$player_source" = "streaming" ]; then
            animdl_playthrough=0
        elif [ "$player_source" = "torrenting" ] || [ "$player_source" = "cached_link" ]; then
            nyaa_search_res=""
            magnet_link=""
            file_list=""
            player_source="torrenting"
        fi
        media_player_exit_code="$PLAYER_MENU_SELECT_SEARCH_RES_CODE"
    elif [ "$media_player_menu_choice" = "🙈" ]; then
        # this will tell the select_magnet_file function to present a menu
        play_status="$PLAY_STATUS_FILE_SEL"
        # this will tell the play loop to execute play_anime function again
        media_player_exit_code="$PLAYER_MENU_FILE_SELECT_CODE"
    elif [ "$media_player_menu_choice" = "🔖" ]; then
        # add new bookmark or overwrite bookmark
        cache_link
        media_player_menu
    elif [ "$media_player_menu_choice" = "🗑️" ]; then
        # delete the bookmark for the current anime
        delete_link_cache
        media_player_menu
    fi
}

#* PLAYER LOGIC

# Torrent plays a file from a magnet link
# run completely detached from terminal for availability
torrent_magnet_link() {
    case "$MEDIA_PLAYER_APP" in
    "vlc")
        webtorrent_player_args="--extraintf oldrc --rc-fake-tty --rc-unix $MEDIA_PLAYER_VLC_SOCKET --verbose=1 --file-logging --logfile=$PLAYER_LOGFILE --play-and-exit"
        ;;
    "iina")
        webtorrent_player_args="--mpv-keep-open=no --mpv-log-file=$PLAYER_LOGFILE --mpv-input-ipc-server=$MEDIA_PLAYER_IINA_SOCKET"
        ;;
    "mpv")
        webtorrent_player_args="--keep-open=no --log-file=$PLAYER_LOGFILE --input-ipc-server=$MEDIA_PLAYER_MPV_SOCKET"
        ;;
    esac
    torrent_pid_file="$(get_temp_filename)"
    set +m
    (
        nohup node "$WEBTORRENT_CLI" download "$magnet_link" --select "$file_index" --out "$TORRENT_DOWNLOADS_DIR" --"$MEDIA_PLAYER_APP" --player-args="$webtorrent_player_args" >"$WEBTORRENT_LOGFILE" 2>&1 &
        echo $! >"$torrent_pid_file"
    )
    set -m
    # printf "%s" "$episode_data" | jq '.name' >"$CURRENTLY_PLAYING_LOGFILE"
    # remove from job queue to avoid info messages if we have to end the process with kill
    echo && line_to_remove
    printf "$MSG_INFO_COLOR%s$RESET\n" "      🚀 Torrent is playing soon (please wait...)" && line_to_remove
    play_episode_torrent_status=$(check_torrent_health "$(cat "$torrent_pid_file")")
    if [ "$play_episode_torrent_status" -eq "$TORRENT_STATUS_ERRORED" ]; then
        printf "$MSG_WARN_COLOR%s$RESET\n" "      🚫 Unable to play (torrenting)" && line_to_remove
        magnet_link=""
        play_status=$PLAY_STATUS_ERRORED
    else
        rm "$torrent_pid_file"
        play_status=$PLAY_STATUS_OKPLAYING
    fi
    # do not clear_lines here because the messages are chained
}

# gets info from a magnet link
get_magnet_info() {
    echo && line_to_remove
    printf "$MSG_INFO_COLOR%s$RESET\n" "      🗃️  Searching for matching file..." && line_to_remove
    get_magnet_info_data="$(python3 "$NYAA_FE_BIN" --title "$anime_title_match" --synonyms "$(printf "%s" "$show_synonyms")" --magnet-link "$magnet_link" --episode "$cur_anime_episode" --type "$show_type")"
    episode_data="$(printf "%s" "$get_magnet_info_data" | awk -F"////" '{print $1}' | sed "s/'/'\"'\"'/g")"
    file_list="$(printf "%s" "$get_magnet_info_data" | awk -F"////" '{print $2}')"
    file_index="$(printf "%s" "$get_magnet_info_data" | awk -F"////" '{print $3}')"
    debug_match_info=$episode_data
    # do not clear_lines here because the messages are chained
}

# get magnet content and select a file from it
# it picks the file index from the magnet file if there is no file list initialized
# or it allows the user to pick a file from the list
select_magnet_file() {
    if [ -z "$file_list" ]; then
        get_magnet_info
    fi
    [ "$file_index" = "$NYAA_FID_CODE_CONTENT_MISMATCH" ] && play_status="$PLAY_STATUS_FILE_SEL"
    if [ "$play_status" = "$PLAY_STATUS_FILE_SEL" ]; then
        if [ "$file_list" = "None" ]; then
            printf "$MSG_WARN_COLOR%s$RESET\n" "      🚫 Could not find any matching files in this magnet" && line_to_remove
            magnet_link=""
            file_list=""
            play_status=$PLAY_STATUS_ERRORED
            return
        fi
        FZF_PREVIEW_WINDOW_CMD="printf \"\n%s\n\n%b\" {}"
        file_index=$(
            printf "%b" "$file_list\n◂ NOW PLAYING" | sed "s/\"//g" |
                $FZF -i --prompt "Choose a file: " \
                    --border-label "╢ ♣  🗃️  FILE SELECTION ─ $(trim "$anime_title") ▶ $cur_anime_episode ♣  ╟" \
                    --header "⇅ Navigation ─ [ESC] Exit ─ [Ctrl-L] Expand ─ [Enter] Play ▶ (torrenting)" \
                    --header-first \
                    --preview "$FZF_PREVIEW_WINDOW_CMD" \
                    --preview-window "$PREVIEW_WINDOW_OPTS" \
                    --bind "shift-right:change-preview-window($MENU_PREVIEW_POS_MODES)+preview:$FZF_PREVIEW_WINDOW_CMD" \
                    --preview-label ' Expanded view ' \
                    --bind "ctrl-l:toggle-preview" | cut -d " " -f1
        )
    fi
}

create_playlist() {
    full_info=$(get_watching_shows)
    if [ ! "$full_info" ]; then
        full_info="Your watching list is empty"
        watch_choice=$(
            printf "%s\n%s" "$full_info" "$BACK_TO_SUBMENU" |
                $FZF -i --prompt "(multi) Choose anime for your playlist: " \
                    --border-label "╢ ♣  CREATE PLAYLIST ($(
                        if [ "$TRACKER_SERVICE" = "anilist" ]; then
                            printf "%s" "re+watching"
                        else
                            printf "%s" "watching"
                        fi
                    ) list) ♣  ╟" \
                    --header "⇅ Navigation ─ [ESC] Exit ─ [Enter] Play ▶" \
                    --header-first
        )
        clear_modifiers
    fi
    if [ "$random_anime" -eq 1 ]; then
        watch_choice=$(printf "%s" "$full_info" | shuf -n 1)
    elif [ "$random_airing" -eq 1 ]; then
        # format and filter airing shows, select one randomly
        watch_choice=$(printf "%s" "$full_info" | sed -n "/🆕/p" | shuf -n 1)
    else
        full_info="$(printf "%s" "$full_info")"
        WATCH_MENU_PREVIEW_CMD="TO_MAIN_MENU=\"$TO_MAIN_MENU\"; TRACKMA_STATUS_MENU_ENTRIES=\"$TRACKMA_STATUS_MENU_ENTRIES\"; TRACKMA_LIST_REGEX=\"$TRACKMA_LIST_REGEX\"; TRACKMA_ENTRY_REGEX=\"$TRACKMA_ENTRY_REGEX\"; GLOBAL_TRACKMA_FIFO=$GLOBAL_TRACKMA_FIFO; GLOBAL_TRACKMA_TMPFILE=$GLOBAL_TRACKMA_TMPFILE; $trackma_query_function_code; $filter_trackma_list_function_code; $get_trackma_status_code_function_code; $get_title_fragment_function_code; $get_entry_index_function_code; $format_anime_info_function_code; $get_mixed_anime_info_function_code; get_mixed_anime_info {}"
        cur_playlist=$(
            printf "%s\n%s" "$BACK_TO_SUBMENU" "$full_info" |
                $FZF -i --prompt "(multi) Choose anime for your playlist: " \
                    --multi \
                    --preview "$WATCH_MENU_PREVIEW_CMD" \
                    --preview-window "$PREVIEW_WINDOW_OPTS" \
                    --bind "shift-right:change-preview-window($MENU_PREVIEW_POS_MODES)+preview:$WATCH_MENU_PREVIEW_CMD" \
                    --preview-label ' Info ' \
                    --border-label "╢ ♣  CREATE PLAYLIST ($(
                        if [ "$TRACKER_SERVICE" = "anilist" ]; then
                            printf "%s" "re+watching"
                        else
                            printf "%s" "watching"
                        fi
                    )) list ♣  ╟" \
                    --header "⇅ Navigation ─ [Ctrl-L] Toggle info ─ [ESC] Exit ─ [Enter] Play ▶" \
                    --bind "ctrl-l:toggle-preview" \
                    --header-first --tac
        )
    fi
    if [ -n "$(printf "%s" "$cur_playlist" | sed -En "/$BACK_TO_SUBMENU/p")" ] || [ -z "$cur_playlist" ]; then
        cur_playlist=""
        return
    fi
    echo && line_to_remove
    if [ "$(printf "%b\n" "$cur_playlist" | wc -l)" -gt 1 ]; then
        printf "      🎦 How many episodes per anime?\n" && line_to_remove
    else
        printf "      🎦 How many episodes?\n" && line_to_remove
    fi
    printf "      👉 (leave blank for default) [1]: " && line_to_remove
    read -r playlist_ep_count
    playlist_ep_count="$(printf "%s" "$playlist_ep_count" | sed -E "s/[^0-9]//g")"
    if [ -z "$playlist_ep_count" ]; then
        playlist_ep_count=1
    fi
    clear_lines
}

# plays an anime episode via streaming or torrenting
play_anime() {
    reset_logs
    # reset the media player
    reset_media_player_app
    # reset media player log file
    printf "" >"$PLAYER_LOGFILE"
    while ! connectivity_check; do
        echo && line_to_remove
        printf "$MSG_WARN_COLOR%s$RESET\n" "      🌴🦕 NO INTERNET CONNECTION ・・・" && line_to_remove
        printf "$MSG_WARN_COLOR%s$RESET\n" "      Please check your connection and press [Enter]" && line_to_remove
        read -r key
        key="$(start_substring "$key" 1)"
        [ "$key" = "" ] && clear_lines && continue
    done
    if [ "$player_source" = "torrenting" ]; then
        if [ -z "$magnet_link" ]; then
            # get magnet link and play it with webtorrent-cli
            if [ -z "$nyaa_search_res" ]; then
                echo && line_to_remove
                printf "$MSG_INFO_COLOR%s$RESET\n" "      😺 Searching Nyaa Torrents. Please wait..." && line_to_remove
                nyaa_search_res="$($NYAA_SEARCH_BIN --title "$anime_title_match" --episode "$cur_anime_episode" --quality 1080 --show-type "$show_type")"
                if printf "%s" "$nyaa_search_res" | grep "////" >/dev/null 2>&1; then
                    nyaa_search_ret_msg=$(printf "%s" "$nyaa_search_res" | awk -F "////" '{print $1}')
                    nyaa_search_ret_code=$(printf "%s" "$nyaa_search_res" | awk -F "////" '{print $2}')
                fi
                if [ "$nyaa_search_ret_code" = "$NYAA_SEARCH_CODE_NO_RESULTS" ]; then
                    nyaa_search_res="{\"name\": \"$nyaa_search_ret_msg\"}"
                elif [ "$nyaa_search_ret_code" = "$NYAA_SEARCH_CODE_FATAL_ERROR" ]; then
                    echo && line_to_remove
                    printf "$MSG_WARN_COLOR%s$RESET\n" "      🚫 $nyaa_search_ret_msg" && line_to_remove
                    play_status=$PLAY_STATUS_ERRORED
                    return
                fi
                if [ "$INCOGNITO_MODE" -eq 0 ]; then
                    # incognito mode source selection menu is the same as the main menu
                    # so we do not need two options in that case
                    # incognito mode does not know about synonyms either
                    nyaa_search_res="{\"name\": \"$SELECT_SOURCE\"}\n{\"name\": \"$NYAA_SEARCH_SYNONYM\"}\n${nyaa_search_res}"
                    # replace simple quotes with 'smart quotes' to avoid filtering command failure
                    # and to not disrupt the user experience
                    nyaa_search_res="$(printf "%s" "$nyaa_search_res" | sed "s/'/’/g")"
                fi
                clear_lines
            fi
            FZF_PREVIEW_WINDOW_CMD="printf \"\n%s\n\n%b\" {} '────────────\nColor code: \n🟢 Trusted\n🔴 Remake\n⚪️ No category\n\nMore info: https://nyaa.si/help'"
            PROMPT_TEXT="Choose a search result: "
            nya_res_choice=$(
                printf "%b" "{\"name\": \"$TO_MAIN_MENU\"}\n$nyaa_search_res" | jq --raw-output '.name' |
                    $FZF -i --prompt "$PROMPT_TEXT" \
                        --border-label "╢ ♣  SEARCH RESULTS (Nyaa Torrents): $(trim "$anime_title_match") ▶ $cur_anime_episode ♣  ╟" \
                        --header "⇅ Navigation ─ [ESC] Exit ─ [Ctrl-L] Expand ─ [Enter] Play ▶ (torrenting)" \
                        --header-first \
                        --tac \
                        --preview "$FZF_PREVIEW_WINDOW_CMD" \
                        --preview-window "$PREVIEW_WINDOW_OPTS" \
                        --preview-label ' Expanded view ' \
                        --bind "ctrl-l:toggle-preview" \
                        --bind "shift-right:change-preview-window($MENU_PREVIEW_POS_MODES)+preview:$FZF_PREVIEW_WINDOW_CMD" \
                        --bind "ctrl-l:toggle-preview" \
                        --bind "ctrl-b:change-prompt($(printf "\033[44;37m BLU-RAY: \033[0m"))+reload:printf \"%b\" '$nyaa_search_res' | jq --raw-output '.name' | sed -En '/[bB][dD]|[bB][lL][uU][\-]*[rR][aA][yY]/p'" \
                        --bind "tab:change-prompt($PROMPT_TEXT)+reload:printf \"%b\" '{\"name\": \"$TO_MAIN_MENU\"}\n$nyaa_search_res' | jq --raw-output '.name'" \
                        --bind "ctrl-a:change-prompt($(printf "\033[43;37m DUAL-AUDIO: \033[0m"))+reload:printf \"%b\" '$nyaa_search_res' | jq --raw-output '.name' | sed -n '/[dD][uU][aA][lL]/p'" \
                        --bind "ctrl-d:change-prompt($(printf "\033[46;37m DUBBED: \033[0m"))+reload:printf \"%b\" '$nyaa_search_res' | jq --raw-output '.name' | sed -n '/[dD][uU][bB]/p'" \
                        --bind "ctrl-r:change-prompt($(printf "\033[101;37m RAW: \033[0m"))+reload:printf \"%b\" '$nyaa_search_res' | jq --raw-output '.name' | sed -n '/[rR][aA][wW]/p'" \
                        --bind "ctrl-s:change-prompt($(printf "\033[103;90m SUBBED: \033[0m"))+reload:printf \"%b\" '$nyaa_search_res' | jq --raw-output '.name' | sed -n '/[sS][uU][bB]/p'" \
                        --bind "ctrl-f:change-prompt($(printf "\033[104;37m MULTI: \033[0m"))+reload:printf \"%b\" '$nyaa_search_res' | jq --raw-output '.name' | sed -n '/[mM][uU][lL][tT][iI]/p'" \
                        --bind "ctrl-v:change-prompt($(printf "\033[100;90m VHS: \033[0m"))+reload:printf \"%b\" '$nyaa_search_res' | jq --raw-output '.name' | sed -n '/[vV][hH][sS]/p'" \
                        --bind "ctrl-t:change-prompt($(printf "\033[42;37m TRUSTED: \033[0m"))+reload:printf \"%b\" '$nyaa_search_res' | jq --raw-output '.name' | sed -n '/🟢/p'" \
                        --bind "ctrl-o:change-prompt($(printf "\033[45;37m OVA: \033[0m"))+reload:printf \"%b\" '$nyaa_search_res' | jq --raw-output '.name' | sed -n '/[oO][vV][aA]/p'"
            )
            # These conditionals need to be in this order for the user to
            # be able to select a different source or synonym before exiting
            # if the search returned no results.
            if [ "$nya_res_choice" = "$NYAA_SEARCH_SYNONYM" ]; then
                play_status="$PLAY_STATUS_SEARCH_SYNONYM"
                return
            elif [ "$nya_res_choice" = "$SELECT_SOURCE" ]; then
                play_status="$PLAY_STATUS_SELECT_SOURCE"
                return
            elif [ "$nyaa_search_ret_code" = "$NYAA_SEARCH_CODE_NO_RESULTS" ]; then
                play_status="$PLAY_STATUS_EXITED"
                return
            elif [ "$nya_res_choice" = "$TO_MAIN_MENU" ]; then
                play_status="$PLAY_STATUS_EXITED"
                return
            elif [ -z "$nya_res_choice" ]; then
                play_status="$PLAY_STATUS_EXITED"
                return
            fi
            magnet_link="$(printf "%b" "$nyaa_search_res" | jq -c "select( .name == \"$nya_res_choice\" )" | jq --raw-output ".magnet")"
        fi
        select_magnet_file
        [ "$file_index" = "◂" ] && play_status=$PLAY_STATUS_OKPLAYING && return
        if [ "$play_status" = "$PLAY_STATUS_ERRORED" ]; then
            # could not find matching file
            return
        fi
        if [ "$file_index" = "$NYAA_SEARCH_CODE_FATAL_ERROR" ]; then
            printf "$MSG_WARN_COLOR%s$RESET\n" "      🚫 FATAL ERROR!" && line_to_remove
            magnet_link=""
            file_list=""
            play_status=$PLAY_STATUS_ERRORED
            return
        elif [ -z "$file_index" ]; then
            # return to 'now playing' menu
            play_status=$PLAY_STATUS_OKPLAYING
            return
        else
            torrent_magnet_link
        fi
    elif [ "$player_source" = "streaming" ]; then
        stream_providers=$(array "animepahe" "allanime")
        echo && line_to_remove
        printf "$MSG_INFO_COLOR%s$RESET\n" "      💡 Streaming (animdl)" && line_to_remove
        while IFS= read -r provider; do
            decoded_stream_provider=$(printf '%s\n' "$provider" | array_element_decode)
            if [ "$animdl_playthrough" -eq 0 ]; then
                play_episode_stream_fifo_write="$(get_temp_filename)"
                mkfifo -m 600 "$play_episode_stream_fifo_write"
                # switch temporarily to mpv in exceptional case
                if [ "$decoded_stream_provider" = "allanime" ] && [ "$MEDIA_PLAYER_APP" = "iina" ]; then
                    # iina doesn't go well with allanime
                    # save player in helper var
                    media_player_helper="iina"
                    MEDIA_PLAYER_APP="mpv"
                fi
                stream_pid_file="$(get_temp_filename)"
                set +m
                (
                    ANIMDL_CONFIG="$ANIMDL_CONF_FILE" nohup animdl stream "$decoded_stream_provider:$anime_title_match" --range "$cur_anime_episode" --player "$MEDIA_PLAYER_APP" <"$play_episode_stream_fifo_write" >"$ANIMDL_LOGFILE" 2>&1 &
                    echo $! >"$stream_pid_file"
                )
                set -m
                animdl_pid="$(cat "$stream_pid_file")"
                exec 4>"$play_episode_stream_fifo_write"
                printf "$MSG_INFO_COLOR%s$RESET\n" "      🔎 Please wait, searching the stream provider ($decoded_stream_provider)..." && line_to_remove
                stream_health=20
                while [ $stream_health -gt 0 ]; do
                    # check for search result prompt
                    if ! grep "Select the search result" "$ANIMDL_LOGFILE" >/dev/null 2>&1; then
                        if grep "Could not find any streams" "$ANIMDL_LOGFILE" >/dev/null 2>&1; then
                            # stream started automatically
                            play_status=$PLAY_STATUS_ERRORED
                            printf "$MSG_INFO_COLOR%s$RESET\n" "      🚫 Could not find any streams" && line_to_remove
                            return
                        fi
                        if [ -z "$(sed -En "/AV:|libmpv|A-V|File started|Running vlc/p" "$PLAYER_LOGFILE")" ]; then
                            stream_health=$((stream_health - 1))
                        else
                            # stream started automatically
                            play_status=$PLAY_STATUS_OKPLAYING
                            printf "$MSG_INFO_COLOR%s$RESET\n" "      🚀 The stream is starting (please wait...)" && line_to_remove
                            return
                        fi
                    else
                        break
                    fi
                    sleep 1
                done
                if [ $stream_health -eq 0 ]; then
                    printf "$MSG_WARN_COLOR%s$RESET\n" "      🚫 No results found ($decoded_stream_provider), next..." && line_to_remove
                    play_status=$PLAY_STATUS_ERRORED
                    # next provider
                    echo >"$ANIMDL_LOGFILE"
                    continue
                fi
                clear_lines
                results=$(sed -En '/^[[:space:]]+[0-9]+\./p' "$ANIMDL_LOGFILE")
                animdl_search_index="$(
                    printf "%b" "$SELECT_SOURCE\n$TO_MAIN_MENU\n$results" | sed "s/^[[:space:]]*//" |
                        $FZF --prompt="Select a search result: " \
                            --border-label "╢ ♣  SEARCH RESULTS ($decoded_stream_provider): $(trim "$anime_title_match") ▶ Episode $cur_anime_episode ♣  ╟" \
                            --header "⇅ Navigation ─ [ESC] Exit ─ [Enter] Play ▶ (streaming)" \
                            --header-first \
                            --tac | cut -d '.' -f1
                )"
                if [ "$animdl_search_index" = "$SELECT_SOURCE" ]; then
                    play_status="$PLAY_STATUS_SELECT_SOURCE"
                    animdl_search_index=""
                    return
                elif [ "$animdl_search_index" = "$TO_MAIN_MENU" ]; then
                    play_status=$PLAY_STATUS_EXITED
                    animdl_search_index=""
                    return
                elif [ -z "$animdl_search_index" ]; then
                    play_status=$PLAY_STATUS_EXITED
                    animdl_search_index=""
                    return
                fi
                animdl_playthrough=1
                printf "%b" "$animdl_search_index\n" >"$play_episode_stream_fifo_write"
                # shellcheck disable=2188
                4>&-
                sleep 2 # wait for the stream to start
                stream_health=20
                printf "$MSG_INFO_COLOR%s$RESET\n" "      Trying to stream with $decoded_stream_provider" && line_to_remove
                while [ $stream_health -gt 0 ]; do
                    if [ -z "$(sed -En "/AV:|libmpv|A-V|File started|Running vlc/p" "$PLAYER_LOGFILE")" ]; then
                        stream_health=$((stream_health - 1))
                    else
                        break
                    fi
                    sleep 1
                done
                if [ $stream_health -eq 0 ]; then
                    echo && line_to_remove
                    printf "$MSG_WARN_COLOR%s$RESET\n" "      🚫 Unable to stream with $decoded_stream_provider, next..." && line_to_remove
                    play_status=$PLAY_STATUS_ERRORED
                    # next provider
                    echo "" >"$ANIMDL_LOGFILE"
                    continue
                else
                    rm "$play_episode_stream_fifo_write"
                    unset stream_tmpfile
                    unset stream_fifo_write
                    printf "$MSG_INFO_COLOR%s$RESET\n" "      🚀 The stream is starting (please wait...)" && line_to_remove
                    play_status=$PLAY_STATUS_OKPLAYING
                    return
                fi
            else
                [ -z "$animdl_search_index" ] && kill $$
                # switch temporarily to mpv in exceptional case
                if [ "$decoded_stream_provider" = "allanime" ] && [ "$MEDIA_PLAYER_APP" = "iina" ]; then
                    # iina doesn't go well with allanime
                    # save player in helper var
                    media_player_helper="iina"
                    MEDIA_PLAYER_APP="mpv"
                fi
                play_episode_stream_fifo_write="$(get_temp_filename)"
                mkfifo -m 600 "$play_episode_stream_fifo_write"
                stream_pid_file="$(get_temp_filename)"
                set +m
                (
                    ANIMDL_CONFIG="$ANIMDL_CONF_FILE" nohup animdl stream "$decoded_stream_provider:$anime_title_match" --index "$animdl_search_index" --range "$cur_anime_episode" --player "$MEDIA_PLAYER_APP" <"$play_episode_stream_fifo_write" >"$ANIMDL_LOGFILE" 2>&1 &
                    echo $! >"$stream_pid_file"
                )
                set -m
                exec 4>"$play_episode_stream_fifo_write"
                animdl_pid="$(cat "$stream_pid_file")"
                stream_health=20
                while [ $stream_health -gt 0 ]; do
                    if grep "Could not find any streams" "$ANIMDL_LOGFILE" >/dev/null 2>&1; then
                        # stream started automatically
                        play_status=$PLAY_STATUS_ERRORED
                        printf "$MSG_INFO_COLOR%s$RESET\n" "      🚫 Could not find any streams" && line_to_remove
                        return
                    fi
                    if [ -z "$(sed -En "/AV:|libmpv|A-V|File started|Running vlc/p" "$PLAYER_LOGFILE")" ]; then
                        stream_health=$((stream_health - 1))
                    else
                        break
                    fi
                    sleep 1
                done
                if [ $stream_health -eq 0 ]; then
                    echo && line_to_remove
                    printf "$MSG_WARN_COLOR%s$RESET\n" "      🚫 Unable to stream with $decoded_stream_provider" && line_to_remove
                    play_status=$PLAY_STATUS_ERRORED
                    # next provider
                    continue
                else
                    play_status=$PLAY_STATUS_OKPLAYING
                    return
                fi
            fi
        done <<EOF
$stream_providers
EOF
    elif [ "$player_source" = "self_magnet" ]; then
        echo && line_to_remove
        printf "$MSG_INFO_COLOR%s$RESET\n" "      🧲 Paste your magnet link and press Enter (silent input): " && line_to_remove
        stty_orig=$(stty -g)
        stty -echo
        read -r magnet_link
        stty "$stty_orig"
        magnet_link="$(printf "%s" "$magnet_link" | sed "s/;//g" | tr -d '\012')" # newline esc seq in octal
        clear_lines
        if [ -z "$magnet_link" ]; then
            play_status=$PLAY_STATUS_EXITED
            magnet_link=""
            return
        fi
        player_source="torrenting"
        play_anime
    elif [ "$player_source" = "cached_link" ]; then
        if has_cached_link; then
            # check for cached data
            if [ "$play_status" != "$PLAY_STATUS_FILE_SEL" ]; then
                echo && line_to_remove
                printf "$MSG_INFO_COLOR%s$RESET\n" "      🔖 Loading bookmark..." && line_to_remove
            fi
            cached_playback=1
            magnet_link="$(get_cached_link)"
            select_magnet_file
            [ "$file_index" = "◂" ] && play_status=$PLAY_STATUS_OKPLAYING && return
            if [ "$file_index" = "$NYAA_SEARCH_CODE_FATAL_ERROR" ]; then
                printf "$MSG_WARN_COLOR%s$RESET\n" "      🚫 FATAL ERROR: please contact development" && line_to_remove
                printf "$MSG_WARN_COLOR%s$RESET\n" "      🚫 https://github.com/anma-dev/Anime-Manager#support" && line_to_remove
                magnet_link=""
                file_list=""
                play_status=$PLAY_STATUS_ERRORED
                return
            elif [ -z "$file_index" ]; then
                # return to 'now playing' menu
                play_status=$PLAY_STATUS_OKPLAYING
                return
            else
                torrent_magnet_link
            fi
        fi
    fi
}

#* INCOGNITO MENU
#
# The menu that is presented when the user switches incognito mode on.
incognito_menu() {
    tput clear
    INCOGNITO_MENU_HELPTEXT="
👤  Switch Incognito Mode off.
───
💡  Stream with animdl. You will need to type a search query and episode number. This option uses streaming for playing content.
───
😺  Search Nyaa Torrents. You will need to type a search query, type and episode number and select a search result to play it. This option uses torrenting for playing content.
"
    INCOGNITO_MENU_ENTRIES="$PLAY_METHOD_TORRENTING\n$PLAY_METHOD_STREAMING\n$EXIT_INCOGNITO_MODE"
    MAINMENU_TITLE="MAIN MENU"
    menu_entries=$INCOGNITO_MENU_ENTRIES
    menu_title=$MAINMENU_TITLE
    menu_help_text=$INCOGNITO_MENU_HELPTEXT
    prompt=""
    CHECKPOINTFILE="$TMP_PATH/tmp-checkpoint"
    # always remove checkpoint file for every incognito user
    if [ -s "$CHECKPOINTFILE" ]; then
        rm -f "$CHECKPOINTFILE"
    fi
    print_readme_first_msg
    [ "$MINIMAL" -eq 0 ] && paint_logo
    [ "$MINIMAL" -eq 0 ] && print_subheader
    while true; do
        if [ -z "$prompt" ]; then
            FZF_PREVIEW_WINDOW_CMD="printf \"%s\n\" \"$menu_help_text\""
            clear_modifiers
            prompt=$(
                printf "%b" "$menu_entries" |
                    $FZF -i --prompt="Choose an action: " \
                        --border-label "╢ ♣  $menu_title ♣  ╟" \
                        --header "⇅ Navigation ─ [ESC] Exit ─ [Ctrl-L] Help ─ [Enter] Select" \
                        --header-first \
                        --preview-window "$PREVIEW_WINDOW_OPTS" \
                        --bind "shift-right:change-preview-window($MENU_PREVIEW_POS_MODES)+preview:$FZF_PREVIEW_WINDOW_CMD" \
                        --preview "$FZF_PREVIEW_WINDOW_CMD" \
                        --bind "ctrl-l:toggle-preview" \
                        --preview-label " Help "
            )
        fi
        case $prompt in
        "$PLAY_METHOD_TORRENTING")
            player_source="torrenting"
            incognito_play_msg_emoji="😺"
            prompt="PLAY"
            ;;
        "$PLAY_METHOD_STREAMING")
            player_source="streaming"
            incognito_play_msg_emoji="💡"
            prompt="PLAY"
            ;;
        "PLAY")
            echo && line_to_remove
            printf "$MSG_INFO_COLOR      %s What anime do you want to watch❔$RESET\n" "$incognito_play_msg_emoji" && line_to_remove
            printf "         👉 " && line_to_remove
            read -r anime_title
            clear_lines
            [ -z "$anime_title" ] && clear_modifiers && continue
            anime_title="$(printf "%s" "$anime_title" | sed -E 's/[^a-zA-Z0-9 ]//g' | sed "s/[[:space:]]*$//g" | sed "s/^[[:space:]]*//g")"
            echo && line_to_remove
            printf "      %s Enter an episode number if applicable\n" "$incognito_play_msg_emoji" && line_to_remove
            printf "         👉 " && line_to_remove
            read -r cur_anime_episode
            clear_lines
            cur_anime_episode="$(printf "%s" "$cur_anime_episode" | sed -E 's/[^0-9]//g')"
            if [ -z "$cur_anime_episode" ]; then
                cur_anime_episode=1
                show_type="movie"
            else
                show_type="tv"
            fi
            last_show_episode=0
            while true; do
                play_anime
                if [ "$play_status" = "$PLAY_STATUS_SELECT_SOURCE" ]; then
                    clear_modifiers
                    break # go to main menu
                elif [ "$play_status" = "$PLAY_STATUS_EXITED" ]; then
                    clear_modifiers
                    break # go to main menu
                fi
                media_player_menu
                clear_lines
                if [ "$media_player_exit_code" = "$PLAYER_MENU_SELECT_SEARCH_RES_CODE" ]; then
                    # new state already set by media_player_menu function
                    continue
                elif [ "$media_player_exit_code" = "$PLAYER_MENU_END_CODE" ]; then
                    clear_modifiers
                    break # go to main menu
                fi
            done
            ;;
        "$EXIT_INCOGNITO_MODE")
            INCOGNITO_MODE=0
            line_to_remove # remove incognito label
            clear_lines    # remove incognito label
            break
            ;;
        esac
    done
}

# Timeout the torrent process if the content is not readily available.
check_torrent_health() {
    # allow it to start first
    sleep 2
    check_torrent_health_waitingtime=0
    check_torrent_health_checkinterval=5
    check_torrent_health_torrent_status=$TORRENT_STATUS_STALLED
    check_torrent_health_webtorrentpid="$1"
    while [ $check_torrent_health_torrent_status = "$TORRENT_STATUS_STALLED" ] && [ $check_torrent_health_waitingtime -lt $TORRENT_TMOUT ]; do
        # if the torrent is not finding peers
        # before or after download start
        lastlog="$(tail -n20 "$WEBTORRENT_LOGFILE")"
        if [ -z "$(printf "%s" "$lastlog" | sed -n "/Streaming/p")" ] || [ -n "$(printf "%s" "$lastlog" | sed -n "/Peers: 0\/0/p")" ]; then
            check_torrent_health_waitingtime=$((check_torrent_health_waitingtime + check_torrent_health_checkinterval))
            sleep $check_torrent_health_checkinterval
        else
            break
        fi
    done
    if [ $check_torrent_health_waitingtime -eq $TORRENT_TMOUT ]; then
        # kill the process
        if ps "$check_torrent_health_webtorrentpid" >/dev/null 2>&1; then
            kill -9 "$check_torrent_health_webtorrentpid" >/dev/null 2>&1
        fi
        printf "%s" "$TORRENT_STATUS_ERRORED"
    else
        printf "%s" "$TORRENT_STATUS_OKPLAYING"
    fi
}

select_player_source() {
    if [ -z "$player_source" ]; then
        PLAY_METHOD_MENU="$PLAY_METHOD_TORRENTING\n$PLAY_METHOD_MAGNET\n$PLAY_METHOD_STREAMING"
        if has_cached_link; then
            PLAY_METHOD_MENU="$PLAY_METHOD_SAVED_LINK\n$PLAY_METHOD_MENU"
        fi
        if [ "$random_anime" -eq 1 ]; then
            menu_label="SELECT SOURCE: 🔀 $(trim "$anime_title") ▶ $cur_anime_episode"
            top_menu="$TO_MAIN_MENU"
        elif [ "$random_airing" -eq 1 ]; then
            menu_label="SELECT SOURCE: 🆕 $(trim "$anime_title") ▶ $cur_anime_episode"
            top_menu="$BACK_TO_SUBMENU"
        elif [ -n "$sort_airing" ] && [ "$sort_airing" -eq 1 ]; then
            # if we come from airing list selection
            menu_label="SELECT SOURCE: 🆕 $(trim "$anime_title") ▶ $cur_anime_episode"
            top_menu="$BACK_TO_SUBMENU"
        else
            menu_label="SELECT SOURCE: $(trim "$anime_title") ▶ $cur_anime_episode"
            top_menu="$TO_MAIN_MENU"
        fi
        # we check the play status otherwise we would never be able to select source
        if [ "$TORRENT_ONLY" -eq 1 ] && [ "$play_status" != "$PLAY_STATUS_SELECT_SOURCE" ]; then
            if has_cached_link; then
                player_source="cached_link"
            else
                player_source="torrenting"
            fi
        else
            play_method_menu_opt="$(
                printf "%b" "$PLAY_METHOD_MENU\n$top_menu" |
                    $FZF -i --prompt="Select a source: " \
                        --border-label "╢ ♣  $menu_label ♣  ╟" \
                        --header "⇅ Navigation ─ [ESC] Exit ─ [Enter] Select" \
                        --header-first | cut -d " " -f1
            )"
            if [ "$play_method_menu_opt" = "◂" ] || [ -z "$play_method_menu_opt" ]; then
                return
            elif [ "$play_method_menu_opt" = "💡" ]; then
                player_source="streaming"
            elif [ "$play_method_menu_opt" = "😺" ]; then
                player_source="torrenting"
            elif [ "$play_method_menu_opt" = "🧲" ]; then
                player_source="self_magnet"
            elif [ "$play_method_menu_opt" = "🔖" ]; then
                player_source="cached_link"
            fi
        fi
    fi
}

watch_anime() {
    if [ -z "$anime_title" ] && [ -z "$cur_anime_episode" ]; then
        full_info=$(get_watching_shows)
        if [ ! "$full_info" ]; then
            full_info="Your watching list is empty"
            watch_choice=$(
                printf "%s\n%s" "$full_info" "$TO_MAIN_MENU" |
                    $FZF -i --prompt "Choose an anime to watch: " \
                        --border-label "╢ ♣  YOUR $(
                            if [ "$TRACKER_SERVICE" = "anilist" ]; then
                                printf "%s" "(RE)WATCHING LISTS"
                            else
                                printf "%s" "WATCHING LIST"
                            fi
                        ) ♣  ╟" \
                        --header "⇅ Navigation ─ [ESC] Exit ─ [Enter] Play ▶" \
                        --header-first
            )
            return
        fi
        if [ "$random_anime" -eq 1 ]; then
            watch_choice=$(printf "%s" "$full_info" | shuf -n 1)
        elif [ "$random_airing" -eq 1 ]; then
            # format and filter airing shows, select one randomly
            watch_choice=$(printf "%s" "$full_info" | sed -n "/🆕/p" | shuf -n 1)
        else
            full_info="$(printf "%s" "$full_info")"
            WATCH_MENU_PREVIEW_CMD="TO_MAIN_MENU=\"$TO_MAIN_MENU\"; TRACKMA_STATUS_MENU_ENTRIES=\"$TRACKMA_STATUS_MENU_ENTRIES\"; TRACKMA_LIST_REGEX=\"$TRACKMA_LIST_REGEX\"; TRACKMA_ENTRY_REGEX=\"$TRACKMA_ENTRY_REGEX\"; GLOBAL_TRACKMA_FIFO=$GLOBAL_TRACKMA_FIFO; GLOBAL_TRACKMA_TMPFILE=$GLOBAL_TRACKMA_TMPFILE; $trackma_query_function_code; $filter_trackma_list_function_code; $get_trackma_status_code_function_code; $get_title_fragment_function_code; $get_entry_index_function_code; $format_anime_info_function_code; $get_mixed_anime_info_function_code; get_mixed_anime_info {}"
            watch_choice=$(
                printf "%s\n%s" "$TO_MAIN_MENU" "$full_info" |
                    $FZF -i --prompt "Choose an anime to watch: " \
                        --preview "$WATCH_MENU_PREVIEW_CMD" \
                        --preview-window "$PREVIEW_WINDOW_OPTS" \
                        --bind "shift-right:change-preview-window($MENU_PREVIEW_POS_MODES)+preview:$WATCH_MENU_PREVIEW_CMD" \
                        --preview-label ' Info ' \
                        --border-label "╢ ♣  YOUR $(
                            if [ "$TRACKER_SERVICE" = "anilist" ]; then
                                printf "%s" "(RE)WATCHING LISTS"
                            else
                                printf "%s" "WATCHING LIST"
                            fi
                        ) ♣  ╟" \
                        --header "⇅ Navigation ─ [Ctrl-L] Toggle info ─ [ESC] Exit ─ [Enter] Play ▶" \
                        --bind "ctrl-l:toggle-preview" \
                        --header-first --tac
            )
        fi
        [ "$watch_choice" = "$TO_MAIN_MENU" ] && prompt=$TO_MAIN_MENU && return
        if [ ! "$watch_choice" ]; then
            echo && line_to_remove
            printf "$MSG_WARN_COLOR%s$RESET\n" "      Nothing found!" && line_to_remove
            sleep 2
            clear_lines
            return
        fi
        watch_choice="$(clean_trackma_entry "$watch_choice")"
        title_fragment="$(get_title_fragment "$watch_choice")"
        #* we need to get the status and index before we get the full title.
        entry_index="$(get_entry_index "$watch_choice")"
        status="$(get_show_status)"
        anime_title=$(get_anime_title)
        last_watched_ep="$(get_last_watched_episode "$watch_choice")"
        last_show_episode="$(get_last_show_episode "$watch_choice")"
        # if we just don't know what the last episode is we increment anyways and give it a try
        if [ "$last_show_episode" = "?" ] || [ "$last_watched_ep" -lt "$last_show_episode" ]; then
            cur_anime_episode=$((last_watched_ep + 1))
        else
            cur_anime_episode="1"
        fi
    fi
    [ -z "$status" ] && printf "💥 Error no status" && kill $$
    if [ "$(get_trackma_status_code "$status")" != "$(get_trackma_status_code "Watching")" ] &&
        [ "$(get_trackma_status_code "$status")" != "$(get_trackma_status_code "Rewatching")" ]; then
        new_status="Watching"
        menu_play_options="Play ▶\n🔄 Set status as Watching + Play ▶"
        if [ "$status" = "$(get_trackma_status_code "Completed")" ]; then
            menu_play_options="Play ▶\n🔄 Set status as Watching + Reset watched + Play ▶"
            reset_episodes=1
            if [ "$TRACKER_SERVICE" = "anilist" ]; then
                new_status="Rewatching"
                menu_play_options="Play ▶\n🔄 Set status as Rewatching + Play ▶"
            fi
        else
            reset_episodes=0
        fi
        selected_play_option=$(
            printf "%b\n%s" "$menu_play_options" "$TO_MAIN_MENU" |
                $FZF -i --prompt "Choose an option: " \
                    --border-label "╢ ♣  PLAY OPTIONS ♣  ╟" \
                    --header "⇅ Navigation ─ [ESC] Exit ─ [Enter] Select" \
                    --header-first | cut -d " " -f1
        )
        if [ "$selected_play_option" = "◂" ]; then
            return
        elif [ "$selected_play_option" = "🔄" ]; then
            # update episode before updating the status otherwise the index changes
            if [ "$reset_episodes" -eq 1 ]; then
                printf "filter %s\nupdate '%s' %s\n" "$(get_trackma_status_code "$status")" "$entry_index" "0" | trackma_query >>"$TRACKMA_LOGFILE"
                cur_anime_episode="1"
                last_watched_ep="0"
            fi
            # Update anime status
            printf "filter %s\nstatus %s %s\n" "$(get_trackma_status_code "$status")" "$entry_index" "$(get_trackma_status_code "$new_status")" | trackma_query >"$TRACKMA_LOGFILE" 2>&1
            status=$new_status
            # update series index after changing lists
            printf "filter %s\nsearch '^%s$'\n" "$(get_trackma_status_code "$status")" "$(printf "%s" "$anime_title" | sed "s/'/'\\\''/g")" | trackma_query >/dev/null 2>&1
            while ! grep "result" "$GLOBAL_TRACKMA_TMPFILE" >/dev/null 2>&1; do :; done
            res="$(cat "$GLOBAL_TRACKMA_TMPFILE")"
            entry_index="$(format_trackma_list "$res" | sed -En "s/$TRACKMA_ENTRY_REGEX/\1/p")"
        fi
    fi
    # We query trackma again because we want official english and romaji titles
    show_info=$(printf "filter %s\ninfo %s\n" "$(get_trackma_status_code "$status")" "$entry_index" | trackma_query)
    while ! grep "Status" "$GLOBAL_TRACKMA_TMPFILE" >/dev/null 2>&1; do :; done
    anime_title_ro="$(printf "%s" "$show_info" | sed -n "/Romaji/p" | cut -d ":" -f2 | sed "s/ //")"
    anime_title_en="$(printf "%s" "$show_info" | sed -n "/English/p" | cut -d ":" -f2 | sed "s/ //")"
    # give preference to Romaji, then Japanese, then English titles, as this gives better matching
    if [ -n "$anime_title_ro" ] && [ "$anime_title_ro" != "None" ]; then
        anime_title_match=$anime_title_ro
    else
        anime_title_match=$anime_title
    fi

    # player loop
    play_method_menu_opt=""
    media_player_exit_code=""
    if printf "%s" "$show_info" | grep "Type: " >/dev/null 2>&1; then
        show_type="$(printf "%b" "$show_info" | grep "Type: " | awk -F": " '{print $2}')"
    fi
    if printf "%s" "$show_info" | grep "Synonyms: " >/dev/null 2>&1; then
        show_synonyms="$(printf "%b" "$show_info" | grep "Synonyms: " | awk -F": " '{print $2}')"
        show_synonyms="$anime_title, $anime_title_en, $(printf "%s" "$show_synonyms" | sed "s/[]'[]//g")"
    fi
    #* SOURCE SELECT LOOP
    while true; do
        select_player_source
        if [ "$player_source" = "◂" ] || [ -z "$player_source" ]; then
            play_status="$PLAY_STATUS_EXITED"
            prompt="$TO_MAIN_MENU"
            break
        fi
        # play loop
        while true; do
            play_anime
            if [ "$play_status" = "$PLAY_STATUS_SEARCH_SYNONYM" ]; then
                # the user wants to search again with a title synonym
                case $anime_title_match in
                "$anime_title_en")
                    [ -z "$anime_title_ro" ] && continue # does not perform a new search
                    anime_title_match="$anime_title_ro"
                    ;;
                "$anime_title_ro")
                    [ -z "$anime_title_en" ] && continue # does not perform a new search
                    anime_title_match="$anime_title_en"
                    ;;
                esac
                nyaa_search_res="" # does perform a new search
                magnet_link=""
                file_list=""
                play_status=""
                continue
            elif [ "$play_status" = "$PLAY_STATUS_SELECT_SOURCE" ]; then
                player_source=""
                break # select player source
            elif [ "$play_status" = "$PLAY_STATUS_EXITED" ]; then
                clear_modifiers
                break 2 # go to main menu
            fi
            media_player_menu
            clear_lines
            # from media player menu the user should not be able to switch play sources
            if [ "$media_player_exit_code" = "$PLAYER_MENU_FILE_SELECT_CODE" ]; then
                # new state already set by media_player_menu function
                continue
            elif [ "$media_player_exit_code" = "$PLAYER_MENU_SELECT_SEARCH_RES_CODE" ]; then
                # new state already set by media_player_menu function
                continue
            elif [ "$media_player_exit_code" = "$PLAYER_MENU_END_CODE" ]; then
                break 2 # go to main menu
            else
                # Here we break in all other cases to avoid infinite loop (for
                # example the user sent signal to script). Do not clear
                # modifiers when in playlist mode.
                break 2 # go to main menu
            fi
        done
    done
}

#* ACCOUNT MENU
#
# The menu that is presented when the user selects a Trackma account.
account_menu() {
    prompt=""
    MAINMENU_ENTRIES="$WATCH_HISTORY\n$WATCH\n$WATCH_RANDOM\n$ADD_ANIME\n$LIST\n$UPDATE_STATUS\n$SCORE_SHOW\n$ENTER_INCOGNITO_MODE\n$TO_SUBMENU"
    SUBMENU_ENTRIES="$SWITCH_ACCOUNTS\n$DELETE_ANIME\n$WATCH_RAND_AIRING\n$LIST_AIRING\n$UPDATE_EPISODES\n$SET_ALTNAME\n$PULL\n$PUSH\n$LIST_BY_SCORE\n$PLAYLIST\n$TO_MAIN_MENU"
    MAINMENU_TITLE="MAIN MENU"
    SUBMENU_TITLE="MORE OPTIONS"
    menu_entries=$MAINMENU_ENTRIES
    menu_title=$MAINMENU_TITLE
    menu_help_text=$MAIN_MENU_HELPTEXT
    AM_USER_HOME_DIR="${CONFIG_PATH}/$(printf "%s" "$USERNAME" | sed -E 's/[^A-Za-z0-9._-]/_/g')"
    mkdir -p "$AM_USER_HOME_DIR"
    CHECKPOINTFILE="${AM_USER_HOME_DIR}/checkpoint"
    print_readme_first_msg
    [ "$MINIMAL" -eq 0 ] && paint_logo
    [ "$MINIMAL" -eq 0 ] && print_subheader
    LINK_CACHE_DIR="${AM_USER_HOME_DIR}/bookmarks"
    mkdir -p "$LINK_CACHE_DIR"
    WATCH_HISTORY_FILE="${AM_USER_HOME_DIR}/watch-history"
    [ ! -f "$WATCH_HISTORY_FILE" ] && touch "$WATCH_HISTORY_FILE"
    if [ "$TRACKER_SERVICE" = "anilist" ]; then
        # exception for anilist
        TRACKMA_STATUS_MENU_ENTRIES="$(printf "%b" "Watching\nCompleted\nRewatching\nPaused\nDropped\nPlan to Watch" | sort -r)"
    else
        TRACKMA_STATUS_MENU_ENTRIES="$(printf "%b" "Watching\nCompleted\nOn Hold\nDropped\nPlan to Watch" | sort -r)"
    fi
    # account menu loop
    while true; do
        if [ -z "$prompt" ]; then
            clear_modifiers
            FZF_MAIN_MENU_PREVIEW_WINDOW_CMD="printf \"%s\" \"$menu_help_text\""
            prompt=$(
                printf "%b" "$menu_entries" |
                    $FZF -i --prompt="Choose an action: " \
                        --border-label "╢ ♣  $menu_title ♣  ╟" \
                        --header "⇅ Navigation ─ [ESC] Exit ─ [Ctrl-L] Help ─ [Enter] Select" \
                        --header-first \
                        --preview "$FZF_MAIN_MENU_PREVIEW_WINDOW_CMD" \
                        --preview-window "$PREVIEW_WINDOW_OPTS" \
                        --bind "shift-right:change-preview-window($MENU_PREVIEW_POS_MODES)+preview:$FZF_MAIN_MENU_PREVIEW_WINDOW_CMD" \
                        --bind "ctrl-l:toggle-preview" \
                        --preview-label " Help "
            )
        fi
        case $prompt in
        "$SWITCH_ACCOUNTS")
            line_to_remove # remove account label
            clear_lines    # remove account label
            printf "account\nq\n" | trackma_query >/dev/null 2>&1
            close_trackma
            # select_account
            break
            ;;
        "$ENTER_INCOGNITO_MODE")
            INCOGNITO_MODE=1
            line_to_remove # remove account label
            clear_lines    # remove account label
            close_trackma
            break
            ;;
        "$TO_MAIN_MENU")
            menu_entries=$MAINMENU_ENTRIES
            menu_title=$MAINMENU_TITLE
            menu_help_text=$MAIN_MENU_HELPTEXT
            clear_modifiers
            ;;
        "$TO_SUBMENU" | "$BACK_TO_SUBMENU")
            menu_entries=$SUBMENU_ENTRIES
            menu_title=$SUBMENU_TITLE
            menu_help_text=$SUB_MENU_HELPTEXT
            clear_modifiers
            ;;
        "$WATCH_HISTORY")
            clear_modifiers
            HIST="$(cat "$WATCH_HISTORY_FILE")"
            if [ -z "$HIST" ]; then
                sel=$(
                    printf "Your watch history is empty\n%s" "$TO_MAIN_MENU" |
                        $FZF -i --border-label "╢ ♣  WATCH HISTORY ♣  ╟" \
                            --header "⇅ Navigation ─ [ESC] Exit" \
                            --header-first
                )
            else
                HIST=$(column -t -s "////" "$WATCH_HISTORY_FILE")
                HIST="$TO_MAIN_MENU\n$DELETE_HIST\n$HIST"
                watch_hist_choice=$(
                    printf "%b" "$HIST" |
                        $FZF -i --prompt="Select an anime: " \
                            --border-label "╢ ♣  WATCH HISTORY ♣  ╟" \
                            --header "⇅ Navigation ─ [ESC] Exit ─ [Enter] Play ▶" \
                            --header-first --tac
                )
                [ "$watch_hist_choice" = "$TO_MAIN_MENU" ] && prompt=$TO_MAIN_MENU && continue
                [ "$watch_hist_choice" = "$DELETE_HIST" ] && delete_watch_history && continue
                anime_title="$(printf "%s" "$watch_hist_choice" | sed -En "s/^.*[AP]M[[:space:]]*\|[[:space:]]*[[:digit:]]*[[:space:]]*(.*)/\1/p")"
                watch_hist_entry="$(get_entry_from_title)"
                entry_index="$(get_entry_index "$watch_hist_entry")"
                title_fragment="$anime_title"
                status="$(get_show_status)"
                last_watched_ep="$(get_last_watched_episode "$watch_hist_entry")"
                last_show_episode="$(get_last_show_episode "$watch_hist_entry")"
                # only increment if it's not the last episode of the show
                # if we don't know the last aired apisode just attempt playing the next episode
                if [ "$last_show_episode" = "?" ] || [ "$last_watched_ep" -lt "$last_show_episode" ]; then
                    cur_anime_episode=$((last_watched_ep + 1))
                else
                    cur_anime_episode="1"
                fi
                prompt="$WATCH"
            fi
            ;;
        "$WATCH_RANDOM")
            random_anime=1
            prompt=$WATCH
            ;;
        "$WATCH_RAND_AIRING")
            random_airing=1
            prompt=$WATCH
            ;;
        "$WATCH")
            watch_anime
            clear_modifiers
            ;;
        "$ADD_ANIME")
            new_status="Plan to Watch"
            echo && line_to_remove
            printf "      🧩 What anime do you plan to watch❔ \n         👉 " && line_to_remove
            read -r series_title
            series_title="$(printf "%s" "$series_title" | sed -E 's/[^a-zA-Z0-9'\''" -]//g' | sed "s/'/'\\\''/g")"
            clear_lines
            if [ -z "$series_title" ]; then
                line_to_remove && clear_lines
                clear_modifiers
                continue
            fi
            results="$(printf "filter %s\nadd '%s'\n" "$(get_trackma_status_code "$new_status")" "$series_title" | trackma_query)"
            printf "$MSG_INFO_COLOR%s$RESET" "      🔎 Searching the catalog ($TRACKER_SERVICE), please wait..." && line_to_remove
            while [ -z "$(sed -En "/Choose|DataError/p" "$GLOBAL_TRACKMA_TMPFILE")" ]; do :; done
            clear_lines
            results="$(sed -En "/^[0-9]+:/p" "$GLOBAL_TRACKMA_TMPFILE")"
            [ -z "$results" ] && results="No results found.\n$TO_MAIN_MENU"
            add_anime_choice="$(
                printf "%b" "$TO_MAIN_MENU\n$results" | sort -r --version-sort |
                    $FZF --prompt="Choose the anime to add: " \
                        --border-label "╢ ♣  ADD NEW ANIME ($new_status list) ♣  ╟" \
                        --header "⇅ Navigation ─ [ESC] Exit ─ [Enter] Add" \
                        --header-first --tac
            )"
            [ -z "$results" ] && clear_modifiers && continue
            if [ "$add_anime_choice" = "$TO_MAIN_MENU" ]; then
                printf "\n" >"$GLOBAL_TRACKMA_FIFO"
                clear_modifiers && continue
            fi
            add_anime_choice_id=$(printf "%s" "$add_anime_choice" | cut -d ':' -f1)
            printf "%b\n" "$add_anime_choice_id" >"$GLOBAL_TRACKMA_FIFO"
            clear_modifiers
            ;;
        "$DELETE_ANIME")
            status=$(
                printf "%b\n%s" "$TRACKMA_STATUS_MENU_ENTRIES" "$BACK_TO_SUBMENU" |
                    $FZF -i --prompt="Choose a status: " \
                        --border-label "╢ ♣  DELETE ANIME (Status select) ♣  ╟" \
                        --header "⇅ Navigation ─ [ESC] Exit ─ [Enter] Select" \
                        --header-first
            )
            [ "$status" = "$BACK_TO_SUBMENU" ] && prompt="$BACK_TO_SUBMENU" && continue
            status=$(get_trackma_status_code "$status")
            FULL_LIST=$(printf "filter %s\nls\n" "$status" | trackma_query)
            FULL_LIST=$(format_trackma_list "$FULL_LIST")
            [ -z "$FULL_LIST" ] && FULL_LIST="No anime found in this list..."
            FULL_LIST="$BACK_TO_SUBMENU\n$SWITCH_STATUS_MSG_MENU_ENTRY\n$FULL_LIST"
            anime_sel=$(
                printf "%b" "$FULL_LIST" |
                    $FZF -i --prompt="Choose an anime to DELETE: " \
                        --border-label "╢ ♣  DELETE ANIME ($status list) ♣  ╟" \
                        --header "⇅ Navigation ─ [ESC] Exit ─ [Enter] Delete" \
                        --header-first --tac
            )
            if [ "$anime_sel" = "$BACK_TO_SUBMENU" ]; then
                prompt="$BACK_TO_SUBMENU"
                continue
            elif [ "$anime_sel" = "$SWITCH_STATUS_MSG_MENU_ENTRY" ]; then
                continue
            fi
            del_confirm=$(
                printf "%b" "$anime_sel\n$BACK_TO_SUBMENU\n$SWITCH_STATUS_MSG_MENU_ENTRY" |
                    $FZF -i --prompt="💥 💥 💥 DELETE CONFIRMATION /// THIS IS PERMANENT 💥 💥 💥 " \
                        --border-label "╢ ♣  💥 💥 💥 WARNING /// YOU ARE ABOUT TO DELETE AN ANIME!! 💥 💥 💥  ╟" \
                        --header "⇅ Navigation ─ [ESC] Exit ─ [Enter] DELETE" \
                        --header-first | cut -d" " -f1
            )
            if [ "$del_confirm" = "◂" ]; then
                prompt="$BACK_TO_SUBMENU" && continue
            elif [ "$del_confirm" = "🔄" ]; then
                continue
            else
                printf "filter %s\ndelete %s\ny\n" "$status" "$del_confirm" | trackma_query >"$TRACKMA_LOGFILE" 2>&1
            fi
            ;;
        "$UPDATE_EPISODES" | "$UPDATE_STATUS")
            if [ "$prompt" = "$UPDATE_EPISODES" ]; then
                menuitem="$BACK_TO_SUBMENU"
                update_op_menu_label="UPDATE WATCHED EPISODES"
            else
                menuitem="$TO_MAIN_MENU"
                update_op_menu_label="UPDATE STATUS"
            fi
            # status select loop
            while true; do
                status=$(
                    printf "%s\n%s" "$TRACKMA_STATUS_MENU_ENTRIES" "$menuitem" |
                        $FZF -i --prompt="Choose a status: " \
                            --border-label "╢ ♣  ${update_op_menu_label} ♣  ╟" \
                            --header "⇅ Navigation ─ [ESC] Exit ─ [Enter] Select" \
                            --header-first
                )
                [ "$status" = "$menuitem" ] && prompt=$menuitem && break
                status=$(get_trackma_status_code "$status")
                # select anime loop
                while true; do
                    res="$(printf "filter %s\nls\n" "$status" | trackma_query)"
                    res="$(format_trackma_list "$res")"
                    if [ -z "$res" ]; then
                        res="This list has no items..."
                        printf "%b" "$res\n$menuitem" | $FZF -i --prompt="Choose an anime to update: " \
                            --border-label "╢ ♣  ${update_op_menu_label} ($status list) ♣  ╟" \
                            --header "⇅ Navigation ─ [ESC] Exit ─ [Enter] Select" \
                            --header-first
                        continue
                    fi
                    update_choice="$(
                        printf "%b" "$menuitem\n$SWITCH_STATUS_MSG_MENU_ENTRY\n$res" |
                            $FZF -i --prompt="Choose an anime to update: " \
                                --border-label "╢ ♣  ${update_op_menu_label} ($status list) ♣  ╟" \
                                --header "⇅ Navigation ─ [ESC] Exit ─ [Enter] Select" \
                                --header-first --tac
                    )"
                    if [ "$update_choice" = "$SWITCH_STATUS_MSG_MENU_ENTRY" ]; then
                        break
                    elif [ "$update_choice" = "$menuitem" ] || [ -z "$update_choice" ]; then
                        prompt=$menuitem
                        break 2
                    fi
                    #* set index first
                    entry_index="$(printf "%s" "$update_choice" | sed -En "s/$TRACKMA_ENTRY_REGEX/\1/p")"
                    anime_title="$(get_anime_title)"
                    last_watched_ep="$(printf "%s" "$update_choice" | sed -En "s/$TRACKMA_ENTRY_REGEX/\4/p")"
                    if [ "$prompt" = "$UPDATE_EPISODES" ]; then
                        echo && line_to_remove
                        printf "$MSG_INFO_COLOR%s$RESET\n" "      How many episodes of this anime have you watched so far❔" && line_to_remove
                        printf "%s" "         👉 " && line_to_remove
                        read -r new_episode_count
                        new_episode_count="$(start_substring "$new_episode_count" 4)"
                        new_episode_count="$(printf "%s" "$new_episode_count" | sed -E 's/[^0-9]//g')"
                        clear_lines
                        [ -z "$new_episode_count" ] && clear_modifiers && continue
                        if [ "$new_episode_count" -ne "$last_watched_ep" ]; then
                            # this will also change the status to completed if
                            # anime last episode = updated watched episode
                            # and if the user already scored the anime
                            printf "filter %s\nupdate '%s' %s\n" "$status" "$entry_index" "$new_episode_count" | trackma_query >"$TRACKMA_LOGFILE" 2>&1
                        fi
                    elif [ "$prompt" = "$UPDATE_STATUS" ]; then
                        update_choice=$(
                            printf "%b" "$TRACKMA_STATUS_MENU_ENTRIES\n$menuitem\n$SWITCH_STATUS_MSG_MENU_ENTRY" |
                                $FZF -i --prompt="Choose the new status: " \
                                    --border-label "╢ ♣  ${update_op_menu_label} ♣  ╟" \
                                    --header "⇅ Navigation ─ [ESC] Exit ─ [Enter] Select" \
                                    --header-first
                        )
                        if [ "$update_choice" = "$SWITCH_STATUS_MSG_MENU_ENTRY" ]; then
                            break
                        elif [ "$update_choice" = "$menuitem" ] || [ -z "$update_choice" ]; then
                            prompt=$menuitem
                            break 2
                        fi
                        new_status="$(get_trackma_status_code "$update_choice")"
                        if [ -n "$entry_index" ]; then
                            trackma_update_id="$entry_index"
                        else
                            trackma_update_id="$anime_title"
                            # escape single quotes for update query
                            trackma_update_id="$(printf "%s" "$anime_title" | sed "s/'/'\"'\"'/g")"
                        fi
                        printf "filter %s\nstatus '%s' %s\n" "$status" "$trackma_update_id" "$new_status" | trackma_query >/dev/null 2>&1
                        status="$new_status"
                    fi
                done
            done
            clear_modifiers
            ;;
        "$SCORE_SHOW")
            # status selection loop
            while true; do
                status=$(
                    printf "%b" "$TRACKMA_STATUS_MENU_ENTRIES\n$TO_MAIN_MENU" |
                        $FZF -i --prompt="Choose a status: " \
                            --border-label "╢ ♣  SCORE ANIME (Status select) ♣  ╟" \
                            --header "⇅ Navigation ─ [ESC] Exit ─ [Enter] Select" \
                            --header-first
                )
                status=$(get_trackma_status_code "$status")
                [ "$status" = "$TO_MAIN_MENU" ] && prompt=$TO_MAIN_MENU && clear_modifiers && break
                # anime selection loop
                while true; do
                    full_info="$(printf "filter %s\nls\n" "$status" | trackma_query)"
                    full_info="$(format_trackma_list "$full_info")"
                    full_info="$TO_MAIN_MENU\n$SWITCH_STATUS_MSG_MENU_ENTRY\n$full_info"
                    score_anime_choice="$(
                        printf "%b" "$full_info" |
                            $FZF -i --prompt="Choose an anime to score: " \
                                --border-label "╢ ♣  SCORE ANIME ($status) ♣  ╟" \
                                --header "⇅ Navigation ─ [ESC] Exit ─ [Enter] Select" \
                                --header-first --tac
                    )"
                    [ "$score_anime_choice" = "$TO_MAIN_MENU" ] && clear_modifiers && break 2
                    [ "$score_anime_choice" = "$SWITCH_STATUS_MSG_MENU_ENTRY" ] && break
                    entry_index="$(printf "%s" "$score_anime_choice" | cut -d" " -f1)"
                    anime_title=$(get_anime_title)
                    SCORE_MENU="(10) Masterpiece\n(9) Great\n(8) Very Good\n(7) Good\n(6) Fine\n(5) Average\n(4) Bad\n(3) Very Bad\n(2) Horrible\n(1) Appalling"
                    score=$(
                        printf "%b" "$SCORE_MENU" | $FZF -i --prompt="Select a score: " \
                            --border-label "╢ ♣  SCORING ANIME: $(trim "$anime_title") ♣  ╟" \
                            --header "⇅ Navigation ─ [ESC] Exit ─ [Enter] Select" \
                            --pointer 🌟 \
                            --header-first --tac | sed -En "s/\(([[:digit:]]+)\).*/\1/p"
                    )
                    clear_lines
                    printf "filter %s\nscore %s %s\n" "$status" "$entry_index" "$score" | trackma_query >/dev/null 2>&1
                done
            done
            ;;
        "$SET_ALTNAME")
            while true; do
                status=$(
                    printf "$TRACKMA_STATUS_MENU_ENTRIES\n%s" "$BACK_TO_SUBMENU" |
                        $FZF -i --prompt="Choose a status: " \
                            --border-label "╢ ♣  SET ALTERNATIVE NAME (Status select) ♣  ╟" \
                            --header "⇅ Navigation ─ [ESC] Exit ─ [Enter] Select" \
                            --header-first
                )
                [ "$status" = "$BACK_TO_SUBMENU" ] && prompt=$BACK_TO_SUBMENU && break
                status="$(get_trackma_status_code "$status")"
                while true; do
                    full_info="$(printf "filter %s\nls\n" "$status" | trackma_query)"
                    full_info=$(format_trackma_list "$full_info")
                    [ -z "$full_info" ] && full_info="No entries in this list."
                    full_info="$BACK_TO_SUBMENU\n$SWITCH_STATUS_MSG_MENU_ENTRY\n$full_info"
                    altname_choice="$(
                        printf "%b" "$full_info" |
                            $FZF -i --prompt="Choose an anime: " \
                                --border-label "╢ ♣  SET ALTERNATIVE NAME ($status list) ♣  ╟" \
                                --header "⇅ Navigation ─ [ESC] Exit ─ [Enter] Select" \
                                --header-first --tac
                    )"
                    [ "$altname_choice" = "$BACK_TO_SUBMENU" ] && prompt=$BACK_TO_SUBMENU && break 2
                    [ "$altname_choice" = "$SWITCH_STATUS_MSG_MENU_ENTRY" ] && break
                    entry_index=$(printf "%s" "$altname_choice" | cut -d" " -f1)
                    echo && line_to_remove
                    printf "%b" "      What is the altname❔ (leave blank to clear it)\n      👉 " && line_to_remove
                    read -r altname
                    line_to_remove # user intro
                    altname="$(printf "%s" "$altname" | sed -E 's/[^a-zA-Z0-9'\''" -]//g' | sed "s/'/'\\\''/g")"
                    printf "altname %s '%s'\n" "$entry_index" "$altname" | trackma_query >"$TRACKMA_LOGFILE" 2>&1
                    clear_lines
                done
            done
            ;;
        "$PULL")
            sel=$(
                printf "🔄 Pull remote list data... (does not overwrite local changes)\n%s" "$BACK_TO_SUBMENU" |
                    $FZF -i --prompt="Choose an option: " \
                        --border-label "╢ ♣  $PULL ♣  ╟" \
                        --header "⇅ Navigation ─ [ESC] Exit ─ [Enter] Select" \
                        --header-first | cut -d" " -f1
            )
            [ "$sel" = "$BACK_TO_SUBMENU" ] && prompt=$TO_MAIN_MENU && continue
            [ "$sel" = "🔄" ] &&
                printf "retrieve\n" | trackma_query >/dev/null 2>&1
            while ! sed -En "/>>|\?/p" "$GLOBAL_TRACKMA_TMPFILE" >/dev/null 2>&1; do :; done
            if grep "There are unqueued changes" "$GLOBAL_TRACKMA_TMPFILE" >/dev/null 2>&1; then
                pull_choice=$(printf "No, keep local list\nYes, overwrite local list" |
                    $FZF -i --prompt="There are unqueued changes. Overwrite local list?" \
                        --border-label "╢ ♣  $PULL ♣  ╟" \
                        --header "⇅ Navigation ─ [ESC] Exit ─ [Enter] Select" \
                        --header-first | cut -c1)
                if [ "$pull_choice" = "N" ]; then
                    printf "N\n" | trackma_query >/dev/null 2>&1
                elif [ "$pull_choice" = "Y" ]; then
                    printf "Y\n" | trackma_query >/dev/null 2>&1
                else
                    printf "\n💥 An error occured while pulling from remote.\n"
                    exit 1
                fi
            fi
            clear_modifiers
            ;;
        "$PUSH")
            sel=$(
                printf "🔄 Overwrite remote lists\n%s" "$BACK_TO_SUBMENU" |
                    $FZF -i --prompt="Choose an option: " \
                        --border-label "╢ ♣  $PUSH ♣  ╟" \
                        --header "⇅ Navigation ─ [ESC] Exit ─ [Enter] Select" \
                        --header-first | cut -d" " -f1
            )
            [ "$sel" = "$BACK_TO_SUBMENU" ] && clear_modifiers && continue
            [ "$sel" = "🔄" ] &&
                printf "send\n" | trackma_query >/dev/null 2>&1
            clear_modifiers
            ;;
        "$PLAYLIST")
            playlist_mode=1
            AUTO_UPDATE=1
            # update subheader
            line_to_remove && clear_lines
            print_subheader
            create_playlist
            if [ "$cur_playlist" = "$BACK_TO_SUBMENU" ] || [ -z "$cur_playlist" ] || [ -z "$playlist_ep_count" ]; then
                playlist_mode=0
                # update subheader
                line_to_remove && clear_lines
                print_subheader
                clear_modifiers
                prompt="$BACK_TO_SUBMENU"
                continue
            fi
            while read -r playlist_item; do
                playlist_item="$(clean_trackma_entry "$playlist_item")"
                title_fragment="$(get_title_fragment "$playlist_item")"
                #* we need to get the status and index before we get the full title.
                entry_index="$(get_entry_index "$playlist_item")"
                status="$(get_show_status)"
                anime_title=$(get_anime_title)
                last_watched_ep="$(get_last_watched_episode "$playlist_item")"
                last_show_episode="$(get_last_show_episode "$playlist_item")"
                cur_anime_playlist_ep_count="$playlist_ep_count"
                if [ "$last_show_episode" != "?" ]; then
                    remaining_eps=$((last_show_episode - last_watched_ep))
                    if [ "$cur_anime_playlist_ep_count" -gt "$remaining_eps" ]; then
                        cur_anime_playlist_ep_count="$remaining_eps"
                    fi
                fi
                for i in $(seq 1 "$cur_anime_playlist_ep_count"); do
                    # if we don't know what the last episode is give it a try anyways
                    cur_anime_episode=$((last_watched_ep + 1))
                    watch_anime
                    if [ "$play_status" = "$PLAY_STATUS_EXITED" ]; then
                        # user cancelled the playlist
                        break 2
                    elif [ "$play_status" = "$PLAY_STATUS_ERRORED" ]; then
                        # an error occurred
                        printf "💥 Playlist ended"
                        break 2
                    fi
                    last_watched_ep="$cur_anime_episode"
                    if [ "$player_source" = "torrenting" ] || [ "$player_source" = "cached_link" ]; then
                        file_list="" # call file extractor for new episode
                    fi
                done
                # clear global state for the next anime queued in the playlist
                # queue. unsets animdl playthrough so the user will be prompted
                # again for the next anime
                clear_modifiers
            done <<EOF
$cur_playlist
EOF
            playlist_mode=0
            clear_modifiers
            prompt="$BACK_TO_SUBMENU"
            # update subheader
            line_to_remove && clear_lines
            print_subheader
            ;;
        "$LIST_AIRING")
            sort_airing=1
            prompt=$LIST
            ;;
        "$LIST_BY_SCORE")
            sort_score=1
            prompt=$LIST
            ;;
        "$LIST")
            if [ "$sort_score" -eq 1 ]; then
                top_menu_entry="$BACK_TO_SUBMENU"
            elif [ "$sort_airing" -eq 1 ]; then
                top_menu_entry="$BACK_TO_SUBMENU"
            else
                top_menu_entry="$TO_MAIN_MENU"
            fi
            status=$(
                printf "%s\n%s" "$TRACKMA_STATUS_MENU_ENTRIES" "$top_menu_entry" |
                    $FZF -i --prompt="Choose a status: " \
                        --border-label " ♣  LIST$(
                            if [ "$sort_score" -eq 1 ]; then
                                printf ' BY SCORE 🌟'
                            elif [ "$sort_airing" -eq 1 ]; then
                                printf ' AIRING SHOWS 🆕'
                            else
                                printf " SHOWS"
                            fi
                        ) (Status select) ♣  " \
                        --header "⇅ Navigation ─ [ESC] Exit ─ [Enter] Select" \
                        --header-first
            )
            [ "$status" = "$top_menu_entry" ] && prompt=$top_menu_entry && continue
            status=$(get_trackma_status_code "$status")
            if [ "$sort_score" -eq 1 ]; then
                # sort by score
                msg="$(printf "filter %s\nsort my_score\nls\n" "$status" | trackma_query)"
            else
                msg="$(printf "filter %s\nls\n" "$status" | trackma_query)"
            fi
            msg=$(format_trackma_list "$msg")
            if [ "$sort_airing" -eq 1 ]; then
                # filter airing show per user request
                msg=$(printf "%s" "$msg" | sed -n "/🆕/p")
            fi
            if [ ! "$msg" ]; then
                msg="This list has no items... "
                sel=$(
                    printf "%s\n%s\n%s" "$msg" "$top_menu_entry" "$SWITCH_STATUS_MSG_MENU_ENTRY" |
                        $FZF -i --border-label " ♣  LIST$(
                            if [ "$sort_score" -eq 1 ]; then
                                printf ' BY SCORE 🌟'
                            elif [ "$sort_airing" -eq 1 ]; then
                                printf ' AIRING SHOWS 🆕'
                            else
                                printf " SHOWS"
                            fi
                        ) ($status list) ♣  " \
                            --header "⇅ Navigation ─ [Enter] Go back" \
                            --header-first \
                            --prompt ""
                )
                [ "$sel" = "$top_menu_entry" ] && prompt="$top_menu_entry" && continue
                continue
            fi
            export status
            while true; do
                FZF_PREVIEW_WINDOW_CMD="TRACKMA_LIST_REGEX=\"$TRACKMA_LIST_REGEX\"; TRACKMA_ENTRY_REGEX=\"$TRACKMA_ENTRY_REGEX\"; GLOBAL_TRACKMA_FIFO=$GLOBAL_TRACKMA_FIFO; GLOBAL_TRACKMA_TMPFILE=$GLOBAL_TRACKMA_TMPFILE; $trackma_query_function_code; $sanitize_ext_regex_function_code; $get_title_fragment_function_code; $get_trackma_status_code_function_code; $filter_trackma_list_function_code; $format_anime_info_function_code; $get_anime_info_function_code; get_anime_info {} $status"
                # watch choice is global state and will be used by the watch prompt
                list_choice=$(
                    printf "%s\n%s\n%s" "$top_menu_entry" "$SWITCH_STATUS_MSG_MENU_ENTRY" "$msg" |
                        $FZF -i --bind "ctrl-l:toggle-preview" \
                            --preview "$FZF_PREVIEW_WINDOW_CMD" \
                            --preview-window "$PREVIEW_WINDOW_OPTS" \
                            --bind "shift-right:change-preview-window($MENU_PREVIEW_POS_MODES)+preview:$FZF_PREVIEW_WINDOW_CMD" \
                            --preview-label ' Info ' \
                            --border-label " ♣  LIST$(
                                if [ "$sort_score" -eq 1 ]; then
                                    printf ' BY SCORE 🌟'
                                elif [ "$sort_airing" -eq 1 ]; then
                                    printf ' AIRING SHOWS 🆕'
                                else
                                    printf " SHOWS"
                                fi
                            ) ($status list) ♣  " \
                            --header "⇅ Navigation ─ [Ctrl-L] Toggle info ─ [ESC] Exit ─ [Enter] Play ▶" \
                            --header-first \
                            --prompt "" \
                            --tac
                )
                [ "$list_choice" = "$top_menu_entry" ] && clear_modifiers && break
                [ "$list_choice" = "$SWITCH_STATUS_MSG_MENU_ENTRY" ] && break
                #* trackma index needs to be set first!
                entry_index="$(printf "%s" "$list_choice" | sed -En "s/$TRACKMA_ENTRY_REGEX/\1/p")"
                anime_title=$(get_anime_title)
                last_show_episode="$(printf "%s" "$list_choice" | sed -En "s/$TRACKMA_ENTRY_REGEX/\5/p")"
                last_watched_ep="$(printf "%s" "$list_choice" | sed -En "s/$TRACKMA_ENTRY_REGEX/\4/p")"
                # only increment if it's not the last episode of the show
                # if we don't know the last aired apisode just attempt playing the next episode
                # last_show_episode can be a string or integer
                if [ "$last_show_episode" = "?" ]; then
                    cur_anime_episode=$((last_watched_ep + 1))
                elif [ "$last_watched_ep" -lt "$last_show_episode" ]; then
                    cur_anime_episode=$((last_watched_ep + 1))
                else
                    cur_anime_episode="1"
                fi
                prompt="$WATCH"
                break
            done
            ;;
        esac
    done
}

#*********************************
#* ENTRYPOINT
#*********************************

# Script entry point function
main() {
    check_setup
    # common fzf args
    PREVIEW_WINDOW_OPTS="right,70%,hidden,wrap"
    MENU_PREVIEW_POS_MODES="down,70%|left,70%|top,70%|"
    if [ "$MINIMAL" -eq 1 ]; then
        # initial preview options
        FZF="fzf -0 --ansi --cycle --ellipsis (...) --color dark --pointer > --border-label-pos 1 --reverse --border top --layout=reverse --info inline --no-separator --bind change:first --no-sort"
    else
        FZF="fzf -0 --ansi --cycle --ellipsis (...) --height 70% --border rounded --pointer 👉 --margin 5% --padding=1,0,0,0 --border-label-pos -1 --bind change:first --no-sort"
    fi
    while true; do
        if [ "$INCOGNITO_MODE" -eq 0 ]; then
            spawn_trackma
            check_trackma_config
        fi
        if [ "$INCOGNITO_MODE" -eq 0 ]; then
            account_menu
        else
            incognito_menu
        fi
    done
}

# Gracefully exit the script
#* Needs to be at the end of the script
on_exit() {
    onexit_last_exit_status="$?"
    onexit_parent_lineno="$1"
    onexit_message="${2:-(no message ($onexit_last_exit_status))}"
    onexit_exit_code="${3:-$onexit_last_exit_status}"
    [ "$AUTOINSTALL" -eq 1 ] && exit "$onexit_exit_code"
    if [ "$onexit_exit_code" -eq 130 ] || [ "$onexit_exit_code" -eq 0 ]; then
        tput clear && tput clear
    else
        printf "%s\n" "ERROR on line $onexit_parent_lineno - $onexit_message - exit code $onexit_exit_code"
    fi
    if [ "$INCOGNITO_MODE" -eq 0 ]; then
        close_trackma
    fi
    # cleanup, save disk space
    if [ "$DEBUG" -eq 0 ]; then
        reset_logs
        if [ "$TORRENT_DOWNLOADS_DIR" = "$DEFAULT_DOWNLOADS_DIR" ]; then
            rm -rf "$TORRENT_DOWNLOADS_DIR"
        fi
    fi
    clear_modifiers
    exit "$onexit_exit_code"
}
#* Must go before main function call
trap 'on_exit ${LINENO}' EXIT
main
